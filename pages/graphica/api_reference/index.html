
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://crossgl.github.io/crossgl-docs/pages/graphica/api_reference/">
      
      
        <link rel="prev" href="../language/">
      
      
        <link rel="next" href="../graphica_contribution/">
      
      
      <link rel="icon" href="../../../assets/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.9">
    
    
      
        <title>API REFERENCE - CrossGL Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.4af4bdda.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="red">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-references-for-crossgl-to-directx-metal-and-opengl" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="CrossGL Documentation" class="md-header__button md-logo" aria-label="CrossGL Documentation" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CrossGL Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API REFERENCE
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/CrossGL/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    CrossGL
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
    
  
  HOME

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../dyson/overview/" class="md-tabs__link">
          
  
    
  
  DYSON

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../graphica/" class="md-tabs__link">
          
  
    
  
  GRAPHICA

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="CrossGL Documentation" class="md-nav__button md-logo" aria-label="CrossGL Documentation" data-md-component="logo">
      
  <img src="../../../assets/logo.png" alt="logo">

    </a>
    CrossGL Documentation
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CrossGL/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    CrossGL
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HOME
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    DYSON
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            DYSON
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../dyson/overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OVERVIEW
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../dyson/getting-started/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    GETTING STARTED
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../dyson/billing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    BILLING
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    GRAPHICA
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            GRAPHICA
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graphica/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OVERVIEW
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../language/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LANGUAGE
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    API REFERENCE
    
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graphica_contribution/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CONTRIBUTION
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="api-references-for-crossgl-to-directx-metal-and-opengl">API References For CrossGL To DirectX , Metal And OpenGL</h1>
<h1 id="directx-code-generation">DirectX Code Generation</h1>
<p>The [HLSLCodeGen]{.title-ref} class within the CrossGL framework is
pivotal in translating CrossGL shader abstract syntax trees (AST) into
HLSL (High-Level Shader Language) code, which is essential for DirectX
applications. This class systematically converts the AST (representing
the logical structure of a shader) into corresponding HLSL code that can
be executed in DirectX environments.</p>
<ul>
<li>
<p>Attributes</p>
<p>:   -   current_shader (ShaderNode) : The current shader node being
        processed.</p>
</li>
</ul>
<h2 id="methods">Methods</h2>
<ul>
<li>
<p><strong>__init__(self) :</strong></p>
<p>Initializes the code generator.</p>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>generate(self, ast)</strong></p>
<p>:   Generates HLSL code from the AST.</p>
<pre><code>-

    **Parameters:**

    :   -   [ast (ShaderNode)]{.title-ref} -- The abstract
            syntax tree of the shader.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>generate_shader(self, node)</strong></p>
<p>:   Generates the HLSL code for the shader.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (ShaderNode)]{.title-ref} -- The shader node
            of the AST.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>check_gl_position(self, node)</strong></p>
<p>:   Checks if the [gl_Position]{.title-ref} output is assigned within
    the vertex shader.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (ASTNode)]{.title-ref} -- The current node being
            processed in the AST.

-

    **Returns:**

    :   -   [None]{.title-ref}
</code></pre>
<p>---</p>
<p><strong>generate_intermidiate(self, node, shader_type)</strong></p>
<p>:   Generates intermediate shader code by processing a sequence of
    statements.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (list\[ASTNode\])]{.title-ref} -- A list of AST
            nodes representing the statements to be processed.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., vertex, fragment) for which the code is being
            generated.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated intermediate shader
            code as a string.
</code></pre>
<p>---</p>
<p><strong>generate_main(self, node, shader_type)</strong></p>
<p>:   Generates the main function code for a shader, tailored to the
    specified shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (FunctionNode)]{.title-ref} -- The function node
            of the AST containing the body of the main function.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., \"vertex\" or \"fragment\") for which the main
            function code is being generated.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated main function code as
            a string.
</code></pre>
<p>---</p>
<p><strong>generate_function(self, node)</strong></p>
<p>:   Generates the HLSL code for a function.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (FunctionNode)]{.title-ref} -- The function node
            of the AST.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>generate_statement(self, stmt, indent=0, is_vs_input=False)</strong></p>
<p>:   Generates the HLSL code for a statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node of
            the AST.
        -   [indent (int)]{.title-ref} -- The indentation level.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the
            statement is in the vertex shader input.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>generate_assignment(self, node, is_vs_input=False)</strong></p>
<p>:   Generates the HLSL code for an assignment statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment
            node of the AST.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the
            assignment is in the vertex shader input.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>generate_if(self, node, indent, is_vs_input=False)</strong></p>
<p>:   Generates the HLSL code for an if statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (IfNode)]{.title-ref} -- The if statement node of
            the AST.
        -   [indent (int)]{.title-ref} -- The indentation level.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the if
            statement is in the vertex shader input.

-

    **Returns:**

    :   -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>generate_for(self, node, indent, is_vs_input=False)</strong></p>
<p>:   Generates the HLSL code for a for loop statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (ForNode)]{.title-ref} -- The for loop node of the
            AST.
        -   [indent (int)]{.title-ref} -- The indentation level.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the for loop
            is in the vertex shader input.

-   **Returns:**
    -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>generate_expression(self, expr, is_vs_input=False)</strong></p>
<p>:   Generates the HLSL code for an expression.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (ASTNode)]{.title-ref} -- The expression node of
            the AST.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the
            expression is in the vertex shader input.

-   **Returns:**
    -   [str]{.title-ref} -- The generated HLSL code.
</code></pre>
<p>---</p>
<p><strong>translate_expression(self, expr, is_vs_input)</strong></p>
<p>:   Translates an expression from CrossGL syntax to HLSL syntax.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (str)]{.title-ref} -- The expression in CrossGL
            syntax.
        -   [is_vs_input (bool)]{.title-ref} -- Whether the
            expression is in the vertex shader input.

-   **Returns:**
    -   [str]{.title-ref} -- The translated expression.
</code></pre>
<p>---</p>
<p><strong>map_type(self, vtype)</strong></p>
<p>:   Maps CrossGL types to HLSL types.</p>
<pre><code>-   **Parameters:**
    -   [vtype (str)]{.title-ref} -- The CrossGL type.
-   **Returns:**
    -   [str]{.title-ref} -- The corresponding HLSL type.
</code></pre>
<p>---</p>
<p><strong>map_operator(self, op)</strong></p>
<p>:   Maps CrossGL operators to HLSL operators.</p>
<pre><code>-   **Parameters:**
    -   [op (str)]{.title-ref} -- The CrossGL operator.
-   **Returns:**
    -   [str]{.title-ref} -- The corresponding HLSL operator.
</code></pre>
<p>---</p>
<p>Example</p>
<p>Here's an example usage of the HLSLCodeGen class to generate HLSL code
from a CrossGL shader:</p>
<pre><code class="language-python">from compiler.lexer import Lexer
from compiler.parser import Parser

code = &quot;&quot;&quot;
shader main {
    input vec3 position;
    input vec2 texCoord;
    input mat2 depth;
    output vec4 fragColor;
    output float depth;
    vec3 customFunction(vec3 random, float factor) {
        return random * factor;
    }

    void main() {
        vec3 color = vec3(position.x,position.y, 0.0);
        float factor = 1.0;

        if (texCoord.x &gt; 0.5) {
            color = vec3(1.0, 0.0, 0.0);
        } else {
            color = vec3(0.0, 1.0, 0.0);
        }

        for (int i = 0; i &lt; 3; i = i + 1) {
            factor = factor * 0.5;
            color = customFunction(color, factor);
        }

        if (length(color) &gt; 1.0) {
            color = normalize(color);
        }

        fragColor = vec4(color, 1.0);
    }
}
&quot;&quot;&quot;
lexer = Lexer(code)
parser = Parser(lexer.tokens)
ast = parser.parse()

codegen = HLSLCodeGen()
hlsl_code = codegen.generate(ast)
print(hlsl_code)
</code></pre>
<h1 id="metal-codegen">Metal Codegen</h1>
<p>The MetalCodeGen class in the CrossGL framework plays a crucial role in
converting the abstract syntax tree (AST) of CrossGL shaders into Metal
shading language (MSL) code, optimized for Apple's Metal API. This class
ensures that CrossGL shaders are efficiently translated into MSL,
enabling their execution on Apple platforms, including macOS, iOS, and
iPadOS.</p>
<ul>
<li>
<p>Attributes</p>
<p>:   -   current_shader (ShaderNode) : The current shader node being
        processed.</p>
</li>
</ul>
<h2 id="methods_1">Methods</h2>
<p><strong>__init__(self)</strong></p>
<p>:   Initializes the code generator.</p>
<p>---</p>
<p><strong>generate(self, ast)</strong></p>
<p>:   Generates the complete shader code from the given abstract syntax
    tree (AST).</p>
<pre><code>-   **Parameters:**
    -   [ast (ASTNode)]{.title-ref} -- The root node of the AST,
        typically a ShaderNode, representing the entire shader.
-   **Returns:**
    -   [str]{.title-ref} -- The generated shader code as a string,
        or an empty string if the AST is not a ShaderNode.
</code></pre>
<p>---</p>
<p><strong>generate_shader(self, node)</strong></p>
<p>:   Generates the complete Metal shading language (MSL) code for a
    shader from its abstract syntax tree (AST).</p>
<pre><code>-   **Parameters:**
    -   [node (ShaderNode)]{.title-ref} -- The root node of the AST
        representing the entire shader, including its global inputs,
        outputs, and shader stages (vertex and fragment).
-   **Returns:**
    -   [str]{.title-ref} -- The generated MSL code as a string.
</code></pre>
<p>---</p>
<p><strong>check_gl_position(self, node)</strong></p>
<p>:   Generates intermediate shader code by processing a sequence of
    statements.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (list\[ASTNode\])]{.title-ref} -- A list of AST
            nodes representing the statements to be processed.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., vertex, fragment) for which the code is being
            generated.

-   **Returns:**
    -   [str]{.title-ref} -- The generated intermediate shader code
        as a string.
</code></pre>
<p>---</p>
<p><strong>generate_intermidiate(self, node, shader_type)</strong></p>
<p>:   Generates intermediate shader code by processing a sequence of
    statements.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (list\[ASTNode\])]{.title-ref} -- A list of AST
            nodes representing the statements to be processed.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., vertex, fragment) for which the code is being
            generated.

-   **Returns:**
    -   [str]{.title-ref} -- The generated intermediate shader code
        as a string.
</code></pre>
<p>---</p>
<p><strong>generate_function(self, node, shader_type)</strong></p>
<p>:   Generates shader function code based on the function nodes and
    shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (list\[FunctionNode\] \|
            FunctionNode)]{.title-ref} -- A list of function nodes
            or a single function node, depending on the shader type.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., "vertex", "fragment", "global") for which the
            function code is being generated.

-   **Returns:**
    -   [str]{.title-ref} -- The generated shader function code as a
        string.
</code></pre>
<p>---</p>
<p><strong>generate_main(self, node, shader_type)</strong></p>
<p>:   Generates the main function code for the specified shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (FunctionNode)]{.title-ref} -- The function node
            representing the main function in the shader's AST.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            ("vertex" or "fragment") for which the main function
            code is being generated.

-   **Returns:**
    -   [str]{.title-ref} -- The generated main function code as a
        string.
</code></pre>
<p>---</p>
<p><strong>generate_statement(self, stmt, indent=0, shader_type=None)</strong></p>
<p>:   Generates code for a given statement, with support for different
    statement types and optional indentation.</p>
<pre><code>-

    **Parameters:**

    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node to be
            converted to code.
        -   [indent (int, optional)]{.title-ref} -- The indentation
            level for the generated code. Defaults to 0.
        -   [shader_type (str, optional)]{.title-ref} -- The type of
            shader (e.g., vertex, fragment), used for
            context-specific code generation.

-   **Returns:**
    -   [str]{.title-ref} -- The generated code for the statement as
        a string.
</code></pre>
<p>---</p>
<p><strong>generate_assignment(self, node, shader_type=None)</strong></p>
<p>:   Generates the code for an assignment statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment
            node containing the variable name and the value to be
            assigned.
        -   [shader_type (str, optional)]{.title-ref} -- The type of
            shader (e.g., vertex, fragment), which influences how
            the assignment is generated.

-   **Returns:**
    -   [str]{.title-ref} -- The generated assignment code as a
        string.
</code></pre>
<p>---</p>
<p><strong>generate_if(self, node, indent, shader_type=None)</strong></p>
<p>:   Generates code for an if statement, including optional else body.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (IfNode)]{.title-ref} -- The IfNode containing the
            condition, if body statements, and optionally else body
            statements.
        -   [indent (int)]{.title-ref} -- The indentation level for
            the generated code.
        -   [shader_type (str, optional)]{.title-ref} -- The type of
            shader (e.g., vertex, fragment), used for
            context-specific code generation.

-   **Returns:**
    -   [str]{.title-ref} -- The generated if statement code as a
        string.
</code></pre>
<p>---</p>
<p><strong>generate_for(self, node, indent, shader_type=None)</strong></p>
<p>:   Generates code for a for loop statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (ForNode)]{.title-ref} -- The ForNode containing
            initialization, condition, update expressions, and the
            loop body.
        -   [indent (int)]{.title-ref} -- The indentation level for
            the generated code.
        -   [shader_type (str, optional)]{.title-ref} -- The type of
            shader (e.g., vertex, fragment), used for
            context-specific code generation.

-   **Returns:**
    -   [str]{.title-ref} -- The generated for loop code as a
        string.
</code></pre>
<p>---</p>
<p><strong>generate_expression(self, expr, shader_type=None)</strong></p>
<p>:   Generates code for an expression, handling various types of
    expression nodes.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (ASTNode)]{.title-ref} -- The expression node to
            be converted into code.
        -   [shader_type (str, optional)]{.title-ref} -- The type of
            shader (e.g., vertex, fragment), used for
            context-specific code generation.

-   **Returns:**
    -   [str]{.title-ref} -- The generated expression code as a
        string.
</code></pre>
<p>---</p>
<p><strong>translate_expression(self, expr, shader_type)</strong></p>
<p>:   Translates an expression to its corresponding shader code
    representation, based on the shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (str)]{.title-ref} -- The expression to be
            translated.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (e.g., vertex, fragment), used for context-specific
            translation.

-   **Returns:**
    -   [str]{.title-ref} -- The translated expression code as a
        string.
</code></pre>
<p>---</p>
<p><strong>map_type(self, vtype)</strong></p>
<p>:   Maps a type identifier to its corresponding shader type
    representation.</p>
<pre><code>-   **Parameters:**
    -   [vtype (str)]{.title-ref} -- The type identifier to be
        mapped.
-   **Returns:**
    -   [str]{.title-ref} -- The mapped shader type representation.
</code></pre>
<p>---</p>
<p><strong>map_operator(self, op)</strong></p>
<p>:   Maps an operator identifier to its corresponding shader code
    representation.</p>
<pre><code>-   **Parameters:**
    -   [op (str)]{.title-ref} -- The operator identifier to be
        mapped.
-   **Returns:**
    -   [str]{.title-ref} -- The mapped shader operator
        representation.
</code></pre>
<p>---</p>
<p>Example</p>
<p>Here's an example usage of the MetalCodeGen class to generate Metal code
from a CrossGL shader:</p>
<pre><code class="language-python">from compiler.lexer import Lexer
from compiler.parser import Parser

code = &quot;&quot;&quot;
shader main {
    input vec3 position;
    input vec2 texCoord;
    input mat2 depth;
    output vec4 fragColor;
    output float depth;
    vec3 customFunction(vec3 random, float factor) {
        return random * factor;
    }

    void main() {
        vec3 color = vec3(position.x,position.y, 0.0);
        float factor = 1.0;

        if (texCoord.x &gt; 0.5) {
            color = vec3(1.0, 0.0, 0.0);
        } else {
            color = vec3(0.0, 1.0, 0.0);
        }

        for (int i = 0; i &lt; 3; i = i + 1) {
            factor = factor * 0.5;
            color = customFunction(color, factor);
        }

        if (length(color) &gt; 1.0) {
            color = normalize(color);
        }

        fragColor = vec4(color, 1.0);
    }
}
&quot;&quot;&quot;
lexer = Lexer(code)
parser = Parser(lexer.tokens)
ast = parser.parse()

codegen = MetalCodeGen()
Metal_code = codegen.generate(ast)
print(Metal_code)
</code></pre>
<h1 id="opengl-codegen">OpenGL Codegen</h1>
<p>The [OpenGLCodeGen]{.title-ref} class in the CrossGL framework is
essential for translating the abstract syntax tree (AST) of CrossGL
shaders into OpenGL Shading Language (GLSL) code. This class is
responsible for converting CrossGL shaders into GLSL, ensuring
compatibility with OpenGL implementations across various platforms. By
generating optimized GLSL code, the [OpenGLCodeGen]{.title-ref} class
enables the efficient execution of shaders on systems that support
OpenGL, including Windows, macOS, and Linux environments.</p>
<ul>
<li>
<p>Attributes</p>
<p>:   -   current_shader (ShaderNode) : The current shader node being
        processed.</p>
</li>
</ul>
<h2 id="methods_2">Methods</h2>
<p><strong>__init__(self)</strong></p>
<p>:   Initializes the code generator.</p>
<p>---</p>
<p><strong>generate(self, ast)</strong></p>
<p>:   Generates the shader code from the given abstract syntax tree (AST).</p>
<pre><code>-   **Parameters:**
    -   [ast (ASTNode)]{.title-ref} -- The abstract syntax tree node
        representing the shader.
-   **Returns:**
    -   [str]{.title-ref} -- The generated shader code.
</code></pre>
<p>---</p>
<p><strong>generate_shader(self, node)</strong></p>
<p>:   Generates the shader code from its abstract syntax tree (AST).</p>
<pre><code>-   **Parameters:**
    -   [node (ShaderNode)]{.title-ref} -- The shader node
        containing global inputs, outputs, and shader sections.
-   **Returns:**
    -   [str]{.title-ref} -- The generated shader code.
</code></pre>
<p>---</p>
<p><strong>generate_function(self, node, shader_type)</strong></p>
<p>:   Generates function code for the given function node and shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (FunctionNode)]{.title-ref} -- The function node
            containing return type, name, parameters, and body.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\", \"fragment\", or \"global\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated function code.
</code></pre>
<p>---</p>
<p><strong>generate_main(self, node, shader_type)</strong></p>
<p>:   Generates the main function code for the given function node and
    shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (FunctionNode)]{.title-ref} -- The function node
            containing return type, name, parameters, and body.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated main function code.
</code></pre>
<p>---</p>
<p><strong>generate_statement(self, stmt, indent=0, shader_type=None)</strong></p>
<p>:   Generates code for a given statement, handling different types of
    statements based on their node type.</p>
<pre><code>-

    **Parameters:**

    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node to
            generate code for.
        -   [indent (int)]{.title-ref} -- The level of indentation
            for the statement.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated code for the statement.
</code></pre>
<p>---</p>
<p><strong>generate_intermediate(self, node, shader_type)</strong></p>
<p>:   Generates intermediate code from a list of statements.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (list of ASTNode)]{.title-ref} -- The list of
            intermediate statements to generate code for.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated intermediate code.
</code></pre>
<p>---</p>
<p><strong>generate_assignment(self, node, shader_type=None)</strong></p>
<p>:   Generates the code for an assignment statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment
            node containing the variable and the value to assign.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated assignment code.
</code></pre>
<p>---</p>
<p><strong>generate_if(self, node, indent, shader_type=None)</strong></p>
<p>:   Generates the code for an [if]{.title-ref} statement.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (IfNode)]{.title-ref} -- The node representing the
            [if]{.title-ref} statement with its condition and
            bodies.
        -   [indent (int)]{.title-ref} -- The level of indentation
            for the generated code.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated [if]{.title-ref}
        statement code.
</code></pre>
<p>---</p>
<p><strong>generate_for(self, node, indent, shader_type=None)</strong></p>
<p>:   Generates the code for a [for]{.title-ref} loop.</p>
<pre><code>-

    **Parameters:**

    :   -   [node (ForNode)]{.title-ref} -- The node representing
            the [for]{.title-ref} loop with initialization,
            condition, update, and body.
        -   [indent (int)]{.title-ref} -- The level of indentation
            for the generated code.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated [for]{.title-ref} loop
        code.
</code></pre>
<p>---</p>
<p><strong>generate_expression(self, expr, shader_type=None)</strong></p>
<p>:   Generates the code for an expression based on its type.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (ASTNode)]{.title-ref} -- The expression node,
            which could be a string, [VariableNode]{.title-ref},
            [BinaryOpNode]{.title-ref},
            [FunctionCallNode]{.title-ref},
            [UnaryOpNode]{.title-ref}, [TernaryOpNode]{.title-ref},
            or [MemberAccessNode]{.title-ref}.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The generated code for the expression.
</code></pre>
<p>---</p>
<p><strong>translate_expression(self, expr, shader_type)</strong></p>
<p>:   Translates the expression based on its type and shader type.</p>
<pre><code>-

    **Parameters:**

    :   -   [expr (str)]{.title-ref} -- The expression to translate.
        -   [shader_type (str)]{.title-ref} -- The type of shader
            (\"vertex\" or \"fragment\").

-   **Returns:**
    -   [str]{.title-ref} -- The translated expression, or the
        original expression if no translation is found.
</code></pre>
<p>---</p>
<p><strong>map_type(self, vtype)</strong></p>
<p>:   Maps the given type to its corresponding shader type.</p>
<pre><code>-   **Parameters:**
    -   [vtype (str)]{.title-ref} -- The type to be mapped.
-   **Returns:**
    -   [str]{.title-ref} -- The mapped shader type.
</code></pre>
<p>---</p>
<p><strong>map_operator(self, op)</strong></p>
<p>:   Maps the given operator to its corresponding shader operator.</p>
<pre><code>-   **Parameters:**
    -   [op (str)]{.title-ref} -- The operator to be mapped.
-   **Returns:**
    -   [str]{.title-ref} -- The mapped shader operator.
</code></pre>
<p>---</p>
<p>Example</p>
<p>Here's an example usage of the OpenGLCodeGen class to generate OpenGL
code from a CrossGL shader:</p>
<pre><code class="language-python">from compiler.lexer import Lexer
from compiler.parser import Parser

code = &quot;&quot;&quot;
shader main {
    input vec3 position;
    input vec2 texCoord;
    input mat2 depth;
    output vec4 fragColor;
    output float depth;
    vec3 customFunction(vec3 random, float factor) {
        return random * factor;
    }

    void main() {
        vec3 color = vec3(position.x,position.y, 0.0);
        float factor = 1.0;

        if (texCoord.x &gt; 0.5) {
            color = vec3(1.0, 0.0, 0.0);
        } else {
            color = vec3(0.0, 1.0, 0.0);
        }

        for (int i = 0; i &lt; 3; i = i + 1) {
            factor = factor * 0.5;
            color = customFunction(color, factor);
        }

        if (length(color) &gt; 1.0) {
            color = normalize(color);
        }

        fragColor = vec4(color, 1.0);
    }
}
&quot;&quot;&quot;
lexer = Lexer(code)
parser = Parser(lexer.tokens)
ast = parser.parse()

codegen = OpenGLCodeGen()
opengl_code = codegen.generate(ast)
print(opengl_code)
</code></pre>
<h1 id="vulkan-codegen">Vulkan Codegen</h1>
<p>The [VulkanCodeGen]{.title-ref} class in the CrossGL framework is
pivotal for translating the abstract syntax tree (AST) of CrossGL
shaders into SPIR-V compatible code, used by the Vulkan API. This class
ensures that CrossGL shaders are converted into Vulkan Shading Language
(GLSL for Vulkan) or directly into SPIR-V, providing compatibility with
Vulkan-based applications across various platforms. By generating
optimized SPIR-V code, the [VulkanCodeGen]{.title-ref} class enables
efficient execution of shaders on systems that support Vulkan, including
Windows, macOS, Linux, and Android environments, ensuring high
performance and flexibility in rendering tasks.</p>
<ul>
<li>
<p>Attributes</p>
<p>:   -   current_shader (ShaderNode) : The current shader node being
        processed.</p>
</li>
</ul>
<h2 id="methods_3">Methods</h2>
<p><strong>__init__(self)</strong></p>
<p>:   Initializes the code generator.</p>
<p>---</p>
<p><strong>generate(self, ast)</strong></p>
<p>Generates shader code from the given abstract syntax tree (AST).</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>[ast (ShaderNode)]{.title-ref} -- The abstract syntax tree node
    representing the shader.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The generated shader code, or an empty
    string if the AST is not a [ShaderNode]{.title-ref}.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>generate_shader(self, node)</strong></p>
<p>Generates the SPIR-V code for a Vulkan shader based on the provided
shader node.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>[node (ShaderNode)]{.title-ref} -- The node representing the
    shader, containing inputs, outputs, functions, and other shader
    components.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The generated SPIR-V code, including SPIR-V
    header information, entry points, decorations, type
    declarations, global variables, constants, function
    declarations, and function definitions.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>declare_types(self)</strong></p>
<p>Declares the necessary data types for the Vulkan SPIR-V shader.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>None</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The SPIR-V code string that includes type
    declarations for [void]{.title-ref}, [boolean]{.title-ref},
    [float]{.title-ref}, [integer]{.title-ref}, and [unsigned
    integer]{.title-ref} types. It also dynamically generates vector
    types based on the shader's input and output variables,
    assigning them unique IDs.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>declare_global_variables(self)</strong></p>
<p>Declares global variables for shader inputs and outputs in the SPIR-V
code.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>None</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The SPIR-V code string that declares
    pointers to the input and output variables. It assigns unique
    IDs to these variables and stores them in
    [self.variable_ids]{.title-ref}. The function handles both input
    and output variables, generating the appropriate
    [OpTypePointer]{.title-ref} and [OpVariable]{.title-ref}
    instructions for each.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>declare_constants(self)</strong></p>
<p>Declares constants used in the shader within the SPIR-V code.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>None</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The SPIR-V code string that defines
    commonly used constants such as [0]{.title-ref} and
    [1]{.title-ref} for both [float]{.title-ref} and
    [int]{.title-ref} types, as well as [3]{.title-ref} for the
    [int]{.title-ref} type. Each constant is represented with an
    [OpConstant]{.title-ref} instruction, associating the value with
    a type ([float]{.title-ref} or [int]{.title-ref}). These
    constants can then be referenced within the shader code.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>declare_function(self, node)</strong></p>
<p>Declares a function type in SPIR-V code based on the given function
node.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>[node (FunctionNode)]{.title-ref} -- The function node
    representing the function declaration in the shader.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The SPIR-V code string that defines the
    function type. It includes the function's return type and
    parameter types, and assigns a unique ID to this function type.
    The function type is represented with an
    [OpTypeFunction]{.title-ref} instruction, specifying the return
    type and the types of parameters the function accepts.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>generate_function(self, node)</strong></p>
<p>Generates the SPIR-V code for a function based on the given function
node.</p>
<ul>
<li><strong>Parameters:</strong><ul>
<li>[node (FunctionNode)]{.title-ref} -- The function node
    representing the function definition in the shader.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>[str]{.title-ref} -- The SPIR-V code string for the function.
    This includes the function declaration with its type, parameter
    declarations, function body, and function end. The function code
    is defined using [OpFunction]{.title-ref},
    [OpFunctionParameter]{.title-ref}, [OpLabel]{.title-ref},
    [OpReturn]{.title-ref}, [OpUnreachable]{.title-ref}, and
    [OpFunctionEnd]{.title-ref} instructions. The function is
    assigned a unique ID and the function parameters are mapped to
    SPIR-V function parameters. The body of the function is
    generated by translating each statement into SPIR-V code.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>generate_statement(self, stmt)</strong></p>
<p>Generates the SPIR-V code for a given statement node.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[stmt (ASTNode)]{.title-ref} -- The statement node representing
    a specific type of statement in the shader code.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the statement. The function translates different types of statements into corresponding SPIR-V instructions:

    :   -   For [AssignmentNode]{.title-ref}, it generates code
            using [OpStore]{.title-ref}.
        -   For [IfNode]{.title-ref}, it generates conditional
            branches using [OpBranchConditional]{.title-ref}.
        -   For [ForNode]{.title-ref}, it generates code for the
            initialization, condition, and update steps, and
            loops through the body.
        -   For [ReturnNode]{.title-ref}, it generates a return
            statement with [OpReturnValue]{.title-ref} or
            [OpReturn]{.title-ref} if there is no return value.
        -   For other statements, it generates SPIR-V code for
            expressions.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>generate_assignment(self, node)</strong></p>
<p>Generates the SPIR-V code for an assignment statement.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node (AssignmentNode)]{.title-ref} -- The assignment node
    containing the variable being assigned to and the value being
    assigned.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the assignment operation. The function handles assignments in two cases:

    :   -   If the variable being assigned to is a shader
            output, it uses the [OpStore]{.title-ref}
            instruction to store the value directly to the
            output variable.
        -   For other variables, it generates a temporary
            variable of the function type, assigns the value to
            it, and then stores the value to the temporary
            variable. This is useful for intermediate variables
            within functions.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>generate_if(self, node)</strong></p>
<p>Generates SPIR-V code for an [if]{.title-ref} statement.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node (IfNode)]{.title-ref} -- The if-node containing the
    condition, the body of statements to execute if the condition is
    true, and optionally the body of statements to execute if the
    condition is false.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the [if]{.title-ref} statement. The function handles the following :

    :   -   **Condition Evaluation:** Evaluates the condition
            expression and generates the necessary label IDs for
            the [then]{.title-ref}, [else]{.title-ref}, and
            [merge]{.title-ref} blocks.
        -   **Branching:** Uses the
            [OpSelectionMerge]{.title-ref} and
            [OpBranchConditional]{.title-ref} instructions to
            branch to the appropriate labels based on the
            condition.
        -   **Then Block:** Executes the statements within the
            [if]{.title-ref} body, then branches to the merge
            block.
        -   **Else Block:** If there is an [else]{.title-ref}
            body, it executes those statements and then branches
            to the merge block.
        -   **Merge Block:** The merge block that consolidates
            the control flow from both the [then]{.title-ref}
            and [else]{.title-ref} blocks.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>generate_for(self, node)</strong></p>
<p>Generates SPIR-V code for a [for]{.title-ref} loop.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node (ForNode)]{.title-ref} -- The for-node containing
    initialization, condition, update, and body of the loop.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the [for]{.title-ref} loop. The function handles the following :

    :   -   **Initialization:** Executes the initialization
            statement.
        -   **Loop Header:** Creates labels for the loop header,
            body, continue, and merge blocks.
        -   **Loop Merge:** Uses [OpLoopMerge]{.title-ref} to
            define the loop structure, specifying the merge and
            continue labels.
        -   **Condition Check:** Uses
            [OpBranchConditional]{.title-ref} to branch to the
            loop body if the condition is true or to the merge
            label if false.
        -   **Body Execution:** Executes the statements in the
            loop body and then branches to the continue label.
        -   **Update and Repeat:** Executes the update
            statement, then branches back to the loop header for
            the next iteration.
        -   **Merge Block:** The merge block that follows the
            end of the loop, consolidating the control flow.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>generate_expression(self, expr)</strong></p>
<p>Generates SPIR-V code for the given expression.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[expr (ExpressionNode)]{.title-ref} -- The expression node to be
    converted into SPIR-V code. This can be a string,
    [VariableNode]{.title-ref}, [BinaryOpNode]{.title-ref},
    [FunctionCallNode]{.title-ref}, [MemberAccessNode]{.title-ref},
    or other types of expression nodes.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the expression. The function handles the following cases :

    :   -   **String:** Translates a simple string expression
            directly.
        -   **VariableNode:** Translates the variable name to
            its corresponding SPIR-V identifier.
        -   **BinaryOpNode:** Generates code for binary
            operations. This involves:
        -   Generating SPIR-V IDs for the left and right
            operands.
        -   Mapping the operator to its SPIR-V representation.
        -   Constructing the appropriate SPIR-V instruction
            using [OpBinaryOp]{.title-ref}.
        -   **FunctionCallNode:** Handles function calls,
            including:
        -   **Vector Constructors:** For built-in functions like
            [vec2]{.title-ref}, [vec3]{.title-ref}, and
            [vec4]{.title-ref}, constructs the vector using
            [OpCompositeConstruct]{.title-ref}.
        -   **Regular Function Calls:** Calls functions with
            [OpFunctionCall]{.title-ref}, handling both void and
            non-void return types.
        -   **MemberAccessNode:** Generates code to access a
            member of a composite type using
            [OpCompositeExtract]{.title-ref}.
        -   **Default Case:** Returns the string representation
            of the expression for any other cases.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>translate_expression(self, expr)</strong></p>
<p>Translates an expression into SPIR-V code.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[expr (str)]{.title-ref} -- The expression to be translated.
    This can be a variable name, a vector constructor, or a constant
    value.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V code string for the given expression. The function handles the following cases :

    :   -   **Variable Names:** If the expression is a variable
            name that exists in [self.variable_ids]{.title-ref},
            it returns the corresponding SPIR-V identifier.
        -   **Vector Constructors:** If the expression is a
            vector constructor (e.g., [vec3(1.0, 2.0,
            3.0)]{.title-ref}), it translates the components
            into SPIR-V code using
            [OpCompositeConstruct]{.title-ref}. It splits the
            vector components, translates each component, and
            constructs the vector.
        -   **Constant Values:** If the expression is a numeric
            value, it attempts to convert it to a float and
            generates a constant using [OpConstant]{.title-ref}
            with type [%float]{.title-ref}.
        -   **Unhandled Expressions:** For any other
            expressions, it returns a comment indicating that
            the expression is unhandled.
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>map_type(self, vtype)</strong></p>
<p>Maps a given type to its corresponding SPIR-V type.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<ul>
<li>[vtype (str)]{.title-ref} -- The type to be mapped, which may
    include types like [\"void\"]{.title-ref},
    [\"bool\"]{.title-ref}, [\"int\"]{.title-ref},
    [\"float\"]{.title-ref}, and various vector and matrix types.</li>
</ul>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V type corresponding to the input type. The function uses a mapping dictionary to translate common GLSL types to SPIR-V types :

    :   -   [\"void\"]{.title-ref} -\&gt; [\"void\"]{.title-ref}
        -   [\"bool\"]{.title-ref} -\&gt; [\"bool\"]{.title-ref}
        -   [\"int\"]{.title-ref} -\&gt; [\"int\"]{.title-ref}
        -   [\"float\"]{.title-ref} -\&gt; [\"float\"]{.title-ref}
        -   [\"vec2\"]{.title-ref} -\&gt; [\"v2float\"]{.title-ref}
        -   [\"vec3\"]{.title-ref} -\&gt; [\"v3float\"]{.title-ref}
        -   [\"vec4\"]{.title-ref} -\&gt; [\"v4float\"]{.title-ref}
        -   [\"mat2\"]{.title-ref} -\&gt;
            [\"mat2v2float\"]{.title-ref}
        -   [\"mat3\"]{.title-ref} -\&gt;
            [\"mat3v3float\"]{.title-ref}
        -   [\"mat4\"]{.title-ref} -\&gt;
            [\"mat4v4float\"]{.title-ref}
</code></pre>
<ul>
<li>If [vtype]{.title-ref} is not in the dictionary, it returns
    [vtype]{.title-ref} unchanged. This allows for custom or
    unsupported types to pass through without modification.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>map_operator(self, op)</strong></p>
<p>Maps a given operator to its corresponding SPIR-V opcode.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<p>:   -   [op (str)]{.title-ref} -- The operator to be mapped. This
        might include operators such as [\"PLUS\"]{.title-ref},
        [\"MINUS\"]{.title-ref}, [\"MULTIPLY\"]{.title-ref},
        [\"DIVIDE\"]{.title-ref}, [\"LESS_THAN\"]{.title-ref}, and
        so on.</p>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>:   -   </p>
<pre><code>    [str]{.title-ref} -- The SPIR-V opcode corresponding to the input operator. The function uses a dictionary to translate common operators to their SPIR-V opcodes:

    :   -   [\"PLUS\"]{.title-ref} -\&gt; [\"OpFAdd\"]{.title-ref}
        -   [\"MINUS\"]{.title-ref} -\&gt; [\"OpFSub\"]{.title-ref}
        -   [\"MULTIPLY\"]{.title-ref} -\&gt;
            [\"OpFMul\"]{.title-ref}
        -   [\"DIVIDE\"]{.title-ref} -\&gt;
            [\"OpFDiv\"]{.title-ref}
        -   [\"LESS_THAN\"]{.title-ref} -\&gt;
            [\"OpFOrdLessThan\"]{.title-ref}
        -   [\"GREATER_THAN\"]{.title-ref} -\&gt;
            [\"OpFOrdGreaterThan\"]{.title-ref}
        -   [\"LESS_EQUAL\"]{.title-ref} -\&gt;
            [\"OpFOrdLessThanEqual\"]{.title-ref}
        -   [\"GREATER_EQUAL\"]{.title-ref} -\&gt;
            [\"OpFOrdGreaterThanEqual\"]{.title-ref}
        -   [\"EQUAL\"]{.title-ref} -\&gt;
            [\"OpFOrdEqual\"]{.title-ref}
        -   [\"NOT_EQUAL\"]{.title-ref} -\&gt;
            [\"OpFOrdNotEqual\"]{.title-ref}
        -   [\"AND\"]{.title-ref} -\&gt;
            [\"OpLogicalAnd\"]{.title-ref}
        -   [\"OR\"]{.title-ref} -\&gt;
            [\"OpLogicalOr\"]{.title-ref}
</code></pre>
<ul>
<li>If [op]{.title-ref} is not found in the dictionary, it returns
    [op]{.title-ref} unchanged, allowing for unhandled or custom
    operators to pass through without modification.</li>
</ul>
</li>
</ul>
<p>---</p>
<p><strong>get_id(self)</strong></p>
<p>Generates a unique identifier for use in the SPIR-V code.</p>
<ul>
<li><strong>Returns:</strong><ul>
<li>[int]{.title-ref} -- The current value of
    [self.id_counter]{.title-ref}, which serves as a unique
    identifier in the generated SPIR-V code. After returning the
    current value, the method increments
    [self.id_counter]{.title-ref} by 1 to ensure that the next call
    to [get_id]{.title-ref} produces a new unique identifier.</li>
</ul>
</li>
</ul>
<h1 id="ast-abstract-syntax-tree">AST (Abstract Syntax Tree)</h1>
<p><strong>UniformNode(ASTNode) Class</strong></p>
<p>Represents a uniform variable in the abstract syntax tree (AST) of
shader code. This node is used to define uniform variables, which are
global variables passed to the shader from the application.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<ul>
<li>vtype (str): The type of the uniform variable (e.g.,
    [int]{.title-ref}, [float]{.title-ref}, [vec3]{.title-ref}).</li>
<li>name (str): The name of the uniform variable.</li>
</ul>
</li>
<li>
<p><strong>Methods</strong>:</p>
<ul>
<li>
<p>__<a href="init__(self)">repr</a>():</p>
<ul>
<li><strong>Purpose</strong>: Provides a detailed string representation of
    the [UniformNode]{.title-ref} instance for debugging
    purposes.</li>
<li><strong>Returns</strong>: A string in the format
    [\"UniformNode(vtype=\&lt;vtype&gt;,
    name=\&lt;name&gt;)\"]{.title-ref}.</li>
</ul>
</li>
<li>
<p>__<a href="init__(self)">str</a>():</p>
<ul>
<li><strong>Purpose</strong>: Provides a string representation of the uniform
    declaration as it would appear in shader code.</li>
<li><strong>Returns</strong>: A string in the format :</li>
</ul>
<p><code>python
"uniform &lt;vtype&gt; &lt;name&gt;;"</code></p>
</li>
</ul>
</li>
<li>
<p><strong>Example</strong>:</p>
<p><code>python
uniform_node = UniformNode("vec3", "lightDirection")
print(uniform_node)  # Output: uniform vec3 lightDirection;
print(repr(uniform_node))  # Output: UniformNode(vtype=vec3, name=lightDirection)</code></p>
</li>
</ul>
<p>---</p>
<p><strong>TernaryOpNode Class</strong></p>
<p>Represents a ternary operation in the abstract syntax tree (AST) of a
programming language or shader code. A ternary operation is a
conditional expression that evaluates to one of two values depending on
the result of a condition.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `condition`: The condition expression to be evaluated.
        This is typically a boolean expression.
    -   `true_expr`: The expression that is evaluated and returned
        if the condition is [True]{.title-ref}.
    -   `false_expr`: The expression that is evaluated and
        returned if the condition is [False]{.title-ref}.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_[repr](init__(self))()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`TernaryOpNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format :

        ``` python
        "TernaryOpNode(condition=&lt;condition&gt;, true_expr=&lt;true_expr&gt;, false_expr=&lt;false_expr&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<p>:   <code>python
    ternary_node = TernaryOpNode("x &gt; 0", "x", "-x")
    print(repr(ternary_node))
    # Output: TernaryOpNode(condition=x &gt; 0, true_expr=x, false_expr=-x)</code></p>
</li>
</ul>
<p><strong>ShaderNode Class</strong></p>
<p>Represents a complete shader program in the abstract syntax tree (AST).
This node encapsulates all the components of a shader, including inputs,
outputs, functions, and the vertex and fragment shader sections.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `name`: The name of the shader program.
    -   `global_inputs`: A list of global input variables used in
        the shader.
    -   `global_outputs`: A list of global output variables
        produced by the shader.
    -   `global_functions`: A list of global functions defined in
        the shader.
    -   `vertex_section`: The vertex shader section, containing
        operations related to vertex processing.
    -   `fragment_section`: The fragment shader section,
        containing operations related to fragment (pixel)
        processing.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_[repr](init__(self))()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`ShaderNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "ShaderNode(&lt;name&gt;) &lt;global_inputs&gt; &lt;global_outputs&gt; &lt;global_functions&gt; &lt;vertex_section&gt; &lt;fragment_section&gt;"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
shader_node = ShaderNode(
    name="BasicShader",
    global_inputs=["position", "normal"],
    global_outputs=["color"],
    global_functions=["transform", "lighting"],
    vertex_section="vertex operations here",
    fragment_section="fragment operations here",
)
print(repr(shader_node))</p>
<h1 id="output-shadernodebasicshader-position-normal-color-transform-lighting-vertex-operations-here-fragment-operations-here">Output: ShaderNode('BasicShader') ['position', 'normal'] ['color'] ['transform', 'lighting'] 'vertex operations here' 'fragment operations here'</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>VERTEXShaderNode Class</strong></p>
<p>Represents the vertex shader section of a shader program in the abstract
syntax tree (AST). This node encapsulates the inputs, outputs,
functions, and intermediate operations specific to the vertex shader.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `inputs`: A list of input variables used by the vertex
        shader, typically including attributes like position,
        normal, etc.
    -   `outputs`: A list of output variables produced by the
        vertex shader, such as transformed positions or interpolated
        data.
    -   `functions`: A list of functions defined and used within
        the vertex shader.
    -   `intermidiate`: The intermediate operations or
        calculations performed within the vertex shader before the
        final output.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_[repr](init__(self))()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`VERTEXShaderNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "VERTEXShaderNode(&lt;inputs&gt;) &lt;outputs&gt; &lt;functions&gt; &lt;intermidiate&gt;"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
vertex_shader_node = VERTEXShaderNode(
    inputs=["position", "normal"],
    outputs=["gl_Position"],
    functions=["transform", "calculateNormal"],
    intermidiate="intermediate calculations here",
)
print(repr(vertex_shader_node))</p>
<h1 id="output-vertexshadernodeposition-normal-gl_position-transform-calculatenormal-intermediate-calculations-here">Output: VERTEXShaderNode(['position', 'normal']) ['gl_Position'] ['transform', 'calculateNormal'] 'intermediate calculations here'</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p>---</p>
<p><strong>FRAGMENTShaderNode Class</strong></p>
<p>Represents the fragment shader section of a shader program in the
abstract syntax tree (AST). This node encapsulates the inputs, outputs,
functions, and intermediate operations specific to the fragment shader.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<ul>
<li>`inputs`: A list of input variables used by the fragment
    shader, such as interpolated data from the vertex shader.</li>
<li>`outputs`: A list of output variables produced by the fragment
    shader, like the final color of the pixel.</li>
<li>`functions`: A list of functions defined and used within the
    fragment shader.</li>
<li>`intermidiate`: The intermediate operations or calculations
    performed within the fragment shader before producing the final
    output.</li>
</ul>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_[repr](init__(self))()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`FRAGMENTShaderNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format :

        ``` python
        "FRAGMENTShaderNode(&lt;inputs&gt;) &lt;outputs&gt; &lt;functions&gt; &lt;intermidiate&gt;"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<p>``` python
fragment_shader_node = FRAGMENTShaderNode(
    inputs=["fragCoord", "color"],
    outputs=["fragColor"],
    functions=["applyLighting", "computeColor"],
    intermidiate="intermediate calculations here",
)
print(repr(fragment_shader_node))</p>
<h1 id="output-fragmentshadernodefragcoord-color-fragcolor-applylighting-computecolor-intermediate-calculations-here">Output: FRAGMENTShaderNode(['fragCoord', 'color']) ['fragColor'] ['applyLighting', 'computeColor'] 'intermediate calculations here'</h1>
<p>```</p>
</li>
</ul>
<p><strong>FunctionNode Class</strong></p>
<p>The [FunctionNode]{.title-ref} class represents a function within the
abstract syntax tree (AST) for shader code. It contains details about
the function's return type, name, parameters, and body. This class is
used in shader code generation to define functions that can be called
within shaders.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `return_type`: The data type that the function returns. It
        is a string representing the type (e.g.,
        [\"float\"]{.title-ref}, [\"vec4\"]{.title-ref}).
    -   `name`: The name of the function as a string.
    -   `params`: A list of tuples where each tuple represents a
        parameter with its type and name (e.g.,`[(\"float\",
        \"param1\"), (\"vec3\", \"param2\")]`).
    -   `body`: A list of statements that constitute the
        function's body. Each statement can be an instance of
        various AST node classes, such as
        [AssignmentNode]{.title-ref}, [ReturnNode]{.title-ref}, etc.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__<a href="init__(self)">repr</a>()[: - **Purpose**: Provides a
        detailed string representation of the
        `FunctionNode]{.title-ref} instance. This is useful for
        debugging and logging.
        -   <strong>Returns</strong>: A string that includes the function's
            return type, name, parameters, and body in a format
            similar to:</p>
<pre><code>    ``` python
    "FunctionNode(return_type=&lt;return_type&gt;, name=&lt;name&gt;, params=&lt;params&gt;, body=&lt;body&gt;)"
    ```
</code></pre>
</li>
<li>
<p><strong>Example Usage:</strong></p>
<blockquote>
<p>``` python</p>
<h1 id="define-a-function-node">Define a function node</h1>
<p>function_node = FunctionNode(
    return_type="float",
    name="calculateLighting",
    params=[("vec3", "position"), ("vec3", "normal")],
    body=[
        AssignmentNode(name="result", value=BinaryOpNode(left="position", op="MULTIPLY", right="normal")),
        ReturnNode(value="result")
    ]
)</p>
<h1 id="print-the-representation">Print the representation</h1>
<p>print(repr(function_node))</p>
<h1 id="output-functionnodereturn_typefloat-namecalculatelighting-paramsvec3-position-vec3-normal-bodyassignmentnodenameresult-valuebinaryopnodeleftposition-opmultiply-rightnormal-returnnodevalueresult">Output: FunctionNode(return_type=float, name=calculateLighting, params=[('vec3', 'position'), ('vec3', 'normal')], body=[AssignmentNode(name=result, value=BinaryOpNode(left=position, op=MULTIPLY, right=normal)), ReturnNode(value=result)])</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>VariableNode Class</strong></p>
<p>The [VariableNode]{.title-ref} class represents a variable within the
abstract syntax tree (AST) for shader code. It contains details about
the variable's type and name. This class is used when defining variables
in shader code and is a fundamental part of shader code generation.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `vtype`: The data type of the variable, represented as a
        string (e.g., [\"float\"]{.title-ref},
        [\"vec3\"]{.title-ref}).
    -   `name`: The name of the variable as a string (e.g.,
        [\"position\"]{.title-ref}, [\"color\"]{.title-ref}).</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__<a href="init__(self)">repr</a>()[: - **Purpose**: Provides a
        detailed string representation of the
        `VariableNode]{.title-ref} instance. This is useful for
        debugging and logging.</p>
<pre><code>    -   **Returns**: A string that includes the variable's type
        and name in a format similar to:

    ``` python
    "VariableNode(vtype=&lt;vtype&gt;, name=&lt;name&gt;)"
    ```
</code></pre>
</li>
<li>
<p><strong>Example Usage:</strong></p>
<blockquote>
<p>``` python</p>
<h1 id="define-a-variable-node">Define a variable node</h1>
<p>variable_node = VariableNode(vtype="vec3", name="position")</p>
<h1 id="print-the-representation_1">Print the representation</h1>
<p>print(repr(variable_node))</p>
<h1 id="output-variablenodevtypevec3-nameposition">Output: VariableNode(vtype=vec3, name=position)</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>AssignmentNode Class</strong></p>
<p>The [AssignmentNode]{.title-ref} class represents an assignment
operation within the abstract syntax tree (AST) for shader code. It
captures the assignment of a value to a variable, which is a fundamental
operation in shaders and other programming languages.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `name`: The name of the variable being assigned a value.
        This is typically a string representing the variable's
        identifier (e.g., [\"color\"]{.title-ref},
        [\"position\"]{.title-ref}).
    -   `value`: The value being assigned to the variable. This
        can be a more complex expression or value, represented as an
        instance of another node class or a string.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__<a href="">repr</a>()[: - **Purpose**: Provides a detailed
        string representation of the `AssignmentNode]{.title-ref}
        instance. This method is useful for debugging and
        visualizing the node's structure.</p>
<pre><code>    -   **Returns**: A string that includes the variable name
        and the assigned value, formatted like:

    ``` python
    "AssignmentNode(name=&lt;name&gt;, value=&lt;value&gt;)"
    ```
</code></pre>
</li>
<li>
<p><strong>Example Usage:</strong></p>
<blockquote>
<p>``` python</p>
<h1 id="define-an-assignment-node">Define an assignment node</h1>
<p>assignment_node = AssignmentNode(name="color", value="vec4(1.0, 0.0, 0.0, 1.0)")</p>
<h1 id="print-the-representation_2">Print the representation</h1>
<p>print(repr(assignment_node))</p>
<h1 id="output-assignmentnodenamecolor-valuevec410-00-00-10">Output: AssignmentNode(name=color, value=vec4(1.0, 0.0, 0.0, 1.0))</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>IfNode Class</strong></p>
<p>The [IfNode]{.title-ref} class represents a conditional statement within
the abstract syntax tree (AST) for shader code. It captures the
structure of an [if]{.title-ref} statement, including the condition to
be evaluated and the bodies of code to execute based on whether the
condition is true or false.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `condition`: An expression or condition that determines
        which body of code will be executed. This is often an
        instance of an expression node, representing a boolean
        condition.
    -   `if_body`: A list of statements or nodes that are executed
        if the condition evaluates to true.
    -   `else_body`: An optional list of statements or nodes that
        are executed if the condition evaluates to false. This can
        be [None]{.title-ref} if there is no [else]{.title-ref}
        part.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__<a href="">repr</a>()[: - **Purpose**: Provides a detailed
        string representation of the `IfNode]{.title-ref} instance.
        This method is useful for debugging and understanding the
        structure of the node.</p>
<pre><code>    -   **Returns**: A string that includes the condition,
        [if_body]{.title-ref}, and optionally the
        [else_body]{.title-ref}, formatted like:

    ``` python
    "IfNode(condition=&lt;condition&gt;, if_body=&lt;if_body&gt;, else_body=&lt;else_body&gt;)"
    ```
</code></pre>
</li>
<li>
<p><strong>Example Usage:</strong></p>
<blockquote>
<p>``` python</p>
<h1 id="define-an-if-node">Define an if-node</h1>
<p>if_node = IfNode(
    condition="x &gt; 0",
    if_body=[
        AssignmentNode(name="result", value="1.0")
    ],
    else_body=[
        AssignmentNode(name="result", value="0.0")
    ]
)</p>
<h1 id="print-the-representation_3">Print the representation</h1>
<p>print(repr(if_node))</p>
<h1 id="output-ifnodeconditionx-0-if_bodyassignmentnodenameresult-value10-else_bodyassignmentnodenameresult-value00">Output: IfNode(condition=x &gt; 0, if_body=[AssignmentNode(name=result, value=1.0)], else_body=[AssignmentNode(name=result, value=0.0)])</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>ForNode Class</strong></p>
<p>Represents a [for]{.title-ref} loop within the abstract syntax tree
(AST) for shader code. This node encapsulates the initialization,
condition, update, and body of the [for]{.title-ref} loop.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `init`: The initialization statement or expression
        executed before the loop starts.
    -   `condition`: The expression evaluated before each
        iteration to determine if the loop should continue.
    -   `update`: The expression or statement executed at the end
        of each loop iteration, typically used to update the loop
        variable or state.
    -   `body`: The list of statements or nodes that make up the
        body of the loop, executed repeatedly as long as the
        [condition]{.title-ref} is true.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_[repr](init__(self))()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`ForNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "ForNode(init=&lt;init&gt;, condition=&lt;condition&gt;, update=&lt;update&gt;, body=&lt;body&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
for_node = ForNode(
    init=AssignmentNode(name="i", value="0"),
    condition="i &lt; 10",
    update=AssignmentNode(name="i", value="i + 1"),
    body=[
        AssignmentNode(name="result", value="result + i")
    ]
)
print(repr(for_node))</p>
<h1 id="output-fornodeinitassignmentnodenamei-value0-conditioni-10-updateassignmentnodenamei-valuei-1-bodyassignmentnodenameresult-valueresult-i">Output: ForNode(init=AssignmentNode(name=i, value=0), condition=i &lt; 10, update=AssignmentNode(name=i, value=i + 1), body=[AssignmentNode(name=result, value=result + i)])</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>ReturnNode Class</strong></p>
<p>Represents a return statement within the abstract syntax tree (AST) for
shader code. This node encapsulates the value to be returned from a
function.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `value`: The expression or value to be returned from the
        function.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`ReturnNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "ReturnNode(value=&lt;value&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
return_node = ReturnNode(value="result")
print(repr(return_node))</p>
<h1 id="output-returnnodevalueresult">Output: ReturnNode(value=result)</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>FunctionCallNode Class</strong></p>
<p>Represents a function call within the abstract syntax tree (AST) for
shader code. This node captures the function name and its arguments.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `name`: The name of the function being called.
    -   `args`: A list of arguments passed to the function.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`FunctionCallNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "FunctionCallNode(name=&lt;name&gt;, args=&lt;args&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
func_call_node = FunctionCallNode(name="someFunction", args=["arg1", "arg2"])
print(repr(func_call_node))</p>
<h1 id="output-functioncallnodenamesomefunction-argsarg1-arg2">Output: FunctionCallNode(name=someFunction, args=['arg1', 'arg2'])</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>BinaryOpNode Class</strong></p>
<p>Represents a binary operation within the abstract syntax tree (AST) for
shader code. This node captures the left operand, operator, and right
operand of the operation.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `left`: The left operand of the binary operation.
    -   `op`: The operator used for the binary operation.
    -   `right`: The right operand of the binary operation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`BinaryOpNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "BinaryOpNode(left=&lt;left&gt;, op=&lt;op&gt;, right=&lt;right&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
binary_op_node = BinaryOpNode(left="a", op="PLUS", right="b")
print(repr(binary_op_node))</p>
<h1 id="output-binaryopnodelefta-opplus-rightb">Output: BinaryOpNode(left=a, op=PLUS, right=b)</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>MemberAccessNode Class</strong></p>
<p>Represents an access operation for a member of an object within the
abstract syntax tree (AST) for shader code. This node captures the
object and the specific member being accessed.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `object`: The object whose member is being accessed.
    -   `member`: The specific member of the object being
        accessed.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`MemberAccessNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "MemberAccessNode(object=&lt;object&gt;, member=&lt;member&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
member_access_node = MemberAccessNode(object="myStruct", member="x")
print(repr(member_access_node))</p>
<h1 id="output-memberaccessnodeobjectmystruct-memberx">Output: MemberAccessNode(object=myStruct, member=x)</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>UnaryOpNode Class</strong></p>
<p>Represents a unary operation within the abstract syntax tree (AST) for
shader code. This node captures the operator and the single operand of
the operation.</p>
<ul>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `op`: The operator for the unary operation.
    -   `operand`: The single operand on which the unary operation
        is applied.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Purpose\*\*: Provides a detailed string representation of the \`UnaryOpNode]{.title-ref} instance for debugging purposes.

    :   -   **Returns**: A string in the format:

        ``` python
        "UnaryOpNode(op=&lt;op&gt;, operand=&lt;operand&gt;)"
        ```
</code></pre>
</li>
<li>
<p><strong>Example</strong>:</p>
<blockquote>
<p>``` python
unary_op_node = UnaryOpNode(op="NEG", operand="x")
print(repr(unary_op_node))</p>
<h1 id="output-unaryopnodeopneg-operandx">Output: UnaryOpNode(op=NEG, operand=x)</h1>
<p>```</p>
</blockquote>
</li>
</ul>
<p><strong>Explanation:</strong></p>
<ul>
<li>`op`: Represents the unary operator. This could be an operation
    such as negation (-), logical NOT (!), or any other unary operation.</li>
<li>`operand`: Represents the operand on which the unary operation is
    performed. This is typically a variable or an expression.</li>
</ul>
<p>The [UnaryOpNode]{.title-ref} class is essential for representing unary
operations in shader code. It enables the AST to handle and process
operations that involve a single operand, facilitating the
interpretation and transformation of shader code that includes unary
operations.</p>
<h1 id="lexer">Lexer</h1>
<p>The [TOKENS]{.title-ref} list defines regular expressions for various
tokens used in shader code. These tokens are used by a lexer to tokenize
shader source code into meaningful components. The
[KEYWORDS]{.title-ref} dictionary maps shader language keywords to their
corresponding token types.</p>
<p>Here's a breakdown of the token types and their corresponding regular
expressions:</p>
<h2 id="token-definitions">Token Definitions</h2>
<ul>
<li><strong>Comments</strong><ul>
<li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with
    [//]{.title-ref}.</li>
<li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed between
    [/*]{.title-ref} and [*/]{.title-ref}.</li>
</ul>
</li>
<li><strong>Shader Language Keywords</strong><ul>
<li><code>SHADER</code>: Matches the [shader]{.title-ref} keyword.</li>
<li><code>INPUT</code>: Matches the [input]{.title-ref} keyword.</li>
<li><code>OUTPUT</code>: Matches the [output]{.title-ref} keyword.</li>
<li><code>VOID</code>: Matches the [void]{.title-ref} keyword.</li>
<li><code>MAIN</code>: Matches the [main]{.title-ref} keyword.</li>
<li><code>UNIFORM</code>: Matches the [uniform]{.title-ref} keyword.</li>
<li><code>VECTOR</code>: Matches [vec2]{.title-ref}, [vec3]{.title-ref}, or
    [vec4]{.title-ref}.</li>
<li><code>MATRIX</code>: Matches [mat2]{.title-ref}, [mat3]{.title-ref}, or
    [mat4]{.title-ref}.</li>
<li><code>BOOL</code>: Matches the [bool]{.title-ref} keyword.</li>
<li><code>VERTEX</code>: Matches the [vertex]{.title-ref} keyword.</li>
<li><code>FRAGMENT</code>: Matches the [fragment]{.title-ref} keyword.</li>
</ul>
</li>
<li><strong>Data Types</strong><ul>
<li><code>FLOAT_NUMBER</code>: Matches floating-point numbers (e.g.,
    [1.0]{.title-ref}, [0.5]{.title-ref}, [3.]{.title-ref}).</li>
<li><code>FLOAT</code>: Matches the [float]{.title-ref} keyword.</li>
<li><code>INT</code>: Matches the [int]{.title-ref} keyword.</li>
<li><code>UINT</code>: Matches the [uint]{.title-ref} keyword.</li>
<li><code>DOUBLE</code>: Matches the [double]{.title-ref} keyword.</li>
<li><code>SAMPLER2D</code>: Matches the [sampler2D]{.title-ref} keyword.</li>
</ul>
</li>
<li><strong>Identifiers and Constants</strong><ul>
<li><code>IDENTIFIER</code>: Matches variable and function names.</li>
<li><code>NUMBER</code>: Matches integer numbers (e.g., [1]{.title-ref},
    [42]{.title-ref}).</li>
</ul>
</li>
<li><strong>Operators and Punctuation</strong><ul>
<li><code>ASSIGN_SHIFT_RIGHT</code>: Matches [&gt;&gt;=]{.title-ref}.</li>
<li><code>ASSIGN_SHIFT_LEFT</code>: Matches [\&lt;\&lt;=]{.title-ref}.</li>
<li><code>ASSIGN_ADD</code>: Matches [+=]{.title-ref}.</li>
<li><code>ASSIGN_SUB</code>: Matches [-=]{.title-ref}.</li>
<li><code>ASSIGN_MUL</code>: Matches [*=]{.title-ref}.</li>
<li><code>ASSIGN_DIV</code>: Matches [/=]{.title-ref}.</li>
<li><code>ASSIGN_AND</code>: Matches [&amp;=]{.title-ref}.</li>
<li><code>ASSIGN_OR</code>: Matches [|=]{.title-ref}.</li>
<li><code>ASSIGN_XOR</code>: Matches [\^=]{.title-ref}.</li>
<li><code>ASSIGN_MOD</code>: Matches [%=]{.title-ref}.</li>
<li><code>BITWISE_SHIFT_LEFT</code>: Matches [\&lt;\&lt;]{.title-ref}.</li>
<li><code>BITWISE_SHIFT_RIGHT</code>: Matches [&gt;&gt;]{.title-ref}.</li>
<li><code>LESS_EQUAL</code>: Matches [\&lt;=]{.title-ref}.</li>
<li><code>GREATER_EQUAL</code>: Matches [&gt;=]{.title-ref}.</li>
<li><code>GREATER_THAN</code>: Matches [&gt;]{.title-ref}.</li>
<li><code>LESS_THAN</code>: Matches [\&lt;]{.title-ref}.</li>
<li><code>INCREMENT</code>: Matches [++]{.title-ref}.</li>
<li><code>DECREMENT</code>: Matches [--]{.title-ref}.</li>
<li><code>EQUAL</code>: Matches [==]{.title-ref}.</li>
<li><code>NOT_EQUAL</code>[: Matches ]{.title-ref}!=`.</li>
<li><code>LOGICAL_AND</code>: Matches [&amp;&amp;]{.title-ref}.</li>
<li><code>LOGICAL_OR</code>: Matches [||]{.title-ref}.</li>
<li><code>XOR</code>: Matches [\^]{.title-ref}.</li>
<li><code>NOT</code>: Matches [!]{.title-ref}.</li>
<li><code>PLUS</code>: Matches [+]{.title-ref}.</li>
<li><code>MINUS</code>: Matches [-]{.title-ref}.</li>
<li><code>MULTIPLY</code>: Matches [*]{.title-ref}.</li>
<li><code>DIVIDE</code>: Matches [/]{.title-ref}.</li>
<li><code>MOD</code>: Matches [%]{.title-ref}.</li>
<li><code>DOT</code>: Matches [.]{.title-ref}.</li>
<li><code>EQUALS</code>: Matches [=]{.title-ref}.</li>
<li><code>QUESTION</code>: Matches [?]{.title-ref}.</li>
<li><code>COLON</code>: Matches [:]{.title-ref}.</li>
</ul>
</li>
<li><strong>Brackets and Delimiters</strong><ul>
<li><code>LBRACE</code>: Matches [{]{.title-ref}.</li>
<li><code>RBRACE</code>: Matches [}]{.title-ref}.</li>
<li><code>LPAREN</code>: Matches [(]{.title-ref}.</li>
<li><code>RPAREN</code>: Matches [)]{.title-ref}.</li>
<li><code>SEMICOLON</code>: Matches [;]{.title-ref}.</li>
<li><code>COMMA</code>: Matches [,]{.title-ref}.</li>
</ul>
</li>
<li><strong>Whitespace and Miscellaneous</strong><ul>
<li><code>WHITESPACE</code>: Matches any whitespace characters.</li>
<li><code>CONST</code>: Matches the [const]{.title-ref} keyword.</li>
<li><code>BITWISE_AND</code>: Matches [&amp;]{.title-ref}.</li>
<li><code>BITWISE_OR</code>: Matches [|]{.title-ref}.</li>
<li><code>BITWISE_XOR</code>: Matches [\^]{.title-ref}.</li>
<li><code>BITWISE_NOT</code>: Matches [\~]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="keywords-dictionary">Keywords Dictionary</h2>
<p>The [KEYWORDS]{.title-ref} dictionary maps shader language keywords to
their corresponding token types. This helps in identifying and
categorizing keywords during tokenization.</p>
<p>This setup allows a lexer to parse shader code and generate tokens that
can be used for further processing, such as syntax checking, code
generation, or transformation.</p>
<p>Attributes: - code (str): The input code to tokenize - tokens (list): A
list of tokens generated from the input code</p>
<h2 id="methods_4">Methods</h2>
<p><strong>__init__(self):</strong></p>
<p>Initializes the code generator.</p>
<p>---</p>
<p><strong>Tokenize :</strong></p>
<p>This method is designed to process a string of shader code and convert
it into a list of tokens based on predefined regular expressions. Here's
a detailed explanation of what each part of the method does:</p>
<ol>
<li><strong>Initialization</strong>:<ul>
<li>`pos = 0`: Initializes the position counter to start from the
    beginning of the code.</li>
</ul>
</li>
<li><strong>Token Matching Loop</strong>:<ul>
<li>The [while]{.title-ref} loop continues as long as
    [pos]{.title-ref} is less than the length of
    [self.code]{.title-ref}.</li>
<li>`match = None`: Initializes the [match]{.title-ref} variable
    to store the result of regex matching.</li>
</ul>
</li>
<li><strong>Regex Matching</strong>:<ul>
<li>The [for]{.title-ref} loop iterates over each token type and its
    corresponding pattern in the [TOKENS]{.title-ref} list.</li>
<li>`regex = re.compile(pattern)`: Compiles the regex pattern for
    the current token type.</li>
<li>`match = regex.match(self.code, pos)`: Attempts to match the
    regex pattern against the code starting at the current position.</li>
</ul>
</li>
<li><strong>Handling Matches</strong>:<ul>
<li>
<p>If a match is found:</p>
<p>:   -   `text = match.group(0)`: Extracts the matched text.
    -   `if token_type == \"IDENTIFIER\" and text in
        KEYWORDS`: Checks if the identifier is a keyword and
        updates the token type accordingly.
    -   `if token_type != \"WHITESPACE\"`: Skips whitespace
        tokens and does not append them to the list of tokens.
    -   `self.tokens.append(token)[: Appends the token (type
        and text) to the `self.tokens]{.title-ref} list.
    -   `pos = match.end(0)`: Updates the position counter to
        the end of the matched text.
    -   `break`: Exits the [for]{.title-ref} loop to continue
        with the next position.
5.  <strong>Handling Unmatched Characters</strong>:
    -   </p>
<p>If no match is found ([if not match]{.title-ref}):</p>
<p>:   -   `unmatched_char = self.code[pos]`: Captures the
        character at the current position.
    -   `highlighted_code`: Highlights the illegal character
        in the code for easier debugging.
    -   Raises a [SyntaxError]{.title-ref} with a message
        indicating the illegal character and its position.
6.  <strong>End of File Token</strong>:
    -   `self.tokens.append((\"EOF\", None))`: Appends an "EOF" (end
of file) token to indicate the end of the token stream.</p>
</li>
</ul>
</li>
</ol>
<p>---</p>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Efficient Matching</strong>: By using regex patterns and the
    [re.match]{.title-ref} method, the tokenizer efficiently matches
    different types of tokens.</li>
<li><strong>Error Handling</strong>: Properly raises a [SyntaxError]{.title-ref} when
    encountering illegal characters.</li>
<li><strong>Token Management</strong>: Handles and stores tokens while skipping
    unnecessary whitespace and maintaining the position in the code.</li>
</ul>
<p>This method ensures that the input shader code is tokenized correctly,
allowing further processing like parsing or code generation to be
performed.</p>
<h1 id="parser">Parser</h1>
<p>This parser generates an abstract syntax tree (AST) from a list of
tokens.</p>
<p>Attributes:</p>
<p>:   -   tokens (list): A list of tokens generated from the input code</p>
<h2 id="methods_5">Methods</h2>
<ul>
<li>
<p><strong>__init__(self) :</strong></p>
<p>Initializes the code generator.</p>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>skip_comments:</strong></p>
<p>:   -   <strong>Description</strong>: This method iterates through the token list
        and advances the position until the current token is no
        longer identified as a comment. It handles both single-line
        and multi-line comments by continuously consuming tokens
        classified as [COMMENT_SINGLE]{.title-ref} or
        [COMMENT_MULTI]{.title-ref}.
    -   <strong>Parameters</strong>: None
    -   <strong>Returns</strong>: None</p>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>eat :</strong></p>
<p>:   -   <strong>Description</strong>: This method checks if the current token
        matches the specified [token_type]{.title-ref}. If it does,
        the token is consumed, and the position is incremented to
        the next token. After consuming the token, comments are
        skipped by calling skip_comments. If the current token does
        not match the expected token type, a
        [SyntaxError]{.title-ref} is raised.</p>
<pre><code>-

    **Parameters**:

    :   -   [token_type]{.title-ref} (str): The expected token
            type.

-   **Returns**: None
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse_uniforms:</strong></p>
<p>:   -   <strong>Description</strong>: This method processes the shader code to
        identify and extract uniform declarations. It starts by
        consuming the [\"UNIFORM\"]{.title-ref} token and then reads
        the uniform's type and name. The method expects uniform
        types to be one of [\"VECTOR\"]{.title-ref},
        [\"FLOAT\"]{.title-ref}, [\"DOUBLE\"]{.title-ref},
        [\"UINT\"]{.title-ref}, [\"INT\"]{.title-ref}, or
        [\"SAMPLER2D\"]{.title-ref}. After parsing the type and
        name, it consumes the following [\"SEMICOLON\"]{.title-ref}
        token. The method returns a list of
        [UniformNode]{.title-ref} objects representing the parsed
        uniform declarations.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`list\`: A list of [UniformNode]{.title-ref}
            objects.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token is not
            [\"UNIFORM\"]{.title-ref} or if an unexpected token
            is encountered when parsing the uniform type.
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse :</strong></p>
<p>:   -   <strong>Description</strong>: This method initiates the parsing process
        for the shader code. It calls the parse_shader method to
        handle the specifics of shader code parsing and constructs
        the abstract syntax tree (AST) that represents the structure
        and components of the shader.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`ShaderNode\`: The root node of the abstract syntax
            tree (AST) representing the parsed shader code.
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse_shader:</strong></p>
<p>:   -   <strong>Description</strong>: This method processes the shader code to
        construct a [ShaderNode]{.title-ref} object. It starts by
        consuming the "SHADER" token and then skips any comments. It
        extracts the shader's name, then parses global inputs,
        uniforms, outputs, and sections for vertex and fragment
        shaders. It also collects global functions. The method
        continues parsing until it encounters the closing brace of
        the shader definition and constructs a
        [ShaderNode]{.title-ref} representing the shader's
        structure.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`ShaderNode\`: The root node of the abstract syntax
            tree (AST) representing the parsed shader code.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match
            the expected token type, indicating a syntax issue
            in the shader code.
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse_shader_section:</strong></p>
<p>:   -   <strong>Description</strong>: This method processes a specific shader
        section, either "VERTEX" or "FRAGMENT", by consuming the
        section header and opening brace. It then collects and
        processes inputs, outputs, functions, and intermediate
        statements until it encounters the closing brace. It
        constructs and returns a [VERTEXShaderNode]{.title-ref} or
        [FRAGMENTShaderNode]{.title-ref} based on the
        [section_type]{.title-ref} parameter.</p>
<pre><code>-

    **Parameters**:

    :   -   [section_type]{.title-ref} (str): The type of shader
            section to parse, either "VERTEX" or "FRAGMENT".

-

    **Returns**:

    :   -   [VERTEXShaderNode]{.title-ref} or
            \`FRAGMENTShaderNode\`: The root node of the AST for
            the specified shader section.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match
            the expected token type, indicating a syntax issue
            in the shader section.
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse_inputs:</strong></p>
<p>:   -   <strong>Description</strong>: This method processes and extracts input
        declarations from the shader code by consuming the "INPUT"
        token, followed by the variable type and name. It collects
        these declarations into a list until it encounters a token
        that is not an "INPUT".</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`list\`: A list of tuples representing the input
            declarations, where each tuple contains the type and
            name of an input.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match
            the expected input types (VECTOR, FLOAT, DOUBLE,
            UINT, INT, MATRIX, or SAMPLER2D).
</code></pre>
</li>
</ul>
<p>---</p>
<ul>
<li>
<p><strong>parse_outputs:</strong></p>
<p>:   -   <strong>Description</strong>: This method processes and extracts output
        declarations from the shader code by consuming the "OUTPUT"
        token, followed by the variable type and name. It continues
        to collect these declarations into a list until it
        encounters a token that is not an "OUTPUT".</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`list\`: A list of tuples representing the output
            declarations, where each tuple contains the type and
            name of an output.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match
            the expected output types (VECTOR, FLOAT, DOUBLE,
            UINT, INT, MATRIX, or SAMPLER2D).
</code></pre>
</li>
</ul>
<p>---</p>
<p><strong>parse_function</strong></p>
<p>:   -   <strong>Description</strong>: This method processes a function declaration by
        extracting the return type, function name, parameters, and body.
        It expects either "MAIN" or an "IDENTIFIER" as the function
        name, then parses the function's parameters enclosed in
        parentheses, and finally, parses the function's body within
        curly braces.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`FunctionNode\`: A [FunctionNode]{.title-ref} object
            representing the parsed function declaration, including
            its return type, name, parameters, and body.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected format for a function declaration, such as not
            finding "MAIN" or an "IDENTIFIER" where expected.
</code></pre>
<p><strong>parse_parameters</strong></p>
<p>:   -   <strong>Description</strong>: This method processes function parameters by
        collecting them into a list. It handles multiple parameters
        separated by commas and continues parsing until the closing
        parenthesis is encountered.</p>
<pre><code>-   **Parameters**: None.

-

    **Returns**:

    :   -   \`list\`: A list of function parameters, where each
            parameter is represented according to the shader
            language's syntax.

-

    **Raises**:

    :   -   [None]{.title-ref}.
</code></pre>
<p><strong>parse_parameter</strong></p>
<p>:   -   <strong>Description</strong>: This method extracts the type and name of a
        function parameter. It processes the parameter type using the
        [parse_type]{.title-ref} method and captures the parameter name
        from the current token.</p>
<pre><code>-   **Parameters**: None.

-

    **Returns**:

    :   -   \`tuple\`: A tuple containing the parameter type and
            name.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected type for a parameter.
</code></pre>
<p><strong>parse_type</strong></p>
<p>:   -   <strong>Description</strong>: This method identifies and returns the type of
        a shader variable or function. It handles basic shader types
        such as [void]{.title-ref}, [VECTOR]{.title-ref},
        [FLOAT]{.title-ref}, [DOUBLE]{.title-ref}, [UINT]{.title-ref},
        [INT]{.title-ref}, [MATRIX]{.title-ref},
        [SAMPLER2D]{.title-ref}, and user-defined types. The method
        checks the current token and returns the appropriate type
        string.</p>
<pre><code>-   **Parameters**: None.

-

    **Returns**:

    :   -   \`str\`: The name of the type.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match a
            valid type declaration.
</code></pre>
<p><strong>parse_body</strong></p>
<p>:   -   <strong>Description</strong>: This method processes the statements within a
        function body, constructing a list of statements by identifying
        and parsing control structures ([IF]{.title-ref},
        [FOR]{.title-ref}), return statements, and assignments or
        function calls. It continues parsing until it encounters a
        closing brace [RBRACE]{.title-ref} or end-of-file
        [EOF]{.title-ref}.</p>
<pre><code>-   **Parameters**: None.

-

    **Returns**:

    :   -   \`list\`: A list of statements contained in the function
            body.

-

    **Raises**:

    :   -   \`SyntaxError\`: If an unexpected token is encountered
            while parsing the function body.
</code></pre>
<p><strong>parse_if_statement</strong></p>
<p>:   -   <strong>Description</strong>: This method processes an [if]{.title-ref}
        statement by extracting the condition, the body of the
        [if]{.title-ref} block, and optionally the [else]{.title-ref}
        block if present. It constructs an [IfNode]{.title-ref} object
        representing the parsed [if]{.title-ref} statement, including
        its condition and the corresponding bodies for the
        [if]{.title-ref} and [else]{.title-ref} branches.</p>
<pre><code>-   **Parameters**: None.

-

    **Returns**:

    :   -   \`IfNode\`: An [IfNode]{.title-ref} object representing
            the [if]{.title-ref} statement, including the condition
            and the bodies for both the [if]{.title-ref} and
            [else]{.title-ref} blocks.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected structure of an [if]{.title-ref} statement.
</code></pre>
<p><strong>peak</strong></p>
<p>:   -   <strong>Description</strong>: This method retrieves the token that is
        [n]{.title-ref} positions ahead in the token list without
        advancing the current position. It allows inspection of future
        tokens for decision-making during parsing.</p>
<pre><code>-

    **Parameters**:

    :   -   \`n (int)\`: The number of tokens to peek ahead in the
            token list.

-

    **Returns**:

    :   -   \`tuple\`: The nth token ahead in the token list.

-

    **Raises**:

    :   -   \`IndexError\`: If peeking beyond the end of the token
            list.
</code></pre>
<p><strong>parse_for_loop</strong></p>
<p>:   -   <strong>Description</strong>: This method processes the components of a for
        loop, including initialization, condition, update, and body. It
        constructs a [ForNode]{.title-ref} object representing the for
        loop structure.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`ForNode\`: An object representing the parsed for loop,
            including its initialization, condition, update, and
            body.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected for loop structure.
</code></pre>
<p><strong>parse_update</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets an update statement,
        handling both increment and decrement operations. It constructs
        a [VariableNode]{.title-ref} object representing the update
        statement with the appropriate operation.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the update
            statement, which could be a [VariableNode]{.title-ref}
            reflecting an increment or decrement operation.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected update statement structure.
</code></pre>
<p><strong>parse_return_statement</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets a return statement,
        capturing the values to be returned. It constructs a
        [ReturnNode]{.title-ref} object that represents the return
        statement with the appropriate return values.</p>
<pre><code>-   **Parameters**: None

-

    **Returns**:

    :   -   \`ReturnNode\`: An object representing the return
            statement, containing a list of values to be returned.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected return statement structure.
</code></pre>
<p><strong>parse_assignment_or_function_call</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets either an assignment
        statement or a function call. It handles various types of
        assignment operations and updates to variables. Additionally, it
        processes function calls when the identifier is followed by
        parentheses.</p>
<pre><code>-

    **Parameters**:

    :   -   [update_condition]{.title-ref} (bool, optional): A flag
            indicating whether the parsing should handle special
            update conditions (e.g., increment or decrement
            operations). Default is [False]{.title-ref}.

-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the assignment or
            function call. This could be an
            [AssignmentNode]{.title-ref},
            [FunctionCallNode]{.title-ref}, or a modified
            [VariableNode]{.title-ref} if an increment or decrement
            operation is detected.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match any
            expected patterns for assignments, function calls, or
            updates.
</code></pre>
<p><strong>parse_variable_declaration</strong></p>
<p>:   -   <strong>Description</strong>: This method parses a variable declaration,
        handling both simple declarations and assignments. It constructs
        a [VariableNode]{.title-ref} or [BinaryOpNode]{.title-ref}
        representing the variable declaration or assignment, including
        handling for member access and compound assignments.</p>
<pre><code>-

    **Returns**:

    :   -   [VariableNode]{.title-ref} or \`BinaryOpNode\`: An
            object representing the variable declaration or
            assignment.

-

    **Raises**:

    :   -   [SyntaxError]{.title-ref} : If the current token does
            not match the expected variable declaration or
            assignment structure.
</code></pre>
<p><strong>parse_assignment</strong></p>
<p>:   -   <strong>Description</strong>: This method parses an assignment statement,
        including various assignment operators. It constructs a
        [BinaryOpNode]{.title-ref} representing the assignment
        operation, with the variable name and the assigned value.</p>
<pre><code>-

    **Attributes**:

    :   -   \`name (str)\`: The name of the variable being assigned.

-

    **Returns**:

    :   -   \`BinaryOpNode\`: An object representing the assignment
            statement.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected assignment operator or structure.
</code></pre>
<p><strong>parse_additive</strong></p>
<p>:   -   <strong>Description</strong>: This method parses an additive expression,
        which includes addition and subtraction operations. It
        constructs a [BinaryOpNode]{.title-ref} representing the
        additive expression, handling multiple operations as needed.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the additive
            expression.

-

    **Raises**:

    :   -   \`SyntaxError\`: Not applicable for this method, as it
            does not handle syntax errors directly.
</code></pre>
<p><strong>parse_multiplicative</strong></p>
<p>:   -   <strong>Description</strong>: This method parses a multiplicative expression,
        which includes multiplication and division operations. It
        constructs a [BinaryOpNode]{.title-ref} representing the
        multiplicative expression, handling multiple operations as
        needed.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the multiplicative
            expression.

-

    **Raises**:

    :   -   \`SyntaxError\`: Not applicable for this method, as it
            does not handle syntax errors directly.
</code></pre>
<p><strong>parse_unary</strong></p>
<p>:   -   <strong>Description</strong>: This method parses a unary expression,
        including unary plus and minus operations. It constructs a
        [UnaryOpNode]{.title-ref} representing the unary expression or
        proceeds to parse a primary expression if no unary operators are
        present.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the unary
            expression.

-

    **Raises**:

    :   -   \`SyntaxError\`: Not applicable for this method, as it
            does not handle syntax errors directly.
</code></pre>
<p><strong>parse_primary</strong></p>
<p>:   -   <strong>Description</strong>: This method parses primary expressions, which
        include parenthesized expressions, numeric literals, and
        identifiers. It handles different token types to construct the
        appropriate AST node or value. If the token is not recognized as
        a valid primary expression, it raises a
        [SyntaxError]{.title-ref}.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the primary
            expression, which could be a value or a node from a
            function call or identifier.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match a
            valid primary expression.
</code></pre>
<p><strong>parse_function_call</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets a function call by
        reading the function name and its arguments. It constructs a
        [FunctionCallNode]{.title-ref} object representing the function
        call with the parsed arguments.</p>
<pre><code>-

    **Attributes**:

    :   -   \`name (str)\`: The name of the function being called.

-

    **Returns**:

    :   -   \`FunctionCallNode\`: An object representing the
            function call, including the function name and a list of
            arguments.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected structure for a function call.
</code></pre>
<p><strong>parse_expression</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets an expression, handling
        various operators to construct a [BinaryOpNode]{.title-ref} that
        represents the expression's structure.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the parsed
            expression, which could be a [BinaryOpNode]{.title-ref}
            reflecting the expression's operators and operands.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected structure for an expression.
</code></pre>
<p><strong>parse_ternary</strong></p>
<p>:   -   <strong>Description</strong>: This method interprets a ternary expression,
        handling the ternary operator ([? :]{.title-ref}) to construct a
        [TernaryOpNode]{.title-ref} that represents the ternary
        expression's condition and its two possible outcomes.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing the parsed ternary
            expression, which could be a [TernaryOpNode]{.title-ref}
            reflecting the condition and both branches of the
            ternary operator.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected structure for a ternary expression.
</code></pre>
<p><strong>parse_function_call_or_identifier</strong></p>
<p>:   -   <strong>Description</strong>: This method determines whether the current
        token represents a function call or a simple identifier. It
        constructs a [FunctionCallNode]{.title-ref} if it detects a
        function call, or a [VariableNode]{.title-ref} if it detects an
        identifier. It also handles member access if a dot
        ([.]{.title-ref}) follows the identifier.</p>
<pre><code>-

    **Returns**:

    :   -   \`ASTNode\`: An object representing either a
            [FunctionCallNode]{.title-ref} for function calls, a
            [VariableNode]{.title-ref} for identifiers, or a member
            access node if applicable.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token does not match the
            expected structure for a function call or identifier.
</code></pre>
<p><strong>parse_member_access</strong></p>
<p>:   -   <strong>Description</strong>: This method parses member access operations,
        such as accessing a field of an object. It constructs a
        [MemberAccessNode]{.title-ref} representing the member access
        and handles cases where multiple member accesses are chained.</p>
<pre><code>-

    **Attributes**:

    :   -   \`object (str)\`: The object being accessed.

-

    **Returns**:

    :   -   \`MemberAccessNode\`: An object representing the member
            access operation.

-

    **Raises**:

    :   -   \`SyntaxError\`: If the current token is not a valid
            identifier following the dot ([.]{.title-ref}), or if
            the structure of the member access is not valid.
</code></pre>
<h1 id="api-references-for-directx-metal-and-opengl-to-crossgl">API References For DirectX , Metal And OpenGL To CrossGL</h1>
<h1 id="directx-ast">DirectX AST</h1>
<h2 id="ternaryopnode">TernaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a ternary operation in an abstract syntax tree (AST).</li>
<li>Contains the condition, the expression to evaluate if the
    condition is true, and the expression to evaluate if the
    condition is false.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`condition`: The condition expression for the ternary
    operation.</li>
<li>`true_expr`: The expression evaluated when the condition is
    true.</li>
<li>`false_expr`: The expression evaluated when the condition is
    false.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [TernaryOpNode]{.title-ref} instance, including the
    condition, true expression, and false expression.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="shadernode">ShaderNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a shader in an abstract syntax tree (AST).</li>
<li>Contains structures for vertex and pixel shader inputs and
    outputs, as well as functions defined within the shader.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`vsinput_struct`: The structure defining the inputs for the
    vertex shader.</li>
<li>`vsoutput_struct`: The structure defining the outputs for the
    vertex shader.</li>
<li>`psinput_struct`: The structure defining the inputs for the
    pixel shader.</li>
<li>`psoutput_struct`: The structure defining the outputs for the
    pixel shader.</li>
<li>`functions`: The list of functions defined within the shader.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [ShaderNode]{.title-ref} instance, including the vertex and
    pixel shader input/output structures and functions.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="structnodetitle-ref">[StructNode]{.title-ref}</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a structure in an abstract syntax tree (AST).</li>
<li>Contains the name of the structure and its members.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`name`: The name of the structure.</li>
<li>`members`: The list of members (fields) within the structure.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [StructNode]{.title-ref} instance, including the structure's
    name and its members.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="functionnode">FunctionNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a function in an abstract syntax tree (AST).</li>
<li>Contains the function's return type, name, parameters, and body.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`return_type`: The return type of the function.</li>
<li>`name`: The name of the function.</li>
<li>`params`: The list of parameters for the function.</li>
<li>`body`: The body of the function, containing the statements to
    be executed.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [FunctionNode]{.title-ref} instance, including the return
    type, name, parameters, and body of the function.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="variablenode">VariableNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a variable in an abstract syntax tree (AST).</li>
<li>Contains the variable's type, name, and optional semantic
    information.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`vtype`: The type of the variable.</li>
<li>`name`: The name of the variable.</li>
<li>`semantic`: Optional semantic information associated with the
    variable.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [VariableNode]{.title-ref} instance, including the
    variable's type, name, and semantic information.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="assignmentnode">AssignmentNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an assignment operation in an abstract syntax tree
    (AST).</li>
<li>Contains the left-hand side (variable or expression), right-hand
    side (value or expression), and the operator used for the
    assignment.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`left`: The left-hand side of the assignment (variable or
    expression).</li>
<li>`right`: The right-hand side of the assignment (value or
    expression).</li>
<li>`operator`: The operator used for the assignment, defaulting
    to [\"=\"]{.title-ref}.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [AssignmentNode]{.title-ref} instance, including the
    left-hand side, operator, and right-hand side of the
    assignment.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ifnode">IfNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an [if]{.title-ref} statement in an abstract syntax
    tree (AST).</li>
<li>Contains the condition for the [if]{.title-ref} statement, the
    body to execute if the condition is true, and an optional body
    for the [else]{.title-ref} branch.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`condition`: The condition to evaluate for the
    [if]{.title-ref} statement.</li>
<li>`if_body`: The body of code to execute if the condition is
    true.</li>
<li>`else_body`: The optional body of code to execute if the
    condition is false.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the [IfNode]{.title-ref}
    instance, including the condition, [if]{.title-ref} body,
    and [else]{.title-ref} body.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fornode">ForNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a [for]{.title-ref} loop statement in an abstract
    syntax tree (AST).</li>
<li>Contains the initialization, condition, update expression, and
    the body of the loop.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`init`: The initialization expression for the
    [for]{.title-ref} loop.</li>
<li>`condition`: The condition to evaluate for continuing the
    loop.</li>
<li>`update`: The update expression to modify the loop variable.</li>
<li>`body`: The body of code to execute during each iteration of
    the loop.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the [ForNode]{.title-ref}
    instance, including the initialization, condition, update,
    and body of the [for]{.title-ref} loop.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="returnnode">ReturnNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a [return]{.title-ref} statement in an abstract
    syntax tree (AST).</li>
<li>Contains the value to be returned from a function or method.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`value`: The value to return from the function or method.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [ReturnNode]{.title-ref} instance, including the value to be
    returned.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="functioncallnode">FunctionCallNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a function call in an abstract syntax tree (AST).</li>
<li>Contains the name of the function being called and the arguments
    passed to it.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`name`: The name of the function being called.</li>
<li>`args`: The list of arguments passed to the function.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [FunctionCallNode]{.title-ref} instance, including the
    function name and arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="binaryopnode">BinaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a binary operation in an abstract syntax tree (AST).</li>
<li>Contains the left operand, the operator used, and the right
    operand.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`left`: The left operand of the binary operation.</li>
<li>`op`: The operator used in the binary operation.</li>
<li>`right`: The right operand of the binary operation.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [BinaryOpNode]{.title-ref} instance, including the left
    operand, operator, and right operand.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="memberaccessnode">MemberAccessNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents access to a member of an object in an abstract syntax
    tree (AST).</li>
<li>Contains the object being accessed and the member being
    accessed.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`object`: The object whose member is being accessed.</li>
<li>`member`: The member of the object being accessed.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [MemberAccessNode]{.title-ref} instance, including the
    object and the member.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="vectorconstructornode">VectorConstructorNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a vector constructor in an abstract syntax tree
    (AST).</li>
<li>Contains the type of the vector and the arguments used to
    initialize it.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`type_name`: The type of the vector being constructed.</li>
<li>`args`: The list of arguments used to initialize the vector.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [VectorConstructorNode]{.title-ref} instance, including the
    vector type and arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="unaryopnode">UnaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a unary operation in an abstract syntax tree (AST).</li>
<li>Contains the operator used and the operand on which the
    operation is performed.</li>
</ul>
</li>
<li><strong>Attributes</strong>:<ul>
<li>`op`: The operator used in the unary operation.</li>
<li>`operand`: The operand on which the unary operation is
    applied.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li>Returns a string representation of the
    [UnaryOpNode]{.title-ref} instance, including the operator
    and operand.</li>
</ul>
</li>
<li><strong>`__str__`</strong>:<ul>
<li>Returns a formatted string of the unary operation, showing
    the operator followed by the operand.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="directx-lexer">DirectX Lexer</h1>
<h2 id="tokens">Tokens</h2>
<ul>
<li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with <code>//</code>.</li>
<li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed by
    <code>/* ... */</code>.</li>
<li><code>STRUCT</code>: Matches the keyword <code>struct</code>.</li>
<li><code>CBUFFER</code>: Matches the keyword <code>cbuffer</code>.</li>
<li><code>TEXTURE2D</code>: Matches the keyword <code>Texture2D</code>.</li>
<li><code>SAMPLER_STATE</code>: Matches the keyword <code>SamplerState</code>.</li>
<li><code>FVECTOR</code>: Matches float vector types (e.g., <code>float2</code>, <code>float3</code>,
    <code>float4</code>).</li>
<li><code>FLOAT</code>: Matches the keyword <code>float</code>.</li>
<li><code>INT</code>: Matches the keyword <code>int</code>.</li>
<li><code>UINT</code>: Matches the keyword <code>uint</code>.</li>
<li><code>BOOL</code>: Matches the keyword <code>bool</code>.</li>
<li><code>MATRIX</code>: Matches matrix types (e.g., <code>float2x2</code>, <code>float3x3</code>,
    <code>float4x4</code>).</li>
<li><code>VOID</code>: Matches the keyword <code>void</code>.</li>
<li><code>RETURN</code>: Matches the keyword <code>return</code>.</li>
<li><code>IF</code>: Matches the keyword <code>if</code>.</li>
<li><code>ELSE_IF</code>: Matches <code>else if</code> keyword.</li>
<li><code>ELSE</code>: Matches the keyword <code>else</code>.</li>
<li><code>FOR</code>: Matches the keyword <code>for</code>.</li>
<li><code>REGISTER</code>: Matches the keyword <code>register</code>.</li>
<li><code>SEMANTIC</code>: Matches semantic annotations (e.g., <code>: POSITION</code>).</li>
<li><code>IDENTIFIER</code>: Matches identifiers (variable names, function names,
    etc.).</li>
<li><code>NUMBER</code>: Matches numerical literals (integers and floats).</li>
<li><code>LBRACE</code>: Matches the left brace <code>{</code>.</li>
<li><code>RBRACE</code>: Matches the right brace <code>}</code>.</li>
<li><code>LPAREN</code>: Matches the left parenthesis <code>(</code>.</li>
<li><code>RPAREN</code>: Matches the right parenthesis <code>)</code>.</li>
<li><code>LBRACKET</code>: Matches the left bracket <code>[</code>.</li>
<li><code>RBRACKET</code>: Matches the right bracket <code>]</code>.</li>
<li><code>SEMICOLON</code>: Matches the semicolon <code>;</code>.</li>
<li><code>COMMA</code>: Matches the comma <code>,</code>.</li>
<li><code>COLON</code>: Matches the colon <code>:</code>.</li>
<li><code>QUESTION</code>: Matches the question mark <code>?</code>.</li>
<li><code>LESS_EQUAL</code>: Matches the less than or equal to operator <code>&lt;=</code>.</li>
<li><code>GREATER_EQUAL</code>: Matches the greater than or equal to operator <code>&gt;=</code>.</li>
<li><code>LESS_THAN</code>: Matches the less than operator <code>&lt;</code>.</li>
<li><code>GREATER_THAN</code>: Matches the greater than operator <code>&gt;</code>.</li>
<li><code>EQUAL</code>: Matches the equality operator <code>==</code>.</li>
<li><code>NOT_EQUAL</code>: Matches the not equal to operator <code>!=</code>.</li>
<li><code>PLUS_EQUALS</code>: Matches the <code>+=</code> operator.</li>
<li><code>MINUS_EQUALS</code>: Matches the <code>-=</code> operator.</li>
<li><code>MULTIPLY_EQUALS</code>: Matches the <code>*=</code> operator.</li>
<li><code>DIVIDE_EQUALS</code>: Matches the <code>/=</code> operator.</li>
<li><code>AND</code>: Matches the logical AND operator <code>&amp;&amp;</code>.</li>
<li><code>OR</code>: Matches the logical OR operator <code>||</code>.</li>
<li><code>DOT</code>: Matches the dot operator <code>.</code>.</li>
<li><code>MULTIPLY</code>: Matches the multiplication operator <code>*</code>.</li>
<li><code>DIVIDE</code>: Matches the division operator <code>/</code>.</li>
<li><code>PLUS</code>: Matches the addition operator <code>+</code>.</li>
<li><code>MINUS</code>: Matches the subtraction operator <code>-</code>.</li>
<li><code>EQUALS</code>: Matches the assignment operator <code>=</code>.</li>
<li><code>WHITESPACE</code>: Matches whitespace characters.</li>
</ul>
<h2 id="keywords">Keywords</h2>
<ul>
<li><code>struct</code>: Maps to <code>STRUCT</code>.</li>
<li><code>cbuffer</code>: Maps to <code>CBUFFER</code>.</li>
<li><code>Texture2D</code>: Maps to <code>TEXTURE2D</code>.</li>
<li><code>SamplerState</code>: Maps to <code>SAMPLER_STATE</code>.</li>
<li><code>float</code>: Maps to <code>FLOAT</code>.</li>
<li><code>float2</code>, <code>float3</code>, <code>float4</code>: Map to <code>FVECTOR</code>.</li>
<li><code>int</code>: Maps to <code>INT</code>.</li>
<li><code>uint</code>: Maps to <code>UINT</code>.</li>
<li><code>bool</code>: Maps to <code>BOOL</code>.</li>
<li><code>void</code>: Maps to <code>VOID</code>.</li>
<li><code>return</code>: Maps to <code>RETURN</code>.</li>
<li><code>if</code>: Maps to <code>IF</code>.</li>
<li><code>else</code>: Maps to <code>ELSE</code>.</li>
<li><code>for</code>: Maps to <code>FOR</code>.</li>
<li><code>register</code>: Maps to <code>REGISTER</code>.</li>
</ul>
<hr />
<ul>
<li><strong>Description</strong>:<ul>
<li>Initializes the lexer with the given source code.</li>
<li>Tokenizes the source code into a list of tokens.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>`code`: The source code to be tokenized.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="tokenize-1">Tokenize:</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Tokenizes the source code into a list of tokens based on defined
    patterns.</li>
<li>Iterates through the source code, matches patterns, and
    categorizes tokens, while ignoring whitespace and comments.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>`SyntaxError`: If an illegal character is encountered in the
    source code.</li>
</ul>
</li>
</ul>
<h1 id="directx-parser">DirectX Parser</h1>
<p>::: {#init__-1}</p>
<hr />
<p>:::</p>
<ul>
<li><strong>Description</strong>:<ul>
<li>Initializes the parser with a list of tokens.</li>
<li>Sets the initial position and current token, and skips any
    initial comments.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>`tokens`: The list of tokens to be parsed.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="skip_comments">skip_comments</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Skips over tokens that are comments (both single-line and
    multi-line) in the source code.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="eat">eat</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Consumes the current token if it matches the expected type.</li>
<li>Advances to the next token and skips any comments following the
    current token.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>`token_type`: The type of token expected to be consumed.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>`SyntaxError`: If the current token does not match the
    expected token type.</li>
</ul>
</li>
</ul>
<h2 id="parse">parse</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses the entire shader code by calling parse_shader.</li>
<li>Ensures that the end of the file (EOF) is reached after parsing.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>The parsed shader object.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_shader">parse_shader</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses the shader code to extract structures and functions.</li>
<li>Identifies and assigns structures to specific shader stages and
    collects functions.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [ShaderNode]{.title-ref} object containing the parsed
    structures and functions.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_struct">parse_struct</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a structure definition, including its name and members.</li>
<li>Processes each member's type, name, and optional semantic
    information.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [StructNode]{.title-ref} object representing the parsed
    structure.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_function">parse_function</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a function definition, including its return type, name,
    parameters, and body.</li>
<li>Handles optional semantic tokens and constructs a
    [FunctionNode]{.title-ref} with the parsed details.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [FunctionNode]{.title-ref} object representing the parsed
    function.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_parameters">parse_parameters</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses function parameters, including their types, names, and
    optional semantic information.</li>
<li>Continues parsing until the closing parenthesis is encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A list of [VariableNode]{.title-ref} objects representing the
    function parameters.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_block">parse_block</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a block of statements enclosed in braces.</li>
<li>Collects and returns statements until the closing brace is
    encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A list of statements parsed from the block.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_statement">parse_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses different types of statements based on the current token.</li>
<li>Handles variable declarations or assignments, [if]{.title-ref}
    statements, [for]{.title-ref} loops, [return]{.title-ref}
    statements, and expressions.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A statement node representing the parsed statement.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_variable_declaration_or_assignment">parse_variable_declaration_or_assignment</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses variable declarations, assignments, and other related
    statements based on the current token.</li>
<li>Handles various scenarios including simple declarations,
    assignments with expressions, and compound assignments.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A node representing a variable declaration or assignment, or an
    expression statement if none of the previous conditions are met.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_if_statement">parse_if_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses an [if]{.title-ref} statement, including its condition,
    the body of the [if]{.title-ref} block, and optionally an
    [else]{.title-ref} or [else if]{.title-ref} block.</li>
<li>Handles nested [else if]{.title-ref} statements by delegating to
    [parse_else_if_statement]{.title-ref} if the next token is
    [ELSE_IF]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>An [IfNode]{.title-ref} representing the parsed [if]{.title-ref}
    statement, including its condition, [if]{.title-ref} block, and
    optional [else]{.title-ref} or [else if]{.title-ref} block.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_else_if_statement">parse_else_if_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses an [else if]{.title-ref} statement, including its
    condition, the body of the [else if]{.title-ref} block, and
    optionally an [else]{.title-ref} or another [else
    if]{.title-ref} block.</li>
<li>Handles nested [else if]{.title-ref} statements by calling
    [parse_else_if_statement]{.title-ref} recursively.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>An [IfNode]{.title-ref} representing the parsed [else
    if]{.title-ref} statement, including its condition, [else
    if]{.title-ref} block, and optional [else]{.title-ref} or nested
    [else if]{.title-ref} blocks.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>None</li>
</ul>
</li>
</ul>
<h2 id="parse_for_statement">parse_for_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a [for]{.title-ref} loop statement, including
    initialization, loop condition, update expression, and the loop
    body.</li>
<li>Handles initialization of variables or simple expressions.</li>
<li>Extracts and processes the condition and update expressions,
    along with the body of the loop.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [ForNode]{.title-ref} representing the parsed
    [for]{.title-ref} loop statement, including the initialization,
    condition, update expression, and body of the loop.</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>[SyntaxError]{.title-ref} if the [for]{.title-ref} statement's
    syntax is incorrect or missing required components.</li>
</ul>
</li>
</ul>
<h2 id="parse_return_statement">parse_return_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a [return]{.title-ref} statement.</li>
<li>Extracts the return value and ensures it is followed by a
    semicolon.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [ReturnNode]{.title-ref} containing the parsed return value.</li>
</ul>
</li>
</ul>
<h2 id="parse_expression_statement">parse_expression_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses a statement that consists of an expression followed by a
    semicolon.</li>
<li>Handles expressions that may be standalone or part of more
    complex statements.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>The parsed expression, which could be any valid expression node
    ([BinaryOpNode]{.title-ref}, [UnaryOpNode]{.title-ref},
    [FunctionCallNode]{.title-ref}, etc.).</li>
</ul>
</li>
</ul>
<h2 id="parse_expression">parse_expression</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses an expression that may involve assignment operators,
    ternary operations, and logical operations.</li>
<li>Handles assignment ([=]{.title-ref}, [+=]{.title-ref},
    [-=]{.title-ref}, [*=]{.title-ref}, [/=]{.title-ref}) and
    ternary ([condition ? true_expr : false_expr]{.title-ref})
    operators.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>The root node of the parsed expression, which could be an
    [AssignmentNode]{.title-ref}, [TernaryOpNode]{.title-ref}, or
    another type of expression node.</li>
</ul>
</li>
</ul>
<h2 id="parse_assignment">parse_assignment</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses an assignment expression, which can be a simple
    assignment or involve nested assignments.</li>
<li>Handles the assignment operator ([=]{.title-ref}) and
    recursively parses the right-hand side of the assignment.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>An [AssignmentNode]{.title-ref} representing the assignment
    operation, or the left-hand side expression if no assignment
    operator is found.</li>
</ul>
</li>
</ul>
<h2 id="parse_logical_or">parse_logical_or</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses logical OR expressions, handling multiple OR operations.</li>
<li>Constructs a binary operation node for each logical OR
    ([||]{.title-ref}) encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the logical OR
    operation, with nested binary operations for multiple OR
    expressions.</li>
</ul>
</li>
</ul>
<h2 id="parse_logical_and">parse_logical_and</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses logical AND expressions, handling multiple AND
    operations.</li>
<li>Constructs a binary operation node for each logical AND
    ([&amp;&amp;]{.title-ref}) encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the logical AND
    operation, with nested binary operations for multiple AND
    expressions.</li>
</ul>
</li>
</ul>
<h2 id="parse_equality">parse_equality</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses equality and inequality expressions, handling multiple
    equality checks.</li>
<li>Constructs a binary operation node for each equality
    ([==]{.title-ref}) or inequality ([!=]{.title-ref}) operation
    encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the equality or
    inequality operation, with nested binary operations for multiple
    equality checks.</li>
</ul>
</li>
</ul>
<h2 id="parse_relational">parse_relational</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses relational expressions, handling comparisons like less
    than ([\&lt;]{.title-ref}), greater than ([&gt;]{.title-ref}), less
    than or equal to ([\&lt;=]{.title-ref}), and greater than or equal
    to ([&gt;=]{.title-ref}).</li>
<li>Constructs a binary operation node for each relational operation
    encountered.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the relational
    operation, with nested binary operations for multiple
    comparisons.</li>
</ul>
</li>
</ul>
<h2 id="parse_additive">parse_additive</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses additive expressions, which involve addition
    ([+]{.title-ref}) and subtraction ([-]{.title-ref}).</li>
<li>Constructs a [BinaryOpNode]{.title-ref} for each additive
    operation, with nested binary operations for multiple additions
    or subtractions.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the additive
    operation, with nested binary operations for multiple additive
    expressions.</li>
</ul>
</li>
</ul>
<h2 id="parse_multiplicative">parse_multiplicative</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Parses multiplicative expressions, which include multiplication
    ([*]{.title-ref}) and division ([/]{.title-ref}).</li>
<li>Constructs a [BinaryOpNode]{.title-ref} for each multiplicative
    operation, handling nested expressions where multiple
    multiplicative operations are present.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [BinaryOpNode]{.title-ref} representing the multiplicative
    operation, including any nested operations.</li>
</ul>
</li>
</ul>
<h2 id="parse_unary">parse_unary</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>None (The [parse_unary]{.title-ref} function does not take any
    explicit parameters.)</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>The [parse_unary]{.title-ref} function is responsible for
    parsing unary expressions in a mathematical expression.</li>
<li>Unary expressions involve a single operand (e.g.,
    [-x]{.title-ref}, [+y]{.title-ref}), where the unary operator
    ([+]{.title-ref} or [-]{.title-ref}) is applied to the operand.</li>
<li>If the current token corresponds to a unary operator
    ([PLUS]{.title-ref} or [MINUS]{.title-ref}), the function
    processes it and recursively parses the operand.</li>
<li>Otherwise, it falls back to parsing the primary expression
    (e.g., literals, identifiers, function calls).</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [UnaryOpNode]{.title-ref} representing the unary operation,
    including any nested unary expressions.</li>
</ul>
</li>
</ul>
<h2 id="parse_primary">parse_primary</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>Handles the parsing of primary expressions in a mathematical
    expression.</li>
<li>Primary expressions include literals (e.g., integers, floats,
    vectors), identifiers (variable names), function calls, and
    parenthesized expressions (nested expressions within
    parentheses).</li>
<li>Examines the current token and determines the appropriate action
    based on the token type.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>The parsed expression (a [VariableNode]{.title-ref}, numeric
    value, function call, or parenthesized expression).</li>
</ul>
</li>
</ul>
<h2 id="parse_vector_constructor">parse_vector_constructor</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>`type_name`: The type of the vector being constructed (e.g.,
    "int", "float", "fvector").</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>The [parse_vector_constructor]{.title-ref} function handles the
    parsing of vector constructors.</li>
<li>Vector constructors are used to create vectors by specifying
    their components within parentheses (e.g., [(1, 2,
    3)]{.title-ref}).</li>
<li>The function iterates through the tokens until it encounters the
    closing parenthesis ([RPAREN]{.title-ref}).</li>
<li>It parses each expression (component) separated by commas and
    collects them in the [args]{.title-ref} list.</li>
<li>Finally, it constructs a [VectorConstructorNode]{.title-ref}
    with the specified type and the collected arguments.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [VectorConstructorNode]{.title-ref} representing the
    constructed vector.</li>
</ul>
</li>
</ul>
<h2 id="parse_function_call_or_identifier">parse_function_call_or_identifier</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>None (The [parse_function_call_or_identifier]{.title-ref}
    function does not take any explicit parameters.)</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>The [parse_function_call_or_identifier]{.title-ref} function
    handles the parsing of either a function call or an identifier
    (variable name).</li>
<li>It examines the current token:<ul>
<li>If the token corresponds to an [IDENTIFIER]{.title-ref}, it
    extracts the name and advances to the next token.</li>
<li>If the next token is an [LPAREN]{.title-ref}, it indicates a
    function call, and the function parses the arguments using
    [self.parse_function_call(name)]{.title-ref}.</li>
<li>If the next token is a [DOT]{.title-ref}, it indicates
    member access (e.g., accessing a method or property of an
    object) and parses it using
    [self.parse_member_access(name)]{.title-ref}.</li>
<li>Otherwise, it constructs a [VariableNode]{.title-ref} with
    an empty type and the extracted name.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>Either a function call node, a member access node, or a variable
    node, depending on the context.</li>
</ul>
</li>
</ul>
<h2 id="parse_function_call">parse_function_call</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>`name`: The name of the function being called.</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>The [parse_function_call]{.title-ref} function handles the
    parsing of function calls in an expression.</li>
<li>It starts by consuming the opening parenthesis token
    ([LPAREN]{.title-ref}).</li>
<li>While the current token is not the closing parenthesis token
    ([RPAREN]{.title-ref}), it continues to parse expressions
    (arguments) separated by commas.</li>
<li>Each argument is obtained by calling
    [self.parse_expression()]{.title-ref}.</li>
<li>If a comma follows an argument, it consumes the comma token.</li>
<li>Finally, it consumes the closing parenthesis token and
    constructs a [FunctionCallNode]{.title-ref} with the specified
    function name and arguments.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [FunctionCallNode]{.title-ref} representing the function call.</li>
</ul>
</li>
</ul>
<h2 id="parse_member_access">parse_member_access</h2>
<ul>
<li><strong>Parameters</strong>:<ul>
<li>`object`: The object (variable or expression) on which the
    member access is performed.</li>
</ul>
</li>
<li><strong>Description</strong>:<ul>
<li>The [parse_member_access]{.title-ref} function handles the
    parsing of member access in an expression.</li>
<li>It starts by consuming the dot token ([DOT]{.title-ref}).</li>
<li>If the next token is not an [IDENTIFIER]{.title-ref}, it raises
    a [SyntaxError]{.title-ref}.</li>
<li>Otherwise, it extracts the member name and advances to the next
    token.</li>
<li>If there's another dot after this member access, it recursively
    calls itself with the updated [MemberAccessNode]{.title-ref}.</li>
<li>Otherwise, it constructs a [MemberAccessNode]{.title-ref} with
    the specified object and member.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>A [MemberAccessNode]{.title-ref} representing the member access.</li>
</ul>
</li>
</ul>
<h1 id="directx-codegen">DirectX Codegen</h1>
<p>The HLSLCodeGen class within the CrossGL framework is pivotal in
translating CrossGL shader abstract syntax trees (AST) into CrossGL
code, which is essential for DirectX applications. This class
systematically converts the AST (representing the logical structure of a
shader)---&gt;into corresponding CrossGL code that can be executed.</p>
<p>Methods</p>
<hr />
<p>Initializes the code generator.</p>
<h2 id="generate">generate</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates shader code from the given Abstract Syntax Tree (AST).</li>
<li>Handles the creation of both vertex and fragment shaders,
    including custom functions and shader-specific I/O declarations.</li>
</ul>
</li>
<li><strong>Steps</strong>:<ol>
<li><strong>Process Structs</strong>:<ul>
<li>Calls [process_structs]{.title-ref} to handle any structures
    defined in the AST.</li>
</ul>
</li>
<li><strong>Initialize Shader Code</strong>:<ul>
<li>Starts with the base shader declaration line: [shader main
    {n]{.title-ref}.</li>
</ul>
</li>
<li><strong>Generate Custom Functions</strong>:<ul>
<li>Iterates through the functions in the AST, excluding the
    main vertex and fragment functions ([VSMain]{.title-ref} and
    [PSMain]{.title-ref}).</li>
<li>Appends the generated code for each custom function.</li>
</ul>
</li>
<li><strong>Generate Vertex Shader</strong>:<ul>
<li>Adds a section comment for the vertex shader.</li>
<li>Includes vertex shader I/O declarations by calling
    [generate_io_declarations]{.title-ref} with
    [\"vertex\"]{.title-ref}.</li>
<li>Adds the main function for the vertex shader using
    [generate_vertex_main]{.title-ref}, fetching the function
    named [VSMain]{.title-ref}.</li>
</ul>
</li>
<li><strong>Generate Fragment Shader</strong>:<ul>
<li>Adds a section comment for the fragment shader.</li>
<li>Includes fragment shader I/O declarations by calling
    [generate_io_declarations]{.title-ref} with
    [\"fragment\"]{.title-ref}.</li>
<li>Adds the main function for the fragment shader using
    [generate_fragment_main]{.title-ref}, fetching the function
    named [PSMain]{.title-ref}.</li>
</ul>
</li>
<li><strong>Finalize Shader Code</strong>:<ul>
<li>Closes the shader block with [}n]{.title-ref}.</li>
</ul>
</li>
</ol>
</li>
<li><strong>Returns</strong>:<ul>
<li>The complete shader code as a string.</li>
</ul>
</li>
</ul>
<h2 id="process_structs">process_structs</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Processes structure definitions from the Abstract Syntax Tree
    (AST) and populates lists of vertex and fragment shader inputs
    and outputs based on the members of the provided structures.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[ast]{.title-ref} ([ShaderNode]{.title-ref}): An instance of
    [ShaderNode]{.title-ref} containing structure definitions and
    functions for vertex and fragment shaders. This includes
    optional vertex input ([vsinput_struct]{.title-ref}), vertex
    output ([vsoutput_struct]{.title-ref}), fragment input
    ([psinput_struct]{.title-ref}), and fragment output
    ([psoutput_struct]{.title-ref}) structures.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`None`: This method updates instance variables
    ([self.vertex_inputs]{.title-ref},
    [self.vertex_outputs]{.title-ref},
    [self.fragment_inputs]{.title-ref}, and
    [self.fragment_outputs]{.title-ref}) directly based on the
    structure members in the provided [ast]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="generate_io_declarations">generate_io_declarations</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates shader I/O declarations based on the specified shader
    type (vertex or fragment). It creates declarations for input and
    output variables in the shader code.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[shader_type]{.title-ref} ([str]{.title-ref}): Specifies the
    type of shader for which to generate I/O declarations. It can be
    [\"vertex\"]{.title-ref} or [\"fragment\"]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted I/O declarations for
    the specified shader type. The string includes
    [input]{.title-ref} and [output]{.title-ref} statements with
    appropriate types and names, formatted according to the shader's
    requirements. The string is stripped of any trailing whitespace.</li>
</ul>
</li>
</ul>
<h2 id="generate_function">generate_function</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates the code for a function based on the provided
    [FunctionNode]{.title-ref}. This includes defining the
    function's return type, name, parameters, and body.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function
    node containing the details of the function to be generated. It
    includes the return type, function name, parameters, and body.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the
    function. This includes the function signature and body,
    properly indented and formatted.</li>
</ul>
</li>
</ul>
<h2 id="generate_vertex_main">generate_vertex_main</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates the main function for the vertex shader, which is
    typically the entry point of the shader. It formats and includes
    the function body with appropriate indentation.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function
    node representing the vertex shader's main function. It contains
    the body of the function that will be used to generate the
    shader code.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the vertex
    shader's [main]{.title-ref} function, including proper
    indentation and the function body.</li>
</ul>
</li>
</ul>
<h2 id="generate_fragment_main">generate_fragment_main</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates the main function for the fragment shader, which is
    typically the entry point of the shader. It formats and includes
    the function body with appropriate indentation.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function
    node representing the fragment shader's main function. It
    contains the body of the function that will be used to generate
    the shader code.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the fragment
    shader's [main]{.title-ref} function, including proper
    indentation and the function body.</li>
</ul>
</li>
</ul>
<h2 id="generate_function_body">generate_function_body</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates the code for the body of a function by iterating
    through statements. It formats each statement based on its type
    and includes the appropriate indentation.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[body]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of
    statements in the function body, where each statement is an
    instance of [ASTNode]{.title-ref} or its derived classes.</li>
<li>[indent]{.title-ref} ([int]{.title-ref}): The level of
    indentation to apply to each line of code. Default is
    [0]{.title-ref}.</li>
<li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating
    whether the function being generated is the [main]{.title-ref}
    function. Default is [False]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the function
    body, including the appropriate indentation and formatted
    statements.</li>
</ul>
</li>
</ul>
<h2 id="generate_for_loop">generate_for_loop</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates code for a [for]{.title-ref} loop based on the
    provided [ForNode]{.title-ref}. This includes formatting the
    initialization, condition, and update expressions, and properly
    indenting the loop body.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[node]{.title-ref} ([ForNode]{.title-ref}): An instance of
    [ForNode]{.title-ref} representing the [for]{.title-ref} loop,
    containing [init]{.title-ref}, [condition]{.title-ref},
    [update]{.title-ref}, and [body]{.title-ref}.</li>
<li>[indent]{.title-ref} ([int]{.title-ref}): The level of
    indentation to apply to each line of the loop code. It controls
    how deep the code will be indented. Default is [0]{.title-ref}.</li>
<li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating
    whether the loop is inside the [main]{.title-ref} function.
    Default is [False]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the
    [for]{.title-ref} loop, including the initialization, condition,
    update, and the body of the loop with proper indentation.</li>
</ul>
</li>
</ul>
<h2 id="generate_if_statement">generate_if_statement</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates code for an [if]{.title-ref} statement, including
    handling [else]{.title-ref} and [else if]{.title-ref} branches.
    The code is properly indented according to the provided level.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[node]{.title-ref} ([IfNode]{.title-ref}): An instance of
    [IfNode]{.title-ref} representing the [if]{.title-ref}
    statement, including the condition, [if_body]{.title-ref}, and
    [else_body]{.title-ref}.</li>
<li>[indent]{.title-ref} ([int]{.title-ref}): The level of
    indentation to apply to each line of the [if]{.title-ref}
    statement code. Default is [0]{.title-ref}.</li>
<li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating
    whether the [if]{.title-ref} statement is inside the
    [main]{.title-ref} function. Default is [False]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the
    [if]{.title-ref} statement, including the condition, body, and
    optional [else]{.title-ref} or [else if]{.title-ref} blocks with
    proper indentation.</li>
</ul>
</li>
</ul>
<h2 id="generate_assignment">generate_assignment</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates code for an assignment operation. Special handling is
    included for assignments where the left-hand side is a member of
    [output]{.title-ref} when in the [main]{.title-ref} function.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[node]{.title-ref} ([AssignmentNode]{.title-ref}): An instance
    of [AssignmentNode]{.title-ref} representing the assignment
    operation, including the left-hand side
    ([node.left]{.title-ref}) and right-hand side
    ([node.right]{.title-ref}) expressions.</li>
<li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating
    whether the code is being generated inside the
    [main]{.title-ref} function. Default is [False]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the
    assignment. Special handling for output variables if
    [is_main]{.title-ref} is [True]{.title-ref}, translating
    [position]{.title-ref} to [gl_Position]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="generate_expression">generate_expression</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Generates code for various types of expressions. Handles
    different node types such as variables, binary operations,
    assignments, unary operations, function calls, member accesses,
    ternary operations, and vector constructors.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[expr]{.title-ref} ([ExpressionNode]{.title-ref}): The
    expression to generate code for, which can be a node of various
    types (e.g., [VariableNode]{.title-ref},
    [BinaryOpNode]{.title-ref}, etc.).</li>
<li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating
    whether the code is being generated inside the
    [main]{.title-ref} function. Default is [False]{.title-ref}.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: A string containing the formatted code for the
    expression, appropriately handling different node types.</li>
</ul>
</li>
</ul>
<h2 id="map_type">map_type</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Maps an HLSL type to its corresponding type in the shader
    language used by the generator. Utilizes a dictionary
    ([type_map]{.title-ref}) for type conversion.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>[hlsl_type]{.title-ref} ([str]{.title-ref}): The HLSL type
    string that needs to be mapped.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>`str`: The mapped type string based on the
    [type_map]{.title-ref} dictionary. If the type is not found in
    the dictionary, it returns the original [hlsl_type]{.title-ref}.</li>
</ul>
</li>
</ul>
<h1 id="metal">Metal</h1>
<h1 id="metal-ast">Metal AST</h1>
<h2 id="ternaryopnode_1">TernaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a ternary conditional operation in the abstract
    syntax tree (AST). It contains a condition, a true expression,
    and a false expression.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The condition
    to be evaluated.</li>
<li>[true_expr]{.title-ref} ([ASTNode]{.title-ref}): The expression
    to be evaluated and returned if the condition is true.</li>
<li>[false_expr]{.title-ref} ([ASTNode]{.title-ref}): The expression
    to be evaluated and returned if the condition is false.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [TernaryOpNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node with its condition, true expression, and false
    expression.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="shadernode_1">ShaderNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a shader node in the abstract syntax tree (AST) for a
    shader. This node contains the functions defined in the shader.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[functions]{.title-ref} ([List[FunctionNode]]{.title-ref}): A
    list of [FunctionNode]{.title-ref} instances representing the
    functions defined in the shader.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ShaderNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node with its functions.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="structnode">StructNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a struct definition in the abstract syntax tree (AST)
    for a shader. This node contains the name of the struct and its
    member variables.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[name]{.title-ref} ([str]{.title-ref}): The name of the struct.</li>
<li>[members]{.title-ref} ([List[VariableNode]]{.title-ref}): A
    list of [VariableNode]{.title-ref} instances representing the
    members of the struct.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [StructNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node with its name and members.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="functionnode_1">FunctionNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a function definition in the abstract syntax tree
    (AST). This node includes details about the function's
    qualifier, return type, name, parameters, body, and any
    associated attributes.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[qualifier]{.title-ref} ([str]{.title-ref}): The qualifier of
    the function (e.g., [public]{.title-ref},
    [private]{.title-ref}).</li>
<li>[return_type]{.title-ref} ([str]{.title-ref}): The return type
    of the function.</li>
<li>[name]{.title-ref} ([str]{.title-ref}): The name of the
    function.</li>
<li>[params]{.title-ref} ([List[VariableNode]]{.title-ref}): A
    list of [VariableNode]{.title-ref} instances representing the
    function's parameters.</li>
<li>[body]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of
    [ASTNode]{.title-ref} instances representing the body of the
    function.</li>
<li>[attributes]{.title-ref} ([List[str]]{.title-ref}, optional):
    A list of string attributes associated with the function.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [FunctionNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its qualifier, return type, name,
    parameters, body, and attributes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="arrayaccessnode">ArrayAccessNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an array access operation in the abstract syntax tree
    (AST). This node contains details about the array being accessed
    and the index used to access an element within the array.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[array]{.title-ref} ([ASTNode]{.title-ref}): The array being
    accessed.</li>
<li>[index]{.title-ref} ([ASTNode]{.title-ref}): The index used to
    access an element in the array.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ArrayAccessNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its array and index.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="variablenode_1">VariableNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a variable declaration in the abstract syntax tree
    (AST). This node contains information about the variable's type,
    its name, and any additional attributes associated with the
    variable.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[vtype]{.title-ref} ([str]{.title-ref}): The type of the
    variable (e.g., [int]{.title-ref}, [float]{.title-ref},
    [vec3]{.title-ref}).</li>
<li>[name]{.title-ref} ([str]{.title-ref}): The name of the
    variable.</li>
<li>[attributes]{.title-ref} ([list]{.title-ref}, optional):
    Additional attributes or qualifiers associated with the
    variable. Defaults to an empty list if not provided.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [VariableNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its type, name, and attributes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="attributenode">AttributeNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an attribute or decoration associated with a
    function, variable, or other elements in the abstract syntax
    tree (AST). This node includes the name of the attribute and any
    associated arguments.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[name]{.title-ref} ([str]{.title-ref}): The name of the
    attribute (e.g., [location]{.title-ref}, [binding]{.title-ref}).</li>
<li>[args]{.title-ref} ([list]{.title-ref}, optional): A list of
    arguments or parameters associated with the attribute. Defaults
    to an empty list if not provided.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [AttributeNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its name and arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="assignmentnode_1">AssignmentNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an assignment operation in the abstract syntax tree
    (AST). This node holds the left-hand side (LHS) variable or
    expression, the right-hand side (RHS) value or expression, and
    the operator used for assignment.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[left]{.title-ref} ([ASTNode]{.title-ref}): The variable or
    expression on the left side of the assignment.</li>
<li>[right]{.title-ref} ([ASTNode]{.title-ref}): The value or
    expression to be assigned to the left side.</li>
<li>[operator]{.title-ref} ([str]{.title-ref}, optional): The
    assignment operator (e.g., [=]{.title-ref}, [+=]{.title-ref},
    [-=]{.title-ref}, etc.). Defaults to [\"=\"]{.title-ref}.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [AssignmentNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its left side, operator, and right side.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ifnode_1">IfNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents an [if]{.title-ref} statement in the abstract syntax
    tree (AST). This node encapsulates the condition of the
    [if]{.title-ref} statement and its associated [if]{.title-ref}
    and [else]{.title-ref} bodies.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The condition
    expression that determines whether the [if]{.title-ref} body or
    [else]{.title-ref} body should be executed.</li>
<li>[if_body]{.title-ref} ([list]{.title-ref} of
    [ASTNode]{.title-ref}): The statements to be executed if the
    condition evaluates to [True]{.title-ref}.</li>
<li>[else_body]{.title-ref} ([list]{.title-ref} of
    [ASTNode]{.title-ref}, optional): The statements to be executed
    if the condition evaluates to [False]{.title-ref}. Defaults to
    [None]{.title-ref}.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [IfNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its condition, [if]{.title-ref} body,
    and [else]{.title-ref} body.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fornode_1">ForNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a [for]{.title-ref} loop in the abstract syntax tree
    (AST). This node captures the initialization, loop condition,
    update expression, and the body of the loop.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[init]{.title-ref} ([ASTNode]{.title-ref}): The initialization
    statement for the [for]{.title-ref} loop, such as setting up a
    loop variable.</li>
<li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The loop
    condition that determines whether the loop should continue
    running.</li>
<li>[update]{.title-ref} ([ASTNode]{.title-ref}): The update
    expression to be evaluated at the end of each loop iteration,
    such as incrementing a loop variable.</li>
<li>[body]{.title-ref} ([list]{.title-ref} of
    [ASTNode]{.title-ref}): The statements to be executed on each
    iteration of the loop.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ForNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including its initialization, condition, update,
    and body.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="returnnode_1">ReturnNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a [return]{.title-ref} statement in the abstract
    syntax tree (AST). This node captures the value that is to be
    returned from a function.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[value]{.title-ref} ([ASTNode]{.title-ref}): The expression or
    value to be returned by the function.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ReturnNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the value being returned.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="functioncallnode_1">FunctionCallNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a function call in the abstract syntax tree (AST).
    This node contains information about the function being called
    and the arguments passed to it.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[name]{.title-ref} ([str]{.title-ref}): The name of the function
    being called.</li>
<li>[args]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of
    arguments passed to the function call. Each argument is an
    [ASTNode]{.title-ref}.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [FunctionCallNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the function name and its arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="binaryopnode_1">BinaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a binary operation in the abstract syntax tree (AST).
    This node is used for operations involving two operands and an
    operator, such as addition, subtraction, multiplication, etc.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[left]{.title-ref} ([ASTNode]{.title-ref}): The left operand of
    the binary operation.</li>
<li>[op]{.title-ref} ([str]{.title-ref}): The operator used in the
    operation (e.g., [+]{.title-ref}, [-]{.title-ref},
    [*]{.title-ref}, [/]{.title-ref}).</li>
<li>[right]{.title-ref} ([ASTNode]{.title-ref}): The right operand
    of the binary operation.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [BinaryOpNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the left operand, operator, and right
    operand.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="memberaccessnode_1">MemberAccessNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents access to a member of an object in the abstract
    syntax tree (AST). This node is used to refer to a property or
    method of an object.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[object]{.title-ref} ([ASTNode]{.title-ref}): The object or
    variable whose member is being accessed.</li>
<li>[member]{.title-ref} ([str]{.title-ref}): The name of the member
    being accessed (e.g., a property or method).</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [MemberAccessNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the object and the member being
    accessed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="vectorconstructornode_1">VectorConstructorNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a vector constructor in the abstract syntax tree
    (AST). This node is used to construct vector types by specifying
    the type and the components of the vector.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[type_name]{.title-ref} ([str]{.title-ref}): The name of the
    vector type being constructed (e.g., [vec3]{.title-ref},
    [vec4]{.title-ref}).</li>
<li>[args]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of
    expressions representing the components of the vector.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [VectorConstructorNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the vector type and its components.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="unaryopnode_1">UnaryOpNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a unary operation in the abstract syntax tree (AST).
    This node is used to model operations that apply to a single
    operand, such as negation or increment.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[op]{.title-ref} ([str]{.title-ref}): The operator for the unary
    operation (e.g., [+]{.title-ref}, [-]{.title-ref},
    [++]{.title-ref}, [--]{.title-ref}).</li>
<li>[operand]{.title-ref} ([ASTNode]{.title-ref}): The operand on
    which the unary operation is applied.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [UnaryOpNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the unary operator and its operand.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="texturesamplenode">TextureSampleNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a texture sampling operation in the abstract syntax
    tree (AST). This node is used to model operations where a
    texture is sampled using specified coordinates and a sampler.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>[texture]{.title-ref} ([str]{.title-ref}): The name or reference
    to the texture being sampled.</li>
<li>[sampler]{.title-ref} ([str]{.title-ref}): The name or reference
    to the sampler used for sampling the texture.</li>
<li>[coordinates]{.title-ref} ([ASTNode]{.title-ref}): The
    coordinates used to sample the texture, typically represented as
    a vector.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [TextureSampleNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string representation of
    the node, including the texture, sampler, and coordinates
    used for sampling.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="threadgroupsyncnode">ThreadgroupSyncNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a synchronization point for thread groups in the
    abstract syntax tree (AST). This node is used to synchronize the
    execution of threads within a thread group.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li>No parameters are needed for this class.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ThreadgroupSyncNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A string indicating that
    the node is a synchronization point for thread groups.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="constantbuffernode">ConstantBufferNode</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Represents a constant buffer in the abstract syntax tree (AST).
    Constant buffers are used to group and manage constants that are
    passed to shaders.</li>
</ul>
</li>
<li><strong>Constructor Parameters</strong>:<ul>
<li><strong>`name`</strong> ([str]{.title-ref}): The name of the constant
    buffer.</li>
<li><strong>`members`</strong> ([list]{.title-ref} of
    [VariableNode]{.title-ref}): A list of members (variables)
    within the constant buffer.</li>
</ul>
</li>
<li><strong>Methods</strong>:<ul>
<li><strong>__repr__</strong>:<ul>
<li><strong>Description</strong>: Returns a string representation of the
    [ConstantBufferNode]{.title-ref} instance.</li>
<li><strong>Returns</strong>: [str]{.title-ref} - A formatted string that
    includes the name and members of the constant buffer.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="metal-lexer">Metal Lexer</h1>
<p>[TOKENS]{.title-ref} and [KEYWORDS]{.title-ref} definitions provide a
comprehensive set of token patterns for parsing a shader language,
potentially for HLSL, GLSL, or a similar language. Here's a brief
overview of what each part does:</p>
<h2 id="tokens-list">TOKENS List</h2>
<p>The [TOKENS]{.title-ref} list defines regex patterns for different types
of tokens. Each token has a name and a regex pattern to match it.</p>
<ul>
<li><strong>Comment Tokens</strong>:<ul>
<li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with
    [//]{.title-ref}.</li>
<li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed in
    [/*]{.title-ref} and [*/]{.title-ref}.</li>
</ul>
</li>
<li><strong>Shader and Language Constructs</strong>:<ul>
<li><code>STRUCT</code>, <code>CONSTANT</code>, <code>TEXTURE2D</code>, <code>SAMPLER</code>: Keywords for
    specific constructs or types.</li>
<li><code>VECTOR</code>, <code>FLOAT</code>, <code>HALF</code>, <code>INT</code>, <code>UINT</code>, <code>BOOL</code>, <code>VOID</code>: Data
    types.</li>
<li><code>QUESTION</code>, <code>IF</code>, <code>ELSE</code>, <code>FOR</code>, <code>RETURN</code>: Common control flow
    and function keywords.</li>
<li><code>VERTEX</code>, <code>FRAGMENT</code>: Shader stages.</li>
<li><code>USING</code>, <code>NAMESPACE</code>, <code>METAL</code>, <code>DEVICE</code>, <code>THREADGROUP</code>,
    <code>THREAD</code>: Specific to certain shading languages or extensions.</li>
</ul>
</li>
<li><strong>Syntax Elements</strong>:<ul>
<li><code>IDENTIFIER</code>: Matches variable and function names.</li>
<li><code>NUMBER</code>: Matches numeric literals.</li>
<li><code>STRING</code>: Matches string literals.</li>
<li><code>LBRACE</code>, <code>RBRACE</code>, <code>LPAREN</code>, <code>RPAREN</code>, <code>LBRACKET</code>, <code>RBRACKET</code>,
    <code>SEMICOLON</code>, <code>COMMA</code>, <code>COLON</code>: Various syntax symbols.</li>
<li><code>LESS_EQUAL</code>, <code>GREATER_EQUAL</code>, <code>LESS_THAN</code>, <code>GREATER_THAN</code>,
    <code>EQUAL</code>, <code>NOT_EQUAL</code>: Comparison operators.</li>
<li><code>PLUS_EQUALS</code>, <code>MINUS_EQUALS</code>, <code>MULTIPLY_EQUALS</code>,
    <code>DIVIDE_EQUALS</code>: Compound assignment operators.</li>
<li><code>PLUS</code>, <code>MINU`S`,</code>MULTIPLY<code>,</code>DIVIDE``: Arithmetic
    operators.</li>
<li><code>AND</code>, <code>OR</code>: Logical operators.</li>
<li><code>DOT</code>: Member access operator.</li>
<li><code>EQUALS</code>: Assignment operator.</li>
<li><code>WHITESPACE</code>`: Matches spaces, tabs, and newlines.</li>
</ul>
</li>
</ul>
<h2 id="keywords-dictionary_1">KEYWORDS Dictionary</h2>
<p>The [KEYWORDS]{.title-ref} dictionary maps specific keywords to their
corresponding token types. This helps in recognizing and categorizing
keywords during parsing.</p>
<ul>
<li><strong>Shader and Language Keywords</strong>:<ul>
<li>Maps shader and language-specific keywords to their token type
    names defined in [TOKENS]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="methods_6">Methods</h2>
<p>::: {#init__self-1}</p>
<hr />
<p>:::</p>
<p>Initializes the code generator.</p>
<h2 id="tokenizeself">tokenize(self)</h2>
<p>| <strong>Description:</strong>
| Tokenizes the input code into a sequence of tokens by matching against
  predefined patterns.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - None</p>
<p>| <strong>Raises:</strong>
| - `SyntaxError`: If an illegal character is encountered in the input
  code.</p>
<h1 id="metal-parser">Metal Parser</h1>
<h2 id="methods-1">Methods</h2>
<p>::: {#init__self-2}</p>
<hr />
<p>:::</p>
<p>Initializes the code generator.</p>
<h2 id="eat_1">eat</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Consumes the current token if it matches the expected type.</li>
<li>Advances to the next token and skips any comments following the
    current token.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>`token_type`: The type of token expected to be consumed.</li>
</ul>
</li>
<li><strong>Returns</strong>: None</li>
<li><strong>Raises</strong>:<ul>
<li>`SyntaxError`: If the current token does not match the
    expected token type.</li>
</ul>
</li>
</ul>
<h2 id="skip_commentsself">skip_comments(self)</h2>
<p>| <strong>Description:</strong>
| Skips over single-line and multi-line comments in the token stream by
  advancing past them.</p>
<p>| <strong>Parameters:</strong> None</p>
<p>| <strong>Returns:</strong> None</p>
<p>| <strong>Raises:</strong> None</p>
<h2 id="parseself">parse(self)</h2>
<p>| <strong>Description:</strong>
| Initiates the parsing process by calling parse_shader to generate the
  Abstract Syntax Tree (AST) for the shader code. Ensures that the
  entire input has been consumed by checking for the end of file
  ([EOF]{.title-ref}).</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The root node of the parsed Abstract Syntax Tree
        (AST) representing the shader.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there is any remaining unparsed input after
        the shader has been parsed.</p>
<h2 id="parse_shaderself">parse_shader(self)</h2>
<p>| <strong>Description:</strong>
| Parses the shader code by sequentially identifying and processing
  various components such as preprocessor directives,
  [using]{.title-ref} statements, structs, constant buffers, and
  functions. The method iterates through the tokens until it reaches the
  end of the file ([EOF]{.title-ref}), constructing a list of functions
  and other shader components.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ShaderNode`: A node representing the parsed shader,
        containing all the functions and components.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the shader contains unrecognized tokens that
        cannot be skipped or parsed.</p>
<h2 id="parse_preprocessor_directiveself">parse_preprocessor_directive(self)</h2>
<p>| <strong>Description:</strong>
| Parses a preprocessor directive from the shader code. It handles
  directives that include a string or are enclosed within angle brackets
  ([\&lt; &gt;]{.title-ref}). The method consumes tokens associated with the
  directive until it reaches the end of the directive.</p>
<p>| <strong>Parameters:</strong> None</p>
<p>| <strong>Returns:</strong> None</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the preprocessor directive is not properly
        closed with a [GREATER_THAN]{.title-ref} token.</p>
<h2 id="parse_using_statementself">parse_using_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses a [using]{.title-ref} statement specifically for the [namespace
  metal;]{.title-ref} declaration in the shader code. This method
  consumes the relevant tokens for [using]{.title-ref},
  [namespace]{.title-ref}, [metal]{.title-ref}, and the terminating
  semicolon ([;]{.title-ref}).</p>
<p>| <strong>Parameters:</strong> None</p>
<p>| <strong>Returns:</strong> None</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If any of the expected tokens
        ([USING]{.title-ref}, [NAMESPACE]{.title-ref},
        [METAL]{.title-ref}, or [SEMICOLON]{.title-ref}) are not found
        in sequence.</p>
<h2 id="parse_structself">parse_struct(self)</h2>
<p>| <strong>Description:</strong>
| Parses a [struct]{.title-ref} declaration in the shader code. This
  method reads the structure's name, its member variables, and any
  associated attributes.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `StructNode`: A node representing the structure, including its
        name and members.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If any of the expected tokens
        ([STRUCT]{.title-ref}, [IDENTIFIER]{.title-ref},
        [LBRACE]{.title-ref}, [RBRACE]{.title-ref},
        [SEMICOLON]{.title-ref}) are not found in sequence.</p>
<h2 id="parse_constant_bufferself">parse_constant_buffer(self)</h2>
<p>| <strong>Description:</strong>
| Parses a [constant]{.title-ref} buffer declaration in the shader code.
  This method reads the buffer's name and its member variables.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ConstantBufferNode`: A node representing the constant buffer,
        including its name and members.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If any of the expected tokens
        ([CONSTANT]{.title-ref}, [IDENTIFIER]{.title-ref},
        [LBRACE]{.title-ref}, [RBRACE]{.title-ref},
        [SEMICOLON]{.title-ref}) are not found in sequence.</p>
<h2 id="parse_functionself">parse_function(self)</h2>
<p>| <strong>Description:</strong>
| Parses a function declaration in the shader code, including function
  qualifiers, return type, parameters, and body. Handles function
  attributes before and after the parameters.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `FunctionNode`: A node representing the function, including
        its qualifier, return type, name, parameters, body, and
        attributes.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If any of the expected tokens
        ([VERTEX]{.title-ref}, [FRAGMENT]{.title-ref},
        [KERNEL]{.title-ref}, [IDENTIFIER]{.title-ref},
        [LPAREN]{.title-ref}, [RPAREN]{.title-ref},
        [LBRACE]{.title-ref}, [RBRACE]{.title-ref}, etc.) are not found
        in sequence.</p>
<h2 id="parse_parametersself">parse_parameters(self)</h2>
<p>| <strong>Description:</strong>
| Parses the parameter list for a function, including handling
  attributes, types, optional template parameters, and names. It
  continues parsing until it encounters a closing parenthesis.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `List[VariableNode][: A list of `VariableNode]{.title-ref}
        instances representing each parameter with its type, name, and
        attributes.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: - If an unexpected token is encountered in the
        parameter list. - If a token that is neither a comma nor a
        closing parenthesis is found when expected.</p>
<h2 id="parse_attributesself">parse_attributes(self)</h2>
<p>| <strong>Description:</strong>
| Parses a sequence of attributes from the token stream. Attributes are
  enclosed in [[[ ]]]{.title-ref}, and this method extracts the
  attribute name and its arguments.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `List[AttributeNode][: A list of `AttributeNode]{.title-ref}
        instances representing the parsed attributes, including their
        names and arguments.</p>
<p>| <strong>Raises:</strong> [None]{.title-ref}</p>
<h2 id="parse_blockself">parse_block(self)</h2>
<p>| <strong>Description:</strong>
| Parses a block of statements enclosed in curly braces
  [{}]{.title-ref}. This method collects statements within the block
  until it encounters the closing brace [}]{.title-ref}.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `List[ASTNode][: A list of statements parsed from the block,
        where each statement is represented as an
        `ASTNode]{.title-ref}.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the closing brace [RBRACE]{.title-ref} is
        not found, indicating a mismatch or incomplete block.</p>
<h2 id="parse_statementself">parse_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses a statement based on the current token type. This method
  determines the type of statement and delegates the parsing to the
  appropriate handler method, such as variable declarations, conditional
  statements, loops, or expressions.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed statement represented as an
        [ASTNode]{.title-ref}. The specific type of
        [ASTNode]{.title-ref} depends on the statement type, such as
        [VariableDeclarationNode]{.title-ref}, [IfNode]{.title-ref},
        [ForNode]{.title-ref}, [ReturnNode]{.title-ref}, or
        [ExpressionStatementNode]{.title-ref}.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the current token does not match any known
        statement types or if there is an issue parsing the statement.</p>
<h2 id="parse_variable_declaration_or_assignmentself">parse_variable_declaration_or_assignment(self)</h2>
<p>| <strong>Description:</strong>
| Parses a variable declaration or assignment statement. This method
  handles different cases including variable declarations with or
  without initialization, assignments, and compound assignments. It also
  deals with member accesses and operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed statement represented as an
        [ASTNode]{.title-ref}.This could be a
        [VariableNode]{.title-ref}, [AssignmentNode]{.title-ref},
        [BinaryOpNode]{.title-ref}, or a general expression node,
        depending on the syntax of the statement.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the variable declaration or
        assignment does not match the expected format, or if there are
        issues parsing the expression.</p>
<h2 id="parse_if_statementself">parse_if_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses an [if]{.title-ref} statement. This method handles the syntax
  of an [if]{.title-ref} statement including the condition and both the
  [if]{.title-ref} and optional [else]{.title-ref} blocks.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `IfNode`: An AST node representing the [if]{.title-ref}
        statement.
    -   This node contains:
        -   The [condition]{.title-ref} as an expression.
        -   The [if_body]{.title-ref} as a block of statements executed
            if the condition is true.
        -   The [else_body]{.title-ref} as a block of statements
            executed if the condition is false (or [None]{.title-ref} if
            there is no [else]{.title-ref} block).</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the [if]{.title-ref} statement
        is incorrect or if there are issues parsing the expression or
        blocks</p>
<h2 id="parse_for_statementself">parse_for_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses a [for]{.title-ref} loop statement. This method handles the
  initialization, condition, and update expressions of the
  [for]{.title-ref} loop, as well as the body of the loop.</p>
<p><strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ForNode`: An AST node representing the [for]{.title-ref} loop
        statement.
    -   This node contains:
        -   `init`: The initialization expression or statement (e.g.,
            variable declaration and assignment).
        -   `condition`: The condition expression that controls the
            loop's continuation.
        -   `update`: The update expression executed after each
            iteration of the loop.
        -   `body`: The block of statements executed in each iteration
            of the loop.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there are issues with the syntax of the
        [for]{.title-ref} statement or problems parsing the expressions
        or block.</p>
<h2 id="parse_return_statementself">parse_return_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses a [return]{.title-ref} statement. This method retrieves the
  expression that is returned from a function and ensures proper syntax
  with a terminating semicolon.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ReturnNode`: An AST node representing the
        [return]{.title-ref} statement.This node contains: - `value`:
        The expression to be returned by the function.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there are issues with the syntax of the
        [return]{.title-ref} statement or problems parsing the
        expression.</p>
<h2 id="parse_expression_statementself">parse_expression_statement(self)</h2>
<p>| <strong>Description:</strong>
| Parses an expression statement. This method handles any general
  expressions followed by a semicolon, treating them as statements.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed expression, which can be any type of
        expression node (e.g., [BinaryOpNode]{.title-ref},
        [FunctionCallNode]{.title-ref}, etc.).</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there are issues with the syntax of the
        expression or if the semicolon is missing.</p>
<h2 id="parse_expressionself">parse_expression(self)</h2>
<p>| <strong>Description:</strong>
| Parses an expression by delegating to the
  [parse_assignment]{.title-ref} method. This method serves as the entry
  point for parsing expressions, handling the overall expression parsing
  process.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed assignment expression or any other
        expression node resulting from the
        [parse_assignment]{.title-ref} method.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there are issues with the syntax of the
        assignment or any sub-expressions.</p>
<h2 id="parse_assignmentself">parse_assignment(self)</h2>
<p>| <strong>Description:</strong>
| Parses an assignment expression. This method first parses the
  left-hand side of the assignment using
  [parse_logical_or()]{.title-ref}. It then checks for assignment
  operators ([EQUALS]{.title-ref}, [PLUS_EQUALS]{.title-ref},
  [MINUS_EQUALS]{.title-ref}, [MULTIPLY_EQUALS]{.title-ref},
  [DIVIDE_EQUALS]{.title-ref}) and parses the right-hand side
  expression. Additionally, it handles ternary conditional expressions
  if a [QUESTION]{.title-ref} token is encountered.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed assignment expression, which could be an
        [AssignmentNode]{.title-ref} or a [TernaryOpNode]{.title-ref}
        depending on the presence of conditional operators.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If there are issues with the syntax of the
        assignment or ternary expressions.</p>
<h2 id="parse_logical_orself">parse_logical_or(self)</h2>
<p>| <strong>Description:</strong>
| Parses a logical OR expression. This method first parses the left-hand
  side of the expression using [parse_logical_and()]{.title-ref}. It
  then processes any subsequent logical OR operators, parsing the
  right-hand side of each OR operation and combining the results into a
  [BinaryOpNode]{.title-ref} representing the logical OR operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed logical OR expression, which is
        represented as a [BinaryOpNode]{.title-ref} if there are
        multiple OR operations, or a single expression if there is no OR
        operation.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the logical OR expression is
        invalid.</p>
<h2 id="parse_logical_andself">parse_logical_and(self)</h2>
<p>| <strong>Description:</strong>
| Parses a logical AND expression. This method first parses the
  left-hand side of the expression using [parse_equality()]{.title-ref}.
  It then processes any subsequent logical AND operators, parsing the
  right-hand side of each AND operation and combining the results into a
  [BinaryOpNode]{.title-ref} representing the logical AND operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed logical AND expression, which is
        represented as a [BinaryOpNode]{.title-ref} if there are
        multiple AND operations, or a single expression if there is no
        AND operation.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the logical AND expression is
        invalid.</p>
<h2 id="parse_equalityself">parse_equality(self)</h2>
<p>| <strong>Description:</strong>
| Parses an equality expression. This method starts by parsing the
  left-hand side of the expression using
  [parse_relational()]{.title-ref}. It then processes any subsequent
  equality or inequality operators ([==]{.title-ref} or
  [!=]{.title-ref}), parsing the right-hand side of each operation and
  combining the results into a [BinaryOpNode]{.title-ref} representing
  the equality or inequality operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed equality expression, represented as a
        [BinaryOpNode]{.title-ref} if there are multiple equality
        operations, or a single expression if there are no equality
        operations.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the equality expression is
        invalid.</p>
<h2 id="parse_relationalself">parse_relational(self)</h2>
<p>| <strong>Description:</strong>
| Parses a relational expression. This method begins by parsing the
  left-hand side of the relational expression using
  [parse_additive()]{.title-ref}. It then processes any relational
  operators ([\&lt;]{.title-ref}, [&gt;]{.title-ref}, [\&lt;=]{.title-ref},
  [&gt;=]{.title-ref}), parsing the right-hand side of each operation and
  combining the results into a [BinaryOpNode]{.title-ref} representing
  the relational operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed relational expression, represented as a
        [BinaryOpNode]{.title-ref} if there are multiple relational
        operations, or a single expression if there are no relational
        operations.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the relational expression is
        invalid.</p>
<h2 id="parse_additiveself">parse_additive(self)</h2>
<p>| <strong>Description:</strong>
| Parses an additive expression. This method starts by parsing the
  left-hand side of the expression using
  [parse_multiplicative()]{.title-ref}. It then processes any additive
  operators ([+]{.title-ref}, [-]{.title-ref}), parsing the right-hand
  side of each operation and combining the results into a
  [BinaryOpNode]{.title-ref} representing the additive operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed additive expression, represented as a
        [BinaryOpNode]{.title-ref} if there are multiple additive
        operations, or a single expression if there are no additive
        operations.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the additive expression is
        invalid.</p>
<h2 id="parse_multiplicativeself">parse_multiplicative(self)</h2>
<p>| <strong>Description:</strong>
| Parses a multiplicative expression. This method starts by parsing the
  left-hand side of the expression using [parse_unary()]{.title-ref}. It
  then processes any multiplicative operators ([*]{.title-ref},
  [/]{.title-ref}), parsing the right-hand side of each operation and
  combining the results into a [BinaryOpNode]{.title-ref} representing
  the multiplicative operation.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed multiplicative expression, represented
        as a [BinaryOpNode]{.title-ref} if there are multiple
        multiplicative operations, or a single expression if there are
        no multiplicative operations.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the multiplicative expression
        is invalid.</p>
<h2 id="parse_unaryself">parse_unary(self)</h2>
<p>| <strong>Description:</strong>
| Parses a unary expression. This method handles unary operators such as
  [+]{.title-ref} and [-]{.title-ref}, applying these operators to the
  result of a recursive call to [parse_unary()]{.title-ref}. If no unary
  operator is present, it delegates to [parse_primary()]{.title-ref} to
  handle the primary expression.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed unary expression, represented as a
        [UnaryOpNode]{.title-ref} if a unary operator is present, or a
        primary expression if no unary operator is found.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If the syntax of the unary expression is
        invalid.</p>
<h2 id="parse_primaryself">parse_primary(self)</h2>
<p>| <strong>Description:</strong>
| Parses a primary expression, which includes literals, variables,
  function calls, or expressions inside parentheses.</p>
<p>| <strong>Parameters:</strong> None</p>
<p><strong>Returns:</strong></p>
<p>:   -   `ASTNode`: The parsed primary expression, such as a
        [VariableNode]{.title-ref}, a constructor call, a literal value,
        or an expression inside parentheses.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If an unexpected token is encountered in the
        expression.</p>
<h2 id="parse_vector_constructorself-type_name">parse_vector_constructor(self, type_name)</h2>
<p>| <strong>Description:</strong>
| Parses a vector constructor expression. This includes the opening
  parenthesis, a list of expressions separated by commas, and the
  closing parenthesis.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [type_name]{.title-ref} (str): The type of the vector being
        constructed (e.g., [vec2]{.title-ref}, [vec3]{.title-ref},
        [vec4]{.title-ref}).</p>
<p><strong>Returns:</strong></p>
<p>:   -   `VectorConstructorNode`: A node representing the vector
        constructor, which includes the vector type and its arguments.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `SyntaxError`: If an unexpected token is encountered (though
        this specific case is not directly handled in this method).</p>
<h2 id="parse_function_call_or_identifierself">parse_function_call_or_identifier(self)</h2>
<p>| <strong>Description:</strong>
| Parses either a function call or a member access based on the current
  token. If the token indicates a function call, it processes that;
  otherwise, it handles member access or just returns a variable node.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><strong>Function Call:</strong> If [LPAREN]{.title-ref} is the next token after
    the identifier.<ul>
<li>`FunctionCallNode`: Represents a function call with its name
    and arguments.</li>
</ul>
</li>
<li><strong>Member Access:</strong> If [DOT]{.title-ref} follows the identifier.<ul>
<li>`MemberAccessNode`: Represents accessing a member of a
    variable.</li>
</ul>
</li>
<li><strong>Variable Node:</strong> If no additional tokens are present.<ul>
<li>`VariableNode`: Represents a simple variable.</li>
</ul>
</li>
</ul>
<h2 id="parse_function_callself-name">parse_function_call(self, name)</h2>
<p>| <strong>Description:</strong>
| Parses a function call with the given function name and its arguments.
  The arguments are collected until the closing parenthesis is
  encountered.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `FunctionCallNode`: Represents a function call with its name
        and arguments.</p>
<h2 id="parse_member_accessself-object">parse_member_access(self, object)</h2>
<p>| <strong>Description:</strong>
| Parses member access expressions. It handles cases where members are
  accessed with dot notation, including nested member accesses.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `MemberAccessNode`: Represents the member access expression
        with the object and the member. If there are nested member
        accesses, the function will recursively parse them.</p>
<h2 id="parse_texture_sampleself">parse_texture_sample(self)</h2>
<p>| <strong>Purpose:</strong>
| Parses a texture sampling operation, which typically involves calling
  a [sample]{.title-ref} method on a texture with specified parameters.</p>
<p><strong>Return:</strong> - Returns a [TextureSampleNode]{.title-ref} with the
texture, sampler, and coordinates.</p>
<h1 id="metal-codegen_1">Metal Codegen</h1>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="generateself-ast">generate(self, ast)</h2>
<p>| <strong>Description:</strong>
| Generates shader code from the abstract syntax tree (AST). This method
  processes the structs, custom functions, vertex shader, and fragment
  shader sections to produce the final shader code.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [ast]{.title-ref} (AST): The abstract syntax tree representing
        the shader code, including functions and other relevant
        structures.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: The generated shader code as a string, including vertex
        and fragment shader sections.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `ValueError`: If no vertex or fragment functions are found in
        the AST when generating shader sections.</p>
<h2 id="process_structsself-ast">process_structs(self, ast)</h2>
<p>| <strong>Description:</strong>
| Processes struct definitions in the abstract syntax tree (AST) to
  categorize and map vertex and fragment input/output variables. This
  method updates the lists of vertex and fragment inputs and outputs
  based on the struct definitions.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [ast]{.title-ref} (AST): The abstract syntax tree representing
        the shader code, including function and struct definitions.</p>
<p><strong>Returns:</strong> [None]{.title-ref}</p>
<p><strong>Raises:</strong></p>
<p>:   -   `KeyError`: If a struct with an unexpected name is encountered
        (though this specific case is not directly handled in this
        method).</p>
<h2 id="generate_io_declarationsself-shader_type">generate_io_declarations(self, shader_type)</h2>
<p>| <strong>Description:</strong>
| Generates input and output declarations for vertex or fragment shaders
  based on the shader type. This method formats the declarations
  according to the shader type and the lists of vertex and fragment
  inputs and outputs.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [shader_type]{.title-ref} (str): The type of shader for which to
        generate declarations ([\"vertex\"]{.title-ref} or
        [\"fragment\"]{.title-ref}).</p>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted input and output
        declarations for the specified shader type.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `ValueError`: If an invalid [shader_type]{.title-ref} is
        provided (though this specific case is not directly handled in
        this method).</p>
<h2 id="generate_functionself-func">generate_function(self, func)</h2>
<p>| <strong>Description:</strong>
| Generates the code for a function, including its signature and body.
  It formats the function declaration and populates it with the
  function's parameters and return type.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [func]{.title-ref} (FunctionNode): The function node
        representing the function to generate code for, including its
        return type, name, parameters, and body.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted function declaration
        and body.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If the [func]{.title-ref} parameter is not an
        instance of [FunctionNode]{.title-ref} (though this specific
        case is not directly handled in this method).</p>
<h2 id="generate_main_functionself-func">generate_main_function(self, func)</h2>
<p>| <strong>Description:</strong>
| Generates the [main]{.title-ref} function code, including its body. It
  formats the [main]{.title-ref} function with appropriate indentation
  and generates the function body.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [func]{.title-ref} (FunctionNode): The function node
        representing the [main]{.title-ref} function to generate code
        for, including its body.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted [main]{.title-ref}
        function with its body.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If the [func]{.title-ref} parameter is not an
        instance of [FunctionNode]{.title-ref} (though this specific
        case is not directly handled in this method).</p>
<h2 id="generate_function_bodyself-body-indent0-is_mainfalse">generate_function_body(self, body, indent=0, is_main=False)</h2>
<p>| <strong>Description:</strong>
| Generates the body of a function, including variable declarations,
  assignments, return statements, and control flow statements. It
  handles different types of statements and formats them with
  appropriate indentation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[body]{.title-ref} (list): A list of statements and expressions to
    include in the function body.</li>
<li>[indent]{.title-ref} (int, optional): The level of indentation for
    formatting the code (default is 0).</li>
<li>[is_main]{.title-ref} (bool, optional): A flag indicating if the
    function is the [main]{.title-ref} function, affecting how certain
    statements are handled (default is False).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted code for the function
        body.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If any item in the [body]{.title-ref} list is not
        an instance of an expected node type (though this specific case
        is not directly handled in this method).</p>
<h2 id="generate_for_loopself-node-indent-is_main">generate_for_loop(self, node, indent, is_main)</h2>
<p>| <strong>Description:</strong>
| Generates the code for a [for]{.title-ref} loop statement, including
  its initialization, condition, update expression, and body. It handles
  formatting and indentation for the loop structure.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (ForNode): The [ForNode]{.title-ref} instance
    representing the [for]{.title-ref} loop, including initialization,
    condition, update, and body.</li>
<li>[indent]{.title-ref} (int): The level of indentation for formatting
    the code.</li>
<li>[is_main]{.title-ref} (bool): A flag indicating if the function is
    the [main]{.title-ref} function, affecting how certain statements
    are handled.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted code for the
        [for]{.title-ref} loop.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of
        [ForNode]{.title-ref}, though this specific case is not directly
        handled in this method.</p>
<h2 id="generate_if_statementself-node-indent-is_main">generate_if_statement(self, node, indent, is_main)</h2>
<p>| <strong>Description:</strong>
| Generates the code for an [if]{.title-ref} statement, including the
  condition, the [if]{.title-ref} body, and the optional
  [else]{.title-ref} body. Handles formatting and indentation for the
  [if]{.title-ref} structure.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (IfNode): The [IfNode]{.title-ref} instance
    representing the [if]{.title-ref} statement, including its
    condition, [if]{.title-ref} body, and optional [else]{.title-ref}
    body.</li>
<li>[indent]{.title-ref} (int): The level of indentation for formatting
    the code.</li>
<li>[is_main]{.title-ref} (bool): A flag indicating if the function is
    the [main]{.title-ref} function, affecting how certain statements
    are handled.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted code for the
        [if]{.title-ref} statement.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of
        [IfNode]{.title-ref}, though this specific case is not directly
        handled in this method.</p>
<h2 id="generate_assignmentself-node-is_main">generate_assignment(self, node, is_main)</h2>
<p>| <strong>Description:</strong>
| Generates the code for an assignment statement, handling special cases
  for assignments to output positions and general assignments. Formats
  the assignment based on whether it is in the [main]{.title-ref}
  function.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (AssignmentNode): The
    [AssignmentNode]{.title-ref} instance representing the assignment,
    including the left-hand side (LHS) and right-hand side (RHS)
    expressions.</li>
<li>[is_main]{.title-ref} (bool): A flag indicating if the function is
    the [main]{.title-ref} function, which affects how certain
    assignments are formatted.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the formatted code for the
        assignment statement.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of
        [AssignmentNode]{.title-ref}, though this specific case is not
        directly handled in this method.</p>
<h2 id="generate_expressionself-expr-is_mainfalse">generate_expression(self, expr, is_main=False)</h2>
<p>| <strong>Description:</strong>
| Generates code for an expression, handling various types of AST nodes
  including variables, assignments, binary operations, function calls,
  member access, unary operations, ternary operations, and vector
  constructors.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[expr]{.title-ref} (ASTNode): The AST node representing the
    expression to be converted to code. This can be a
    [VariableNode]{.title-ref}, [AssignmentNode]{.title-ref},
    [BinaryOpNode]{.title-ref}, [FunctionCallNode]{.title-ref},
    [MemberAccessNode]{.title-ref}, [UnaryOpNode]{.title-ref},
    [TernaryOpNode]{.title-ref}, or [VectorConstructorNode]{.title-ref}.</li>
<li>[is_main]{.title-ref} (bool, optional): A flag indicating if the
    expression is within the [main]{.title-ref} function, affecting how
    some expressions are formatted. Defaults to [False]{.title-ref}.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: A string containing the generated code for the
        expression.</p>
<p><strong>Raises:</strong></p>
<p>:   -   `TypeError`: If [expr]{.title-ref} is not an instance of a
        recognized AST node class or a string.</p>
<h2 id="map_typeself-metal_type">map_type(self, metal_type)</h2>
<p>| <strong>Description:</strong>
| Maps a type from the internal representation (e.g., Metal shading
  language types) to the corresponding type in the target language.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   [metal_type]{.title-ref} (str): The type in the internal
        representation that needs to be mapped to the target language
        type.</p>
<p><strong>Returns:</strong></p>
<p>:   -   `str`: The corresponding type in the target language based on
        the [type_map]{.title-ref}. If [metal_type]{.title-ref} is not
        found in [type_map]{.title-ref}, it returns the
        [metal_type]{.title-ref} itself.</p>
<p><strong>Raises:</strong> [None]{.title-ref}</p>
<h1 id="opengl">OpenGL</h1>
<h2 id="opengl-ast">OpenGL AST</h2>
<h2 id="uniformnode">UniformNode</h2>
<p>Represents a uniform variable in a shader program.</p>
<ul>
<li>
<p><strong>Description</strong>: This class represents a uniform variable used to
    pass data from the application to the shader. It stores the type and
    name of the uniform and provides methods to return its string
    representation.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `vtype (str)[: The data type of the uniform variable (e.g.,
        `float]{.title-ref}, [vec3]{.title-ref}).
    -   `name (str)`: The name of the uniform variable.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `UniformNode`: An object representing the uniform
        variable, with methods to generate its shader code
        representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [UniformNode]{.title-ref} instance, suitable for
        debugging.
    -   `__str__() -&gt; str`: Returns the uniform declaration
        in the shader code as a string.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="constantnode">ConstantNode</h2>
<p>Represents a constant value used in shader code.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates a constant value in shader
    code, such as a number, boolean, or any fixed data type. It provides
    methods to return its string representation.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `value (any)[: The constant value to be represented (e.g.,
        `42]{.title-ref}, [3.14]{.title-ref}, [true]{.title-ref}).</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `ConstantNode`: An object representing the constant value,
        with methods to generate its string representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [ConstantNode]{.title-ref} instance, suitable for
        debugging.
    -   `__str__() -&gt; str`: Returns the string representation
        of the constant value.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="versiondirectivenode">VersionDirectiveNode</h2>
<p>Represents a GLSL version directive in shader code.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates a GLSL version directive,
    which specifies the GLSL version and profile being used in the
    shader code.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `number (str)[: The version number of GLSL (e.g.,
        `450]{.title-ref}).
    -   `profile (str)[: The profile of GLSL (e.g.,
        `core]{.title-ref}, [compatibility]{.title-ref}).</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `VersionDirectiveNode`: An object representing the GLSL
        version directive, with methods to generate its string
        representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [VersionDirectiveNode]{.title-ref} instance, suitable
        for debugging.
    -   `__str__() -&gt; str`: Returns the GLSL version
        directive as a string.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="layoutnode">LayoutNode</h2>
<p>Represents a GLSL layout qualifier for shader variables.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates a GLSL layout qualifier,
    specifying the location and type of shader variables. It supports
    variables in different sections of the shader code.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `location_number (int)[: The location number of the shader
        variable (e.g., `0]{.title-ref}, [1]{.title-ref}).
    -   `dtype (str)[: The data type of the shader variable (e.g.,
        `vec4]{.title-ref}, [float]{.title-ref}).
    -   `name (str)`: The name of the shader variable.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `LayoutNode`: An object representing the GLSL layout
        qualifier, with methods to generate its string
        representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [LayoutNode]{.title-ref} instance, suitable for
        debugging.
    -   `__str__() -&gt; str`: Returns the GLSL layout qualifier
        as a string.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="ternaryopnode_2">TernaryOpNode</h2>
<p>Represents a ternary conditional expression in shader code.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates a ternary conditional
    expression, which is used for conditional operations in shader code.
    It stores the condition, true expression, and false expression.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `condition (ASTNode)[: The condition expression that
        evaluates to either `true]{.title-ref} or
        [false]{.title-ref}.
    -   `true_expr (ASTNode)[: The expression to evaluate and
        return if the condition is `true]{.title-ref}.
    -   `false_expr (ASTNode)[: The expression to evaluate and
        return if the condition is `false]{.title-ref}.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `TernaryOpNode`: An object representing the ternary
        operation, with methods to generate its string
        representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [TernaryOpNode]{.title-ref} instance, including the
        condition, true expression, and false expression.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="shadernode_2">ShaderNode</h2>
<p>Represents a shader program, encapsulating all its components.</p>
<ul>
<li>
<p><strong>Description</strong>: This class represents a complete shader program,
    including the version, input and output variables, uniforms, and the
    vertex and fragment shader sections.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   [version (str)]{.title-ref}`: The version of the shader
        language used.
    -   `global_inputs (list of LayoutNode)`: A list of layout
        nodes specifying global input variables.
    -   `global_outputs (list of LayoutNode)`: A list of layout
        nodes specifying global output variables.
    -   `uniforms (list of UniformNode)`: A list of uniform
        variables used in the shader.
    -   `vertex_section (list of ASTNode)`: A list of AST nodes
        representing the vertex shader section.
    -   `fragment_section (list of ASTNode)`: A list of AST nodes
        representing the fragment shader section.
    -   `functions (list of FunctionNode)`: A list of function
        nodes defined in the shader.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `ShaderNode`: An object representing the entire shader
        program, with methods to generate its string representation.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [ShaderNode]{.title-ref} instance, showing its
        version, global inputs, global outputs, functions, vertex
        section, and fragment section.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="vertexshadernode-class-1">VERTEXShaderNode</h2>
<p>Represents the vertex shader section of a shader program, including
input and output variables, uniform variables, functions, and layout
qualifiers.</p>
<ul>
<li>
<p><strong>Description</strong>: This class represents the vertex shader portion of
    a shader program, encapsulating its inputs, outputs, uniforms, and
    any associated functions or layout qualifiers.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `inputs (list of LayoutNode)`: A list of input variables
        for the vertex shader.
    -   `outputs (list of LayoutNode)`: A list of output variables
        for the vertex shader.
    -   `uniform (list of UniformNode)`: A list of uniform
        variables used in the vertex shader.
    -   `functions (list of FunctionNode)`: A list of functions
        defined in the vertex shader.
    -   `layout_qualifiers (list of LayoutNode, optional)`: A list
        of layout qualifiers specifying additional layout
        information.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `VERTEXShaderNode`: An object representing the vertex
        shader section, with attributes and methods to manipulate
        its components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [VERTEXShaderNode]{.title-ref} instance, including
        its inputs, outputs, uniform variables, functions, and
        layout qualifiers.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="fragmentshadernode-class">FRAGMENTShaderNode</h2>
<p>Represents the fragment shader section of a shader program, including
input and output variables, uniform variables, functions, and layout
qualifiers.</p>
<ul>
<li>
<p><strong>Description</strong>: This class represents the fragment shader portion
    of a shader program, encapsulating its inputs, outputs, uniforms,
    and any associated functions or layout qualifiers.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `inputs (list of LayoutNode)`: A list of input variables
        for the fragment shader.
    -   `outputs (list of LayoutNode)`: A list of output variables
        for the fragment shader.
    -   `uniform (list of UniformNode)`: A list of uniform
        variables used in the fragment shader.
    -   `functions (list of FunctionNode)`: A list of functions
        defined in the fragment shader.
    -   `layout_qualifiers (list of LayoutNode, optional)`: A list
        of layout qualifiers specifying additional layout
        information.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `FRAGMENTShaderNode`: An object representing the fragment
        shader section, with attributes and methods to manipulate
        its components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [FRAGMENTShaderNode]{.title-ref} instance, including
        its inputs, outputs, uniform variables, functions, and
        layout qualifiers.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="functionnode-class">FunctionNode</h2>
<p>Represents a function definition within a shader or programming
language.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates a function\'s return type,
    name, parameters, and body within a shader or programming language
    context.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `return_type (str)[: The return type of the function (e.g.,
        `void]{.title-ref}, [float]{.title-ref},
        [vec4]{.title-ref}).
    -   `name (str)`: The name of the function.
    -   `params (list of VariableNode)[: A list of parameters for
        the function, where each parameter is represented as a
        `VariableNode]{.title-ref}.
    -   `body (list of ASTNode)`: A list of statements or
        expressions representing the function body.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `FunctionNode`: An object representing the function, with
        attributes and methods to manipulate its components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [FunctionNode]{.title-ref} instance, including its
        return type, name, parameters, and body.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="variablenode-class">VariableNode</h2>
<p>Represents a variable within a shader or programming language.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates the type of a variable and
    its name within a shader or programming language context.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `vtype (str)[: The type of the variable (e.g.,
        `int]{.title-ref}, [float]{.title-ref},
        [vec3]{.title-ref}).
    -   `name (str)`: The name of the variable.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `VariableNode`: An object representing the variable, with
        attributes and methods to manipulate its components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [VariableNode]{.title-ref} instance, including its
        type and name.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="assignmentnode-class">AssignmentNode</h2>
<p>Represents an assignment operation within a shader or programming
language.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates an assignment operation,
    including the variable name being assigned and the value assigned to
    it.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `name (str)`: The name of the variable being assigned.
    -   `value (any)`: The value assigned to the variable.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `AssignmentNode`: An object representing the assignment
        operation, with attributes and methods to manipulate its
        components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [AssignmentNode]{.title-ref} instance, including the
        variable name and the assigned value.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="ifnode-class">IfNode</h2>
<p>Represents an if-else conditional structure within a shader or
programming language.</p>
<ul>
<li>
<p><strong>Description</strong>: This class encapsulates an if-else conditional
    structure, including the condition, the body of the if statement,
    optional else-if chains, and an optional else body.</p>
</li>
<li>
<p><strong>Attributes</strong>:</p>
<p>:   -   `condition (ASTNode)`: The condition to evaluate.
    -   `if_body (list of ASTNode)`: The body of the if statement.
    -   `else_if_chain (list of tuple, optional)`: A list of
        tuples, each containing a condition and a body for else-if
        statements.
    -   `else_body (list of ASTNode, optional)`: The body of the
        else statement.</p>
</li>
<li>
<p><strong>Returns</strong>:</p>
<p>:   -   `IfNode`: An object representing the if-else structure,
        with attributes and methods to manipulate its components.</p>
</li>
<li>
<p><strong>Methods</strong>:</p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [IfNode]{.title-ref} instance, including its
        condition, if body, else-if chain, and else body.</p>
</li>
<li>
<p><strong>Raises</strong>:</p>
<p>:   -   `None`: This class does not raise exceptions.</p>
</li>
</ul>
<h2 id="fornode-class-1">ForNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents a for-loop structure within a shader or
    programming language. It includes the initialization, condition,
    update, and the body of the loop.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [init]{.title-ref} (ASTNode): The initialization statement
        of the for-loop.
    -   [condition]{.title-ref} (ASTNode): The condition to evaluate
        for each iteration.
    -   [update]{.title-ref} (ASTNode): The update statement
        executed after each iteration.
    -   [body]{.title-ref} (list of ASTNode): The body of the
        for-loop.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [init]{.title-ref} (ASTNode): The initialization statement.
    -   [condition]{.title-ref} (ASTNode): The condition to
        evaluate.
    -   [update]{.title-ref} (ASTNode): The update statement.
    -   [body]{.title-ref} (list of ASTNode): The body of the
        for-loop.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [ForNode]{.title-ref} instance, including its
        initialization, condition, update, and body.</p>
</li>
</ul>
<h2 id="returnnode-class">ReturnNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents a return statement within a shader or
    programming language. It includes the value to be returned.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [value]{.title-ref} (any): The value to be returned by the
        return statement.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [value]{.title-ref} (any): The value to be returned.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [ReturnNode]{.title-ref} instance, including the
        value to be returned.</p>
</li>
</ul>
<h2 id="functioncallnode-class">FunctionCallNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents a function call within a shader or
    programming language. It includes the function name and the
    arguments passed to the function.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the function being
        called.
    -   [args]{.title-ref} (list of ASTNode): A list of arguments
        passed to the function.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the function.
    -   [args]{.title-ref} (list of ASTNode): The arguments passed
        to the function.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [FunctionCallNode]{.title-ref} instance, including
        the function name and arguments.</p>
</li>
</ul>
<h2 id="binaryopnode-class">BinaryOpNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents a binary operation within a shader or
    programming language. It includes the left operand, the operator,
    and the right operand.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [left]{.title-ref} (ASTNode): The left operand of the binary
        operation.
    -   [op]{.title-ref} (str): The operator of the binary operation
        (e.g., [+]{.title-ref}, [-]{.title-ref}, [*]{.title-ref},
        [/]{.title-ref}).
    -   [right]{.title-ref} (ASTNode): The right operand of the
        binary operation.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [left]{.title-ref} (ASTNode): The left operand.
    -   [op]{.title-ref} (str): The operator.
    -   [right]{.title-ref} (ASTNode): The right operand.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [BinaryOpNode]{.title-ref} instance, including the
        left operand, operator, and right operand.</p>
</li>
</ul>
<h2 id="memberaccessnode-class">MemberAccessNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents member access within a shader or
    programming language. It includes the object and the member being
    accessed.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [object]{.title-ref} (ASTNode): The object whose member is
        being accessed.
    -   [member]{.title-ref} (str): The member being accessed.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [object]{.title-ref} (ASTNode): The object.
    -   [member]{.title-ref} (str): The member being accessed.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [MemberAccessNode]{.title-ref} instance, including
        the object and the member being accessed.</p>
</li>
</ul>
<h2 id="unaryopnode-class">UnaryOpNode Class</h2>
<ul>
<li>
<p><strong>Description:</strong> Represents a unary operation within a shader or
    programming language. It includes the operator and the operand.</p>
</li>
<li>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [op]{.title-ref} (str): The operator of the unary operation
        (e.g., [-]{.title-ref}, [!]{.title-ref}, [\~]{.title-ref}).
    -   [operand]{.title-ref} (ASTNode): The operand of the unary
        operation.</p>
</li>
<li>
<p><strong>Attributes:</strong></p>
<p>:   -   [op]{.title-ref} (str): The operator.
    -   [operand]{.title-ref} (ASTNode): The operand.</p>
</li>
<li>
<p><strong>Methods:</strong></p>
<p>:   -   `__repr__() -&gt; str`: Returns a string representation
        of the [UnaryOpNode]{.title-ref} instance, including the
        operator and operand.
    -   `__str__() -&gt; str`: Returns a string representation
        of the unary operation in the format [(operator
        operand)]{.title-ref}.</p>
</li>
</ul>
<h1 id="opengl-lexer">OpenGL Lexer</h1>
<h2 id="tokens-list_1">TOKENS List</h2>
<p>| <strong>Description:</strong>
| Defines a list of tuples representing different types of tokens used
  in a shader or programming language. Each tuple contains a token name
  and its corresponding regular expression pattern.</p>
<p>| <strong>Tokens:</strong></p>
<ul>
<li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with <code>//</code>.</li>
<li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed by
    <code>/* ... */</code>.</li>
<li><code>ELSE_IF</code>: Matches <code>else if</code> statements.</li>
<li><code>VERSION</code>: Matches version directives starting with <code>#version</code>.</li>
<li><code>NUMBER</code>: Matches numeric literals (e.g., <code>123</code>, <code>123.45</code>).</li>
<li><code>CORE</code>: Matches the keyword <code>core</code>.</li>
<li><code>SHADER</code>: Matches the keyword <code>shader</code>.</li>
<li><code>INPUT</code>: Matches the keyword <code>input</code>.</li>
<li><code>OUTPUT</code>: Matches the keyword <code>output</code>.</li>
<li><code>VOID</code>: Matches the keyword <code>void</code>.</li>
<li><code>MAIN</code>: Matches the <code>main</code> function.</li>
<li><code>UNIFORM</code>: Matches the keyword <code>uniform</code>.</li>
<li><code>VECTOR</code>: Matches vector types (e.g., <code>vec2</code>, <code>vec3</code>, <code>vec4</code>).</li>
<li><code>MATRIX</code>: Matches matrix types (e.g., <code>mat2</code>, <code>mat3</code>, <code>mat4</code>).</li>
<li><code>BOOL</code>: Matches the keyword <code>bool</code>.</li>
<li><code>FLOAT</code>: Matches the keyword <code>float</code>.</li>
<li><code>INT</code>: Matches the keyword <code>int</code>.</li>
<li><code>SAMPLER2D</code>: Matches the keyword <code>sampler2D</code>.</li>
<li><code>PRE_INCREMENT</code>: Matches the pre-increment operator <code>++</code> when
    followed by a word character.</li>
<li><code>PRE_DECREMENT</code>: Matches the pre-decrement operator <code>--</code> when
    followed by a word character.</li>
<li><code>POST_INCREMENT</code>: Matches the post-increment operator <code>++</code> when
    preceded by a word character.</li>
<li><code>POST_DECREMENT</code>: Matches the post-decrement operator <code>--</code> when
    preceded by a word character.</li>
<li><code>IDENTIFIER</code>: Matches identifiers (e.g., variable names, function
    names) using the pattern <code>[a-zA-Z_][a-zA-Z_0-9]*</code>.</li>
<li><code>LBRACE</code>: Matches the left brace <code>{</code>.</li>
<li><code>RBRACE</code>: Matches the right brace <code>}</code>.</li>
<li><code>LPAREN</code>: Matches the left parenthesis <code>(</code>.</li>
<li><code>RPAREN</code>: Matches the right parenthesis <code>)</code>.</li>
<li><code>SEMICOLON</code>: Matches the semicolon <code>;</code>.</li>
<li><code>COMMA</code>: Matches the comma <code>,</code>.</li>
<li><code>ASSIGN_ADD</code>: Matches the addition assignment operator <code>+=</code>.</li>
<li><code>ASSIGN_SUB</code>: Matches the subtraction assignment operator <code>-=</code>.</li>
<li><code>ASSIGN_MUL</code>: Matches the multiplication assignment operator <code>*=</code>.</li>
<li><code>ASSIGN_DIV</code>: Matches the division assignment operator <code>/=</code>.</li>
<li><code>EQUAL</code>: Matches the equality operator <code>==</code>.</li>
<li><code>NOT_EQUAL</code>: Matches the inequality operator <code>!=</code>.</li>
<li><code>WHITESPACE</code>: Matches whitespace characters.</li>
<li><code>IF</code>: Matches the keyword <code>if</code>.</li>
<li><code>ELSE</code>: Matches the keyword <code>else</code>.</li>
<li><code>FOR</code>: Matches the keyword <code>for</code>.</li>
<li><code>RETURN</code>: Matches the keyword <code>return</code>.</li>
<li><code>LESS_EQUAL</code>: Matches the less than or equal to operator <code>&lt;=</code>.</li>
<li><code>GREATER_EQUAL</code>: Matches the greater than or equal to operator <code>&gt;=</code>.</li>
<li><code>LESS_THAN</code>: Matches the less than operator <code>&lt;</code>.</li>
<li><code>GREATER_THAN</code>: Matches the greater than operator <code>&gt;</code>.</li>
<li><code>AND</code>: Matches the logical AND operator <code>&amp;&amp;</code>.</li>
<li><code>OR</code>: Matches the logical OR operator <code>||</code>.</li>
<li><code>NOT</code>: Matches the logical NOT operator <code>!</code>.</li>
<li><code>PLUS</code>: Matches the addition operator <code>+</code>.</li>
<li><code>MINUS</code>: Matches the subtraction operator <code>-</code>.</li>
<li><code>MULTIPLY</code>: Matches the multiplication operator <code>*</code>.</li>
<li><code>DIVIDE</code>: Matches the division operator <code>/</code>.</li>
<li><code>DOT</code>: Matches the dot operator <code>.</code>.</li>
<li><code>EQUALS</code>: Matches the assignment operator <code>=</code>.</li>
<li><code>QUESTION</code>: Matches the ternary conditional operator <code>?</code>.</li>
<li><code>COLON</code>: Matches the colon <code>:</code>.</li>
<li><code>LAYOUT</code>: Matches the keyword <code>layout</code>.</li>
<li><code>IN</code>: Matches the keyword <code>in</code>.</li>
<li><code>OUT</code>: Matches the keyword <code>out</code>.</li>
</ul>
<h2 id="keywords-dictionary_2">KEYWORDS Dictionary</h2>
<p>| <strong>Description:</strong>
| Defines a dictionary mapping specific keywords to their corresponding
  token names.</p>
<p>| <strong>Keywords:</strong></p>
<ul>
<li><code>"void"</code>: <code>VOID</code></li>
<li><code>"main"</code>: <code>MAIN</code></li>
<li><code>"vertex"</code>: <code>VERTEX</code></li>
<li><code>"fragment"</code>: <code>FRAGMENT</code></li>
<li><code>"else if"</code>: <code>ELSE_IF</code></li>
<li><code>"if"</code>: <code>IF</code></li>
<li><code>"else"</code>: <code>ELSE</code></li>
<li><code>"for"</code>: <code>FOR</code></li>
<li><code>"return"</code>: <code>RETURN</code></li>
<li><code>"layout"</code>: <code>LAYOUT</code></li>
<li><code>"in"</code>: <code>IN</code></li>
<li><code>"out"</code>: <code>OUT</code></li>
</ul>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="tokenize-method">Tokenize Method</h2>
<p>| <strong>Description:</strong>
| Tokenizes the input code by matching it against predefined token
  patterns and appending the tokens to the [self.tokens]{.title-ref}
  list. It handles identifiers, keywords, version directives, and
  ignores whitespace. If an illegal character is encountered, it raises
  a [SyntaxError]{.title-ref}.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code to be
        tokenized.</p>
<p><strong>Attributes:</strong></p>
<p>:   -   [self.code]{.title-ref} (str): The code to be tokenized. -
        [self.tokens]{.title-ref} (list of tuple): The list of tokens
        generated from the code.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>tokenize(self):<ul>
<li>Initializes the position [pos]{.title-ref} to 0.</li>
<li>Iterates through the code, matching it against token patterns.</li>
<li>Appends matched tokens to [self.tokens]{.title-ref}.</li>
<li>Handles special cases for identifiers and keywords.</li>
<li>Ignores whitespace tokens.</li>
<li>Raises a [SyntaxError]{.title-ref} for illegal characters.</li>
<li>Appends an [EOF]{.title-ref} token at the end.</li>
</ul>
</li>
</ul>
<h1 id="opengl-parser">OpenGL Parser</h1>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="skip_comments-method">skip_comments Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Skips over multi-line comments in the code by consuming tokens until
    the end of the comment is reached.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>`skip_comments(self)[: - Continues to consume tokens while the
    current token type is ]{.title-ref}\"COMMENT_MULTI\"[. - Uses the
    `eat]{.title-ref} method to consume the current token.</li>
</ul>
<h2 id="eat-method">eat Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Consumes the current token if it matches the expected token type and
    advances to the next token. If the token does not match, it raises a
    [SyntaxError]{.title-ref}. It also skips comments after consuming a
    token.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the tokens.
    -   [token_type]{.title-ref} (str): The expected type of the current
        token.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`eat(self, token_type)[: - Checks if the current token type matches the expected `token_type]{.title-ref}.</p>
<p>:   -   If it matches, increments the position [pos]{.title-ref} and
        updates [current_token]{.title-ref} to the next token.
    -   Calls [skip_comments()]{.title-ref} to skip any comments
        after consuming a token.
    -   If it does not match, raises a [SyntaxError]{.title-ref}
        with a message indicating the expected and actual token
        types.</p>
</li>
</ul>
<h2 id="parse-method">parse Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the input code, handling comments, version directives, and
    shader definitions. It returns the root node of the parsed shader.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse(self)[: - Calls `skip_comments()]{.title-ref} to skip any comments at the beginning.</p>
<p>:   -   Parses the version directive using
        [parse_version_directive()]{.title-ref} and stores the
        result in [version_node]{.title-ref}.
    -   Parses the shader using
        [parse_shader(version_node)]{.title-ref} and stores the
        result in [shader_node]{.title-ref}.
    -   Returns [shader_node]{.title-ref} as the root node of the
        parsed shader.</p>
</li>
</ul>
<h2 id="parse_version_directive-method">parse_version_directive Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the version directive from the input tokens. It handles the
    [VERSION]{.title-ref} token followed by a [NUMBER]{.title-ref} token
    and optionally a [CORE]{.title-ref} token.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_version_directive(self)[: - Checks if the current token is `VERSION]{.title-ref}.</p>
<p>:   -   If true, consumes the [VERSION]{.title-ref} token.
    -   Checks if the next token is [NUMBER]{.title-ref}.
    -   If true, stores the number and consumes the
        [NUMBER]{.title-ref} token.
    -   Optionally checks for a [CORE]{.title-ref} token and
        consumes it if present.
    -   Returns a [VersionDirectiveNode]{.title-ref} with the parsed
        number and optional version identifier.
    -   Raises a [SyntaxError]{.title-ref} if the expected tokens
        are not found.</p>
</li>
</ul>
<h2 id="parse_layout-method">parse_layout Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the layout directive from the input tokens. It handles the
    [LAYOUT]{.title-ref} token followed by a [location]{.title-ref}
    identifier and its associated number, and then processes either an
    [IN]{.title-ref} or [OUT]{.title-ref} token to determine the
    input/output type.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.
    -   `current_section`: The current section being parsed.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_layout(self, current_section)[: - Consumes the `LAYOUT]{.title-ref} and [LPAREN]{.title-ref} tokens.</p>
<p>:   -   Checks for the [location]{.title-ref} identifier and
        consumes the [IDENTIFIER]{.title-ref}, [EQUALS]{.title-ref},
        and [NUMBER]{.title-ref} tokens.
    -   Consumes the [RPAREN]{.title-ref} token and skips any
        comments.
    -   Checks for [IN]{.title-ref} or [OUT]{.title-ref} tokens to
        determine the input/output type.
    -   If [IN]{.title-ref}, consumes the [IN]{.title-ref} token,
        parses the type, and consumes the [IDENTIFIER]{.title-ref}
        and [SEMICOLON]{.title-ref} tokens.
    -   If [OUT]{.title-ref}, consumes the [OUT]{.title-ref} token,
        parses the type, and consumes the [IDENTIFIER]{.title-ref}
        and [SEMICOLON]{.title-ref} tokens.
    -   Returns a [LayoutNode]{.title-ref} with the parsed section,
        location number, data type, name, and input/output type.
    -   Raises a [SyntaxError]{.title-ref} if the expected tokens
        are not found.</p>
</li>
</ul>
<h2 id="parse_shader-method">parse_shader Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the shader code, handling global inputs, outputs, uniforms,
    and specific sections for vertex and fragment shaders.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.
    -   `version_node`: The node representing the version directive.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_shader(self, version_node)[: - Initializes lists for global inputs, outputs, and uniforms. - Creates empty `VERTEXShaderNode]{.title-ref} and [FRAGMENTShaderNode]{.title-ref} instances.</p>
<p>:   -   Sets [current_section]{.title-ref} to [None]{.title-ref}.</p>
<pre><code>-

    Iterates through tokens until [EOF]{.title-ref} is reached:

    :   -   Handles single-line comments to determine the
            current section ([VERTEX]{.title-ref} or
            [FRAGMENT]{.title-ref}).
        -   Parses layout directives and appends them to the
            appropriate section.
        -   Parses inputs and appends them to the appropriate
            section or global list.
        -   Parses outputs and appends them to the appropriate
            section or global list.
        -   Parses uniforms and appends them to the global list.
        -   Parses version directives.
        -   Parses functions and appends them to the appropriate
            section.
        -   Handles braces to parse shader sections and appends
            content to the appropriate section.

-   Raises [SyntaxError]{.title-ref} for unexpected tokens or
    misplaced functions and braces.
</code></pre>
</li>
</ul>
<h2 id="parse_shader_section-method">parse_shader_section Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses a section of the shader code, handling inputs, outputs,
    uniforms, functions, and layout qualifiers within braces.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.
    -   `current_section`: The current section being parsed.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_shader_section(self, current_section)[: - Initializes lists for inputs, outputs, uniforms, functions, and layout qualifiers. - Consumes the `LBRACE]{.title-ref} token.</p>
<p>:   -   </p>
<pre><code>    Iterates through tokens until [RBRACE]{.title-ref} or [EOF]{.title-ref} is reached:

    :   -   Parses layout directives and appends them to
            [layout_qualifiers]{.title-ref}.
        -   Parses inputs and appends them to
            [inputs]{.title-ref}.
        -   Parses outputs and appends them to
            [outputs]{.title-ref}.
        -   Parses uniforms and appends them to
            [uniforms]{.title-ref}.
        -   Parses functions and appends them to
            [functions]{.title-ref}.

-   Returns a tuple of lists containing inputs, outputs,
    uniforms, layout qualifiers, and functions when
    [RBRACE]{.title-ref} is encountered.

-   Raises a [SyntaxError]{.title-ref} for unexpected tokens or
    end of input.
</code></pre>
</li>
</ul>
<h2 id="parse_inputs-method">parse_inputs Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the input variables from the tokens, handling the
    [IN]{.title-ref} token followed by the variable type and name.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_inputs(self)[: - Initializes an empty list `inputs]{.title-ref}.</p>
<p>:   -   </p>
<pre><code>    Iterates through tokens while the current token is \`IN\`:

    :   -   Consumes the [IN]{.title-ref} token.
        -   Parses the variable type and stores it in
            [vtype]{.title-ref}.
        -   Stores the variable name from the current token.
        -   Consumes the [IDENTIFIER]{.title-ref} and
            [SEMICOLON]{.title-ref} tokens.
        -   Appends a tuple [(vtype, name)]{.title-ref} to
            [inputs]{.title-ref}.

-   Returns the list [inputs]{.title-ref}.
</code></pre>
</li>
</ul>
<h2 id="parse_outputs-method">parse_outputs Method</h2>
<p><strong>Description</strong>:</p>
<p>:   Parses the output variables from the tokens, handling the
    [OUT]{.title-ref} token followed by the variable type and name.</p>
<p><strong>Parameters</strong>:</p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details</strong>:</p>
<ul>
<li>
<p>`parse_outputs(self)[: - Initializes an empty list `outputs]{.title-ref}.</p>
<p>:   -   </p>
<pre><code>    Iterates through tokens while the current token is \`OUT\`:

    :   -   Consumes the [OUT]{.title-ref} token.
        -   Parses the variable type and stores it in
            [vtype]{.title-ref}.
        -   Stores the variable name from the current token.
        -   Consumes the [IDENTIFIER]{.title-ref} and
            [SEMICOLON]{.title-ref} tokens.
        -   Appends a tuple [(vtype, name)]{.title-ref} to
            [outputs]{.title-ref}.

-   Returns the list [outputs]{.title-ref}.
</code></pre>
</li>
</ul>
<h2 id="parse_uniforms-method">parse_uniforms Method</h2>
<p>| <strong>Description:</strong>
| Parses the uniform variables from the tokens, handling the
  [UNIFORM]{.title-ref} token followed by the variable type and name.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_uniforms(self)`:<ul>
<li>Initializes an empty list [uniforms]{.title-ref}.</li>
<li>Iterates through tokens while the current token is `UNIFORM`:<ul>
<li>Consumes the [UNIFORM]{.title-ref} token.</li>
<li>Parses the variable type and stores it in
    [vtype]{.title-ref}.</li>
<li>Stores the variable name from the current token.</li>
<li>Consumes the [IDENTIFIER]{.title-ref} and
    [SEMICOLON]{.title-ref} tokens.</li>
<li>Appends a [UniformNode]{.title-ref} with [vtype]{.title-ref}
    and [name]{.title-ref} to [uniforms]{.title-ref}.</li>
</ul>
</li>
<li>Returns the list [uniforms]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_variable-method">parse_variable Method</h2>
<p>| <strong>Description:</strong>
| Parses a variable declaration or assignment from the tokens, handling
  various forms of assignments and member access.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.
    -   `type_name`: The type of the variable being parsed.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_variable(self, type_name)`:<ul>
<li>Stores the variable name from the current token and consumes the
    [IDENTIFIER]{.title-ref} token.</li>
<li>Handles member access by consuming [DOT]{.title-ref} and
    [IDENTIFIER]{.title-ref} tokens, appending to the variable name.</li>
<li>If the next token is [SEMICOLON]{.title-ref}, consumes it and
    returns a [VariableNode]{.title-ref}.</li>
<li>If the next token is [EQUALS]{.title-ref}, consumes it, parses
    the expression, and returns an [AssignmentNode]{.title-ref}.</li>
<li>If the next token is a compound assignment operator
    ([ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},
    [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}), consumes
    it, parses the expression, and returns a
    [BinaryOpNode]{.title-ref}.</li>
<li>Raises a [SyntaxError]{.title-ref} for unexpected tokens or
    missing semicolons.</li>
</ul>
</li>
</ul>
<h2 id="parse_assignment_or_function_call-method">parse_assignment_or_function_call Method</h2>
<p>| <strong>Description:</strong>
| Parses an assignment or function call from the tokens, handling
  various types of assignments, increments, decrements, and function
  calls.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_assignment_or_function_call(self)`:<ul>
<li>Initializes [type_name]{.title-ref} as an empty string.</li>
<li>Checks if the current token is a type ([VECTOR]{.title-ref},
    [FLOAT]{.title-ref}, [INT]{.title-ref}, [MATRIX]{.title-ref}):<ul>
<li>If true, stores the type name and consumes the token.</li>
</ul>
</li>
<li>If the current token is [IDENTIFIER]{.title-ref}, calls
    [parse_variable]{.title-ref} with [type_name]{.title-ref}.<ul>
<li>Stores the identifier name and consumes the
    [IDENTIFIER]{.title-ref} token.</li>
</ul>
</li>
<li>Checks for assignment operators ([EQUALS]{.title-ref},
    [ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},
    [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}):<ul>
<li>If true, calls [parse_assignment]{.title-ref} with the name.</li>
</ul>
</li>
<li>Checks for increment ([PRE_INCREMENT]{.title-ref},
    [POST_INCREMENT]{.title-ref}) or decrement
    ([PRE_DECREMENT]{.title-ref}, [POST_DECREMENT]{.title-ref})
    operators:<ul>
<li>If true, consumes the operator and returns an
    [AssignmentNode]{.title-ref} with a
    [UnaryOpNode]{.title-ref}.</li>
</ul>
</li>
<li>Checks for a function call ([LPAREN]{.title-ref}):<ul>
<li>If true, calls [parse_function_call]{.title-ref} with the
    name.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} for unexpected tokens after
    the identifier.</li>
</ul>
</li>
</ul>
<h2 id="parse_function-method">parse_function Method</h2>
<p>| <strong>Description:</strong>
| Parses a function definition from the tokens, handling the return
  type, function name, parameters, and body.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_function(self)`:<ul>
<li>Parses the return type using [parse_type()]{.title-ref}.</li>
<li>Checks if the current token is [MAIN]{.title-ref} or
    `IDENTIFIER`:<ul>
<li>If [MAIN]{.title-ref}, stores the function name and consumes
    the [MAIN]{.title-ref} token.</li>
<li>If [IDENTIFIER]{.title-ref}, stores the function name and
    consumes the [IDENTIFIER]{.title-ref} token.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} if neither [MAIN]{.title-ref}
    nor [IDENTIFIER]{.title-ref} is found.</li>
<li>Consumes the [LPAREN]{.title-ref} token.</li>
<li>Parses the parameters using [parse_parameters()]{.title-ref}.</li>
<li>Consumes the [RPAREN]{.title-ref} token.</li>
<li>Consumes the [LBRACE]{.title-ref} token.</li>
<li>Parses the function body using [parse_body()]{.title-ref}.</li>
<li>Consumes the [RBRACE]{.title-ref} token.</li>
<li>Returns a [FunctionNode]{.title-ref} with the return type,
    function name, parameters, and body.</li>
</ul>
</li>
</ul>
<h2 id="parse_body-method">parse_body Method</h2>
<p>| <strong>Description:</strong>
| Parses the body of a function, handling various statements such as
  [if]{.title-ref}, [for]{.title-ref}, [return]{.title-ref}, and
  assignments or function calls.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_body(self)`:<ul>
<li>Initializes an empty list [body]{.title-ref}.</li>
<li>Iterates through tokens until [RBRACE]{.title-ref} or
    [EOF]{.title-ref} is encountered:<ul>
<li>If the current token is [IF]{.title-ref}, parses an
    [if]{.title-ref} statement and appends it to
    [body]{.title-ref}.</li>
<li>If the current token is [FOR]{.title-ref}, parses a
    [for]{.title-ref} loop and appends it to [body]{.title-ref}.</li>
<li>If the current token is [RETURN]{.title-ref}, parses a
    [return]{.title-ref} statement and appends it to
    [body]{.title-ref}.</li>
<li>If the current token is a type or identifier
    ([VECTOR]{.title-ref}, [IDENTIFIER]{.title-ref},
    [FLOAT]{.title-ref}, [INT]{.title-ref}), parses an
    assignment or function call and appends it to
    [body]{.title-ref}.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} for unexpected tokens.</li>
<li>Returns the list [body]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_parameters-method">parse_parameters Method</h2>
<p>| <strong>Description:</strong>
| Parses the parameters of a function, handling multiple parameters
  separated by commas.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_parameters(self)`:<ul>
<li>Initializes an empty list [params]{.title-ref}.</li>
<li>If the current token is not [RPAREN]{.title-ref}, parses the
    first parameter and appends it to [params]{.title-ref}.</li>
<li>Iterates through tokens while the current token is `COMMA`:<ul>
<li>Consumes the [COMMA]{.title-ref} token.</li>
<li>Parses the next parameter and appends it to
    [params]{.title-ref}.</li>
</ul>
</li>
<li>Returns the list [params]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_parameter-method">parse_parameter Method</h2>
<p>| <strong>Description:</strong>
| Parses a single parameter, handling the parameter type and name.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_parameter(self)`:<ul>
<li>Parses the parameter type using [parse_type()]{.title-ref}.</li>
<li>Stores the parameter name from the current token.</li>
<li>Consumes the [IDENTIFIER]{.title-ref} token.</li>
<li>Returns a tuple [(param_type, param_name)]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_type-method">parse_type Method</h2>
<p>| <strong>Description:</strong>
| Parses the type of a variable or function return type from the tokens.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_type(self)`:<ul>
<li>Checks if the current token is `VOID`:<ul>
<li>If true, consumes the [VOID]{.title-ref} token and returns
    [\"void\"]{.title-ref}.</li>
</ul>
</li>
<li>Checks if the current token is one of the predefined types
    ([VECTOR]{.title-ref}, [FLOAT]{.title-ref}, [INT]{.title-ref},
    [MATRIX]{.title-ref}, [BOOLEAN]{.title-ref},
    [SAMPLER2D]{.title-ref}):<ul>
<li>If true, stores the type name, consumes the token, and
    returns the type name.</li>
</ul>
</li>
<li>Checks if the current token is `IDENTIFIER`:<ul>
<li>If true, stores the type name, consumes the
    [IDENTIFIER]{.title-ref} token, and returns the type name.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} for unexpected type tokens.</li>
</ul>
</li>
</ul>
<h2 id="parse_arguments-method">parse_arguments Method</h2>
<p>| <strong>Description:</strong>
| Parses the arguments of a function call, handling multiple arguments
  separated by commas.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_arguments(self)`:<ul>
<li>Initializes an empty list [args]{.title-ref}.</li>
<li>Iterates through tokens until [RPAREN]{.title-ref} is
    encountered:<ul>
<li>Parses an expression and appends it to [args]{.title-ref}.</li>
<li>If the current token is [COMMA]{.title-ref}, consumes it.</li>
</ul>
</li>
<li>Returns the list [args]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_update-method">parse_update Method</h2>
<p>| <strong>Description:</strong>
| Parses an update statement, handling various forms of increments,
  decrements, and assignments.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>`parse_update(self)`:<ul>
<li>If the current token is `IDENTIFIER`:<ul>
<li>Stores the identifier name and consumes the
    [IDENTIFIER]{.title-ref} token.</li>
<li>Checks for [POST_INCREMENT]{.title-ref} or
    [POST_DECREMENT]{.title-ref} and returns a
    [UnaryOpNode]{.title-ref}.</li>
<li>Checks for assignment operators ([EQUALS]{.title-ref},
    [ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},
    [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}):</li>
<li>Consumes the operator, parses the expression, and returns an
    [AssignmentNode]{.title-ref} or [BinaryOpNode]{.title-ref}.</li>
</ul>
</li>
<li>If the current token is [PRE_INCREMENT]{.title-ref} or
    `PRE_DECREMENT`:<ul>
<li>Consumes the operator and the [IDENTIFIER]{.title-ref}
    token, and returns a [UnaryOpNode]{.title-ref}.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} for unexpected tokens or
    missing identifiers.</li>
</ul>
</li>
</ul>
<h2 id="parse_assignment-method">parse_assignment Method</h2>
<p>| <strong>Description:</strong>
| Parses an assignment statement, handling the variable name, assignment
  operator, and expression.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_assignment(self)`:<ul>
<li>Stores the variable name from the current token and consumes the
    [IDENTIFIER]{.title-ref} token.</li>
<li>Consumes the [EQUALS]{.title-ref} token.</li>
<li>Parses the expression and stores it in [expr]{.title-ref}.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
<li>Returns an [AssignmentNode]{.title-ref} with the variable name
    and expression.</li>
</ul>
</li>
</ul>
<h2 id="parse_function_call_or_identifier-method">parse_function_call_or_identifier Method</h2>
<p>| <strong>Description:</strong>
| Parses a function call or an identifier, handling the function name
  and its arguments or member access.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>Checks if the current token is `VECTOR`:<ul>
<li>If true, stores the function name and consumes the
    [VECTOR]{.title-ref} token.</li>
<li>Otherwise, stores the function name and consumes the
    [IDENTIFIER]{.title-ref} token.</li>
</ul>
</li>
<li>If the next token is [LPAREN]{.title-ref}, calls
    [parse_function_call]{.title-ref} with the function name.</li>
<li>If the next token is [DOT]{.title-ref}, calls
    [parse_member_access]{.title-ref} with the function name.</li>
<li>Returns a [VariableNode]{.title-ref} with the function name if no
    further tokens are found.</li>
</ul>
<h2 id="parse_additive-method">parse_additive Method</h2>
<p>| <strong>Description:</strong>
| Parses an additive expression, handling addition and subtraction
  operations.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_additive(self)`:<ul>
<li>Parses the left-hand side of the expression using
    [parse_multiplicative()]{.title-ref}.</li>
<li>Iterates through tokens while the current token is
    [PLUS]{.title-ref} or `MINUS`:<ul>
<li>Stores the operator and consumes the token.</li>
<li>Parses the right-hand side of the expression using
    [parse_multiplicative()]{.title-ref}.</li>
</ul>
</li>
<li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,
    operator, and right-hand side.</li>
<li>Returns the final [BinaryOpNode]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_primary-method">parse_primary Method</h2>
<p>| <strong>Description:</strong>
| Parses a primary expression, handling various types of tokens such as
  negation, identifiers, numbers, and parenthesized expressions.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_primary(self)`:<ul>
<li>Checks if the current token is `MINUS`:<ul>
<li>Consumes the [MINUS]{.title-ref} token.</li>
<li>Recursively calls [parse_primary()]{.title-ref} to handle
    the negation.</li>
<li>Returns a [UnaryOpNode]{.title-ref} with the negation
    operator and the parsed value.</li>
</ul>
</li>
<li>Checks if the current token is an [IDENTIFIER]{.title-ref},
    [VECTOR]{.title-ref}, or `FLOAT`:<ul>
<li>Calls [parse_function_call_or_identifier()]{.title-ref} to
    handle the token.</li>
</ul>
</li>
<li>Checks if the current token is `NUMBER`:<ul>
<li>Stores the token value.</li>
<li>Consumes the [NUMBER]{.title-ref} token.</li>
<li>Returns the stored value.</li>
</ul>
</li>
<li>Checks if the current token is `LPAREN`:<ul>
<li>Consumes the [LPAREN]{.title-ref} token.</li>
<li>Calls [parse_expression()]{.title-ref} to parse the
    expression inside the parentheses.</li>
<li>Consumes the [RPAREN]{.title-ref} token.</li>
<li>Returns the parsed expression.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} if the token is unexpected.</li>
</ul>
</li>
</ul>
<h2 id="parse_multiplicative-method">parse_multiplicative Method</h2>
<p>| <strong>Description:</strong>
| Parses a multiplicative expression, handling multiplication and
  division operations.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_multiplicative(self)`:<ul>
<li>Parses the left-hand side of the expression using
    [parse_primary()]{.title-ref}.</li>
<li>Iterates through tokens while the current token is
    [MULTIPLY]{.title-ref} or `DIVIDE`:<ul>
<li>Stores the operator and consumes the token.</li>
<li>Parses the right-hand side of the expression using
    [parse_primary()]{.title-ref}.</li>
</ul>
</li>
<li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,
    operator, and right-hand side.</li>
<li>Returns the final [BinaryOpNode]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_expression-method">parse_expression Method</h2>
<p>| <strong>Description:</strong>
| Parses a general expression, handling additive expressions, comparison
  operators, logical operators, and ternary conditional expressions.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_expression(self)`:<ul>
<li>Parses the left-hand side of the expression using
    [parse_additive()]{.title-ref}.</li>
<li>Iterates through tokens while the current token is a comparison
    or logical operator ([LESS_THAN]{.title-ref},
    [GREATER_THAN]{.title-ref}, [LESS_EQUAL]{.title-ref},
    [GREATER_EQUAL]{.title-ref}, [EQUAL]{.title-ref},
    [NOT_EQUAL]{.title-ref}, [AND]{.title-ref}, [OR]{.title-ref}):<ul>
<li>Stores the operator and consumes the token.</li>
<li>Parses the right-hand side of the expression using
    [parse_additive()]{.title-ref}.</li>
</ul>
</li>
<li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,
    operator, and right-hand side.</li>
<li>Checks if the current token is [QUESTION]{.title-ref} for a
    ternary conditional expression:<ul>
<li>Consumes the [QUESTION]{.title-ref} token.</li>
<li>Parses the true expression using
    [parse_expression()]{.title-ref}.</li>
<li>Consumes the [COLON]{.title-ref} token.</li>
<li>Parses the false expression using
    [parse_expression()]{.title-ref}.</li>
<li>Creates a [TernaryOpNode]{.title-ref} with the condition,
    true expression, and false expression.</li>
</ul>
</li>
<li>Returns the final expression node.</li>
</ul>
</li>
</ul>
<h2 id="parse_return-method">parse_return Method</h2>
<p>| <strong>Description:</strong>
| Parses a return statement, handling the return keyword and the
  associated expression.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_return(self)`:<ul>
<li>Consumes the [RETURN]{.title-ref} token.</li>
<li>Parses the expression to be returned using
    [parse_expression()]{.title-ref}.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
<li>Returns a [ReturnNode]{.title-ref} with the parsed expression.</li>
</ul>
</li>
</ul>
<h2 id="parse_else_if_chain-method">parse_else_if_chain Method</h2>
<p>| <strong>Description:</strong>
| Parses a chain of [else if]{.title-ref} and [else]{.title-ref}
  statements, handling their conditions and bodies.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_else_if_chain(self)`:<ul>
<li>Initializes an empty list [else_if_chain]{.title-ref} and sets
    [else_body]{.title-ref} to [None]{.title-ref}.</li>
<li>Iterates through tokens while the current token is
    [ELSE_IF]{.title-ref} or `ELSE`:<ul>
<li>If the current token is `ELSE_IF`:<ul>
<li>Consumes the [ELSE_IF]{.title-ref} token.</li>
<li>Consumes the [LPAREN]{.title-ref} token.</li>
<li>Parses the [elif]{.title-ref} condition using
    [parse_expression()]{.title-ref}.</li>
<li>Consumes the [RPAREN]{.title-ref} token.</li>
<li>Consumes the [LBRACE]{.title-ref} token.</li>
<li>Parses the [elif]{.title-ref} body using
    [parse_body()]{.title-ref}.</li>
<li>Consumes the [RBRACE]{.title-ref} token.</li>
<li>Appends the condition and body as a tuple to
    [else_if_chain]{.title-ref}.</li>
</ul>
</li>
<li>If the current token is `ELSE`:<ul>
<li>Consumes the [ELSE]{.title-ref} token.</li>
<li>Consumes the [LBRACE]{.title-ref} token.</li>
<li>Parses the [else]{.title-ref} body using
    [parse_body()]{.title-ref}.</li>
<li>Consumes the [RBRACE]{.title-ref} token.</li>
<li>Breaks the loop.</li>
</ul>
</li>
</ul>
</li>
<li>Returns the [else_if_chain]{.title-ref} and
    [else_body]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_if-method">parse_if Method</h2>
<p>| <strong>Description:</strong>
| Parses an [if]{.title-ref} statement, handling the condition, body,
  and any associated [else if]{.title-ref} and [else]{.title-ref}
  statements.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_if(self)`:<ul>
<li>Consumes the [IF]{.title-ref} token.</li>
<li>Consumes the [LPAREN]{.title-ref} token.</li>
<li>Parses the condition using [parse_expression()]{.title-ref}.</li>
<li>Consumes the [RPAREN]{.title-ref} token.</li>
<li>Consumes the [LBRACE]{.title-ref} token.</li>
<li>Parses the body of the [if]{.title-ref} statement using
    [parse_body()]{.title-ref}.</li>
<li>Consumes the [RBRACE]{.title-ref} token.</li>
<li>Parses any [else if]{.title-ref} and [else]{.title-ref}
    statements using [parse_else_if_chain()]{.title-ref}.</li>
<li>Returns an [IfNode]{.title-ref} with the condition, body, [else
    if]{.title-ref} chain, and [else]{.title-ref} body.</li>
</ul>
</li>
</ul>
<h2 id="parse_for-method">parse_for Method</h2>
<p>| <strong>Description:</strong>
| Parses a [for]{.title-ref} loop, handling the initialization,
  condition, update, and body of the loop.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_for(self)`:<ul>
<li>Consumes the [FOR]{.title-ref} token.</li>
<li>Consumes the [LPAREN]{.title-ref} token.</li>
<li>Parses the initialization statement using
    [parse_assignment()]{.title-ref}.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
<li>Parses the loop condition using
    [parse_expression()]{.title-ref}.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
<li>Parses the loop update using [parse_expression()]{.title-ref}.</li>
<li>Consumes the [RPAREN]{.title-ref} token.</li>
<li>Consumes the [LBRACE]{.title-ref} token.</li>
<li>Parses the loop body using [parse_body()]{.title-ref}.</li>
<li>Consumes the [RBRACE]{.title-ref} token.</li>
<li>Returns a [ForNode]{.title-ref} with the initialization,
    condition, update, and body.</li>
</ul>
</li>
</ul>
<h2 id="parse_body-method_1">parse_body Method</h2>
<p>| <strong>Description:</strong>
| Parses the body of a function or a block of statements, handling
  different types of statements such as assignments, expressions,
  returns, and control flow.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_body(self)`:<ul>
<li>Initializes an empty list [body]{.title-ref}.</li>
<li>Iterates through tokens while the current token is not
    [RBRACE]{.title-ref} or `EOF`:<ul>
<li>Calls [parse_statement()]{.title-ref} to parse each
    statement.</li>
<li>Appends each parsed statement to the [body]{.title-ref}.</li>
</ul>
</li>
<li>Returns the list [body]{.title-ref}.</li>
</ul>
</li>
</ul>
<h2 id="parse_statement-method">parse_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses a single statement, handling assignments, expressions, returns,
  [if]{.title-ref} statements, [for]{.title-ref} loops, and
  [break]{.title-ref} statements.</p>
<p><strong>Parameters:</strong></p>
<p>:   -   `self`: The instance of the class containing the code and
        tokens.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`parse_statement(self)`:<ul>
<li>Checks if the current token is [IDENTIFIER]{.title-ref} and the
    next token is `EQUALS`:<ul>
<li>Calls [parse_assignment()]{.title-ref} to handle the
    assignment.</li>
</ul>
</li>
<li>Checks if the current token is `RETURN`:<ul>
<li>Calls [parse_return()]{.title-ref} to handle the return
    statement.</li>
</ul>
</li>
<li>Checks if the current token is `IF`:<ul>
<li>Calls [parse_if()]{.title-ref} to handle the
    [if]{.title-ref} statement.</li>
</ul>
</li>
<li>Checks if the current token is `FOR`:<ul>
<li>Calls [parse_for()]{.title-ref} to handle the
    [for]{.title-ref} loop.</li>
</ul>
</li>
<li>Checks if the current token is `BREAK`:<ul>
<li>Consumes the [BREAK]{.title-ref} token.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
</ul>
</li>
<li>Checks if the current token is an expression:<ul>
<li>Calls [parse_expression()]{.title-ref} to handle the
    expression.</li>
<li>Consumes the [SEMICOLON]{.title-ref} token.</li>
</ul>
</li>
<li>Raises a [SyntaxError]{.title-ref} if the token is unexpected.</li>
</ul>
</li>
</ul>
<h1 id="opengl-codegen_1">OpenGL Codegen</h1>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="generate-method">generate Method</h2>
<p><strong>Description:</strong> Generates shader code from the abstract syntax tree
(AST).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>[ast (ASTNode)]{.title-ref} -- The abstract syntax tree representing
    the shader code.</li>
</ul>
<p><strong>Returns:</strong> - [str]{.title-ref} -- The generated shader code as a
string, or an empty string if the [ast]{.title-ref} is not a
[ShaderNode]{.title-ref}.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>
<p>`generate(self, ast)[: - Checks if the `ast]{.title-ref} is an instance of [ShaderNode]{.title-ref}.</p>
<p>:   -   Sets [self.current_shader]{.title-ref} to the
        [ast]{.title-ref}.
    -   Calls [generate_shader(ast)]{.title-ref} to generate the
        shader code.
    -   Returns an empty string if the [ast]{.title-ref} is not a
        [ShaderNode]{.title-ref}.</p>
</li>
</ul>
<h2 id="generate_shader-method">generate_shader Method</h2>
<p><strong>Description:</strong> Generates the shader code for both vertex and fragment
sections from the given node.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>[node (ShaderNode)]{.title-ref} -- The node representing the shader
    structure.</li>
</ul>
<p><strong>Returns:</strong> - [str]{.title-ref} -- The generated shader code for the
vertex and fragment sections.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>
<p>`generate_shader(self, node)[: - Sets up the shader by initializing `shader_inputs]{.title-ref}, [shader_outputs]{.title-ref}, and [uniforms]{.title-ref} from the node.</p>
<p>:   -   Initializes the shader code with [shader main
        {]{.title-ref}.</p>
<pre><code>-

    Generates the vertex shader section:

    :   -   Sets [self.vertex_item]{.title-ref} to
            [node.vertex_section]{.title-ref}.
        -   If [vertex_item]{.title-ref} exists:
        -   Adds the vertex section to the code.
        -   Generates layout qualifiers using
            [generate_layouts()]{.title-ref}.
        -   Adds inputs and outputs for the shader and vertex
            item.
        -   Generates uniforms using
            [generate_uniforms()]{.title-ref}.
        -   Generates functions using
            [generate_functions()]{.title-ref}.
        -   Raises a [ValueError]{.title-ref} if no vertex
            shader section is present.

-

    Generates the fragment shader section if present:

    :   -   Sets [self.fragment_item]{.title-ref} to
            [node.fragment_section]{.title-ref}.
        -   If [fragment_item]{.title-ref} exists and has layout
            qualifiers or functions:
        -   Adds the fragment section to the code.
        -   Generates layout qualifiers using
            [generate_layouts()]{.title-ref}.
        -   Adds inputs and outputs for the fragment item.
        -   Generates uniforms using
            [generate_uniforms()]{.title-ref}.
        -   Generates functions using
            [generate_functions()]{.title-ref}.
        -   Raises a [ValueError]{.title-ref} if no fragment
            shader section is present.

-   Closes the shader code with [}]{.title-ref}.

-   Returns the generated shader code.
</code></pre>
</li>
</ul>
<h2 id="generate_uniforms-method">generate_uniforms Method</h2>
<p><strong>Description:</strong> Generates the uniform declarations for the shader.</p>
<p><strong>Parameters:</strong> - `self`: The instance of the class containing the
code and tokens.</p>
<p><strong>Returns:</strong> - [str]{.title-ref} -- The generated uniform declarations.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>
<p>`generate_uniforms(self)[: - Initializes an empty list `uniform_lines]{.title-ref}.</p>
<p>:   -   Iterates through each uniform in `self.uniforms`:
    -   Appends the uniform declaration to
        [uniform_lines]{.title-ref}.
    -   Joins the list into a single string with newline characters
        and returns it.</p>
</li>
</ul>
<h2 id="generate_layouts-method">generate_layouts Method</h2>
<p><strong>Description:</strong> Generates the layout qualifiers for the shader,
handling both input and output types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>[layouts (list of LayoutNode)]{.title-ref} -- A list of layout
    objects, each containing [io_type]{.title-ref}, [dtype]{.title-ref},
    and [name]{.title-ref}.</li>
</ul>
<p><strong>Returns:</strong> - [str]{.title-ref} -- The generated layout qualifiers.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>`generate_layouts(self, layouts)`:<ul>
<li>Initializes an empty string [code]{.title-ref}.</li>
<li>Iterates through each layout in `layouts`:</li>
<li>Checks if the layout's [io_type]{.title-ref} is `input`:</li>
<li>Appends the input layout declaration to [code]{.title-ref}.</li>
<li>Checks if the layout's [io_type]{.title-ref} is `output`:</li>
<li>Appends the output layout declaration to [code]{.title-ref}.</li>
<li>Returns the generated code string.</li>
</ul>
</li>
</ul>
<h2 id="generate_functions-method">generate_functions Method</h2>
<p><strong>Description:</strong> Generates the function definitions for the shader,
handling both vertex and fragment shader types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>[functions (list[FunctionNode])]{.title-ref} -- A list of function
    nodes, each representing a function in the shader.</li>
<li>[shader_type (str)]{.title-ref} -- The type of shader
    ([vertex]{.title-ref} or [fragment]{.title-ref}).</li>
</ul>
<p><strong>Returns:</strong> - [str]{.title-ref} -- The generated function definitions.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li>
<p>`generate_functions(self, functions, shader_type)[: - Initializes an empty string `code]{.title-ref}.</p>
<p>:   -   Checks if [shader_type]{.title-ref} is either
        [vertex]{.title-ref} or [fragment]{.title-ref}.
    -   Iterates through each [function_node]{.title-ref} in
        `functions`:
        -   Generates the parameter list by mapping each parameter's
            type and name.
        -   Generates the function header with the return type,
            function name, and parameters.
        -   Generates the function body by iterating through each
            statement in [function_node.body]{.title-ref} and
            calling [generate_statement()]{.title-ref}.
        -   Closes the function definition.
    -   Returns the generated code string.</p>
</li>
</ul>
<h2 id="generate_statement-method">generate_statement Method</h2>
<p><strong>Description:</strong> Generates the code for a given statement, handling
various types of statements such as variable declarations, assignments,
control flow statements, and expressions.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>`stmt`: The statement node to be generated.</li>
<li>`shader_type`: The type of shader ([vertex]{.title-ref} or
    [fragment]{.title-ref}).</li>
<li>`indent`: The indentation level for the generated code (default is
    0).</li>
</ul>
<p><strong>Method Details:</strong></p>
<ul>
<li>
<p>`generate_statement(self, stmt, shader_type, indent=0)[: - Initializes the indentation string `indent_str]{.title-ref} based on the [indent]{.title-ref} level.</p>
<p>:   -   Checks the type of [stmt]{.title-ref} and generates the
        corresponding code:
    -   If [stmt]{.title-ref} is a `VariableNode`:
    -   Returns the variable declaration with the mapped type and
        name.
    -   If [stmt]{.title-ref} is an `AssignmentNode`:
    -   Returns the assignment statement generated by
        [generate_assignment()]{.title-ref}.
    -   If [stmt]{.title-ref} is an `IfNode`:
    -   Returns the [if]{.title-ref} statement generated by
        [generate_if()]{.title-ref}.
    -   If [stmt]{.title-ref} is a `ForNode`:
    -   Returns the [for]{.title-ref} loop generated by
        [generate_for()]{.title-ref}.
    -   If [stmt]{.title-ref} is a `ReturnNode`:
    -   Returns the return statement with the generated expression.
    -   Otherwise:
    -   Returns the generated expression.
    -   Each generated statement is properly indented based on the
        [indent]{.title-ref} level.</p>
</li>
</ul>
<h2 id="generate_assignment-method">generate_assignment Method</h2>
<p><strong>Description:</strong> Generates the code for an assignment statement,
handling the left-hand side (LHS) and right-hand side (RHS) expressions.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>`self`: The instance of the class containing the code and tokens.</li>
<li>`node`: The assignment node containing the LHS and RHS
    expressions.</li>
<li>`shader_type`: The type of shader ([vertex]{.title-ref} or
    [fragment]{.title-ref}).</li>
</ul>
<p><strong>Method Details:</strong></p>
<ul>
<li>`generate_assignment(self, node, shader_type)`:<ul>
<li>Generates the LHS expression using
    [generate_expression(node.name, shader_type)]{.title-ref}.</li>
<li>Generates the RHS expression using
    [generate_expression(node.value, shader_type)]{.title-ref}.</li>
<li>Returns the assignment statement in the format [lhs =
    rhs]{.title-ref}.</li>
</ul>
</li>
</ul>
<p>---</p>
<h2 id="generate_if-method">generate_if Method</h2>
<p><strong>Description:</strong> Generates code for an [if]{.title-ref} statement,
including optional [else if]{.title-ref} and [else]{.title-ref} blocks,
formatted with the specified indentation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (IfNode): An [IfNode]{.title-ref} instance
    representing the [if]{.title-ref} statement and its associated
    conditions and blocks.</li>
<li>[shader_type]{.title-ref} (str): Specifies the type of shader being
    generated (e.g., [\"vertex\"]{.title-ref} or
    [\"fragment\"]{.title-ref}), affecting how certain constructs are
    handled.</li>
<li>[indent]{.title-ref} (int): The current level of indentation to
    apply in the generated code.</li>
</ul>
<p><strong>Returns:</strong> - `str`: A string containing the generated code for the
[if]{.title-ref} statement, properly formatted with indentation.</p>
<p><strong>Method Details:</strong> - Constructs the [if]{.title-ref} statement with its
condition and corresponding body. - Handles chained [else
if]{.title-ref} conditions and their bodies. - Includes an optional
[else]{.title-ref} block if provided. - Ensures that code blocks are
correctly indented based on the [indent]{.title-ref} parameter.</p>
<p>---</p>
<h2 id="generate_else_if-method">generate_else_if Method</h2>
<p><strong>Description:</strong> Generates code for an [else if]{.title-ref} block
within an [if]{.title-ref} statement, formatted with the specified
indentation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (IfNode): An [IfNode]{.title-ref} instance
    representing the [else if]{.title-ref} condition and its associated
    body.</li>
<li>[shader_type]{.title-ref} (str): Specifies the type of shader being
    generated (e.g., [\"vertex\"]{.title-ref} or
    [\"fragment\"]{.title-ref}), influencing the handling of specific
    constructs.</li>
<li>[indent]{.title-ref} (int): The level of indentation to apply in the
    generated code.</li>
</ul>
<p><strong>Returns:</strong> - `str`: A string containing the generated code for the
[else if]{.title-ref} block, properly formatted with indentation.</p>
<p><strong>Method Details:</strong> - Constructs the [else if]{.title-ref} block with
its condition and corresponding body. - Ensures that the code within the
[else if]{.title-ref} block is correctly indented based on the
[indent]{.title-ref} parameter.</p>
<p>---</p>
<h2 id="generate_for-method">generate_for Method</h2>
<p><strong>Description:</strong> Generates code for a [for]{.title-ref} loop construct,
including initialization, condition, update, and body, formatted with
the specified indentation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (ForNode): An instance of [ForNode]{.title-ref}
    representing the [for]{.title-ref} loop's components such as
    initialization, condition, update, and body.</li>
<li>[shader_type]{.title-ref} (str): Specifies the type of shader being
    generated (e.g., [\"vertex\"]{.title-ref} or
    [\"fragment\"]{.title-ref}), affecting the syntax and semantics of
    the loop.</li>
<li>[indent]{.title-ref} (int): The level of indentation to apply to the
    generated code.</li>
</ul>
<p><strong>Returns:</strong> - `str`: A string containing the generated code for the
[for]{.title-ref} loop, properly formatted with indentation.</p>
<p><strong>Method Details:</strong> - <strong>Initialization (`init`)</strong>: Generates the
initialization statement for the [for]{.title-ref} loop, stripping
trailing semicolons. - <strong>Condition (`condition`)</strong>: Generates the
loop's condition expression. - <strong>Update (`update`)</strong>: Generates the
update statement for the [for]{.title-ref} loop, stripping trailing
semicolons. - <strong>Body</strong>: Generates the code for the body of the
[for]{.title-ref} loop, applying additional indentation.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 10; i++) {
    // Loop body
}
</code></pre>
<p>---</p>
<h2 id="generate_update-method">generate_update Method</h2>
<p><strong>Description:</strong> Generates the code for the update part of a
[for]{.title-ref} loop, handling various types of expressions such as
assignments, unary operations, and binary operations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[node]{.title-ref} (ASTNode): An instance of
    [AssignmentNode]{.title-ref}, [UnaryOpNode]{.title-ref}, or
    [BinaryOpNode]{.title-ref} representing the update expression in the
    [for]{.title-ref} loop.</li>
<li>[shader_type]{.title-ref} (str): Specifies the type of shader being
    generated (e.g., [\"vertex\"]{.title-ref} or
    [\"fragment\"]{.title-ref}), which can affect how the update
    expression is formatted.</li>
</ul>
<p><strong>Returns:</strong> - `str`: A string containing the generated code for the
update expression.</p>
<p><strong>Method Details:</strong></p>
<ul>
<li><strong>AssignmentNode</strong>: Handles both simple assignments and
    increments/decrements.<ul>
<li>If the value is a [UnaryOpNode]{.title-ref}, it generates
    increment or decrement operations.</li>
<li>Otherwise, it generates a standard assignment.</li>
</ul>
</li>
<li><strong>UnaryOpNode</strong>: Generates pre-increment, post-increment,
    pre-decrement, post-decrement, or unary operations based on the
    operation type.</li>
<li><strong>BinaryOpNode</strong>: Handles binary operations and maps them to
    appropriate operators using [map_operator]{.title-ref}.</li>
<li><strong>Error Handling</strong>: Raises a [ValueError]{.title-ref} for
    unsupported node types.</li>
</ul>
<p>---</p>
<h2 id="generate_expression-method">generate_expression Method</h2>
<p><strong>Description:</strong> Generates code for various types of expressions used in
shader programming. This includes translating simple strings, handling
variables, binary and unary operations, function calls, ternary
operations, and member accesses.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[expr]{.title-ref} (ASTNode): An instance of a specific type of
    expression node, such as [VariableNode]{.title-ref},
    [BinaryOpNode]{.title-ref}, etc.</li>
<li>[shader_type]{.title-ref} (str): Indicates the type of shader (e.g.,
    [\"vertex\"]{.title-ref} or [\"fragment\"]{.title-ref}), which might
    influence how the expressions are formatted.</li>
</ul>
<p><strong>Returns:</strong> - `str`: A string containing the generated code for the
expression.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li><strong>str</strong>: Uses [translate_expression]{.title-ref} to handle basic
    string translation or identifiers.</li>
<li><strong>VariableNode</strong>: Generates a variable declaration or usage based on
    its type and name.</li>
<li><strong>BinaryOpNode</strong>: Generates binary operations by recursively
    generating code for left and right operands and mapping the
    operator.</li>
<li><strong>FunctionCallNode</strong>: Generates function calls, including the
    function name and arguments.</li>
<li><strong>UnaryOpNode</strong>: Handles unary operations, including pre-increment
    and pre-decrement.</li>
<li><strong>TernaryOpNode</strong>: Generates ternary conditional expressions.</li>
<li><strong>MemberAccessNode</strong>: Handles member accesses (e.g.,
    object.property).</li>
<li><strong>Default Case</strong>: Converts any other node types to their string
    representations.</li>
</ol>
<p>---</p>
<h2 id="translate_expression-method">translate_expression Method</h2>
<p><strong>Description:</strong> Translates a given expression (identifier) into its
corresponding name based on the shader type. It checks if the expression
matches any of the inputs or outputs for the current shader item and
returns the appropriate name.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[expr]{.title-ref} (str): The identifier or expression to be
    translated.</li>
<li>[shader_type]{.title-ref} (str): The type of shader
    ([\"vertex\"]{.title-ref} or [\"fragment\"]{.title-ref}) which
    determines which item lists to check.</li>
</ul>
<p><strong>Returns:</strong> - `str`: The translated name if a match is found,
otherwise the original expression.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li><strong>Vertex Shader Type:</strong><ul>
<li>If [shader_type]{.title-ref} is [\"vertex\"]{.title-ref} and
    [self.vertex_item]{.title-ref} is not [None]{.title-ref}, it
    checks the inputs and outputs of [self.vertex_item]{.title-ref}.</li>
<li>If [expr]{.title-ref} matches any input or output names, it
    returns the matched name.</li>
<li>If no match is found, it returns the original expression.</li>
</ul>
</li>
<li><strong>Fragment Shader Type:</strong><ul>
<li>If [shader_type]{.title-ref} is [\"fragment\"]{.title-ref} and
    [self.fragment_item]{.title-ref} is not [None]{.title-ref}, it
    checks the inputs and outputs of
    [self.fragment_item]{.title-ref}.</li>
<li>If [expr]{.title-ref} matches any input or output names, it
    returns the matched name.</li>
<li>If no match is found, it returns the original expression.</li>
</ul>
</li>
<li><strong>Default Return:</strong><ul>
<li>If the shader type is not recognized or no match is found, the
    method returns the expression as is.</li>
</ul>
</li>
</ol>
<p>---</p>
<h2 id="map_type-method">map_type Method</h2>
<p><strong>Description:</strong> Translates internal type representations into their
corresponding shader types using a predefined mapping.</p>
<p><strong>Parameters:</strong> - [vtype]{.title-ref} (str): The internal type
representation to be mapped.</p>
<p><strong>Returns:</strong> - `str`: The corresponding shader type based on the
mapping, or the original type if no mapping is found.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li>
<p><strong>Type Mapping:</strong></p>
<ul>
<li>The method uses a dictionary called [type_map]{.title-ref} to
    define the mappings:</li>
</ul>
<p><code>cpp
vec3 maps to vec3
vec4 maps to vec4
float maps to float
int maps to int
bool maps to bool</code></p>
<ul>
<li>The [type_map]{.title-ref} dictionary includes common GLSL
    types.</li>
</ul>
</li>
<li>
<p><strong>Lookup:</strong></p>
<ul>
<li>The method attempts to find the [vtype]{.title-ref} in the
    [type_map]{.title-ref} dictionary.</li>
<li>If [vtype]{.title-ref} is found, it returns the corresponding
    shader type.</li>
<li>If [vtype]{.title-ref} is not found in the dictionary, it
    returns the original [vtype]{.title-ref}.</li>
</ul>
</li>
</ol>
<p>---</p>
<h2 id="map_operator-method">map_operator Method</h2>
<p><strong>Description:</strong> Maps internal operator representations to their
corresponding shader language operators using a predefined mapping.</p>
<p><strong>Parameters:</strong> - [op]{.title-ref} (str): The internal operator
representation to be mapped.</p>
<p><strong>Returns:</strong> - `str`: The corresponding shader operator based on the
mapping, or the original operator if no mapping is found.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li>
<p><strong>Operator Mapping:</strong></p>
<ul>
<li>The method uses a dictionary called [operator_map]{.title-ref}
    to define the mappings:</li>
</ul>
<p><code>cpp
+ maps to +
- maps to -
* maps to *
/ maps to /
== maps to ==
!= maps to !=</code></p>
<ul>
<li>The [operator_map]{.title-ref} dictionary includes common GLSL
    operators.</li>
</ul>
</li>
<li>
<p><strong>Lookup:</strong></p>
<ul>
<li>The method attempts to find the [op]{.title-ref} in the
    [operator_map]{.title-ref} dictionary.</li>
<li>If [op]{.title-ref} is found, it returns the corresponding
    shader operator.</li>
<li>If [op]{.title-ref} is not found in the dictionary, it returns
    the original operator.</li>
</ul>
</li>
</ol>
<p>---</p>
<p>This format should provide a clear and organized documentation for each
method, making it easier for users to understand and use the methods
effectively.</p>
<h1 id="mojo">Mojo</h1>
<h1 id="mojo-ast">Mojo AST</h1>
<h2 id="ternaryopnode-class-2">TernaryOpNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a ternary conditional operation in an abstract syntax tree
  (AST). This node type models the conditional expression and its two
  possible outcomes, facilitating the generation of conditional code in
  shader programming.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [condition]{.title-ref} (MojoASTNode): The condition expression
        that determines which of the two outcomes to choose.
    -   [true_expr]{.title-ref} (MojoASTNode): The expression to be
        evaluated and returned if the condition is true.
    -   [false_expr]{.title-ref} (MojoASTNode): The expression to be
        evaluated and returned if the condition is false.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`TernaryOpNode]{.title-ref} instance, useful for debugging
    :   and logging.
        -   **Returns**: A string in the format:

        ``` python
        ```

        \"TernaryOpNode(condition={self.condition},
        true_expr={self.true_expr}, false_expr={self.false_expr})\"
</code></pre>
<h2 id="shadernode-class-2">ShaderNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a shader program in an abstract syntax tree (AST),
  containing a collection of functions that define the shader's behavior
  and structure.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [functions]{.title-ref} (list of MojoASTNode): A list of
        function nodes ([MojoASTNode]{.title-ref}) that are part of the
        shader. These functions define the various operations and logic
        within the shader.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ShaderNode]{.title-ref} instance, useful for debugging
    :   and logging.
        -   **Returns**: \`str\`: A string representation of the
            [ShaderNode]{.title-ref} in the format:

        ``` python
        ```

        \"ShaderNode(functions={self.functions})\"
</code></pre>
<h2 id="structnode-class">StructNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a structure definition in an abstract syntax tree (AST). It
  encapsulates the name of the structure and its members, which define
  the structure's layout and data types.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [name]{.title-ref} (str): The name of the structure.
    -   [members]{.title-ref} (list of Tuple[str, str]): A list of
        tuples where each tuple represents a member of the structure.
        Each tuple contains the member's name and its data type.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`StructNode]{.title-ref} instance, which is useful for
    :   debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [StructNode]{.title-ref} in the format:

        ``` python
        ```

        \"StructNode(name={self.name}, members={self.members})\"
</code></pre>
<h2 id="functionnode-class-2">FunctionNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a function definition in an abstract syntax tree (AST). It
  includes the function's attributes, return type, name, parameters,
  body, and any additional attributes.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [qualifier]{.title-ref} (str): Specifies any qualifiers for the
        function, such as [static]{.title-ref}, [inline]{.title-ref}, or
        [extern]{.title-ref}.
    -   [return_type]{.title-ref} (str): The data type that the function
        returns.
    -   [name]{.title-ref} (str): The name of the function.
    -   [params]{.title-ref} (list of Tuple[str, str]): A list of
        tuples where each tuple represents a parameter of the function.
        Each tuple contains the parameter's type and name.
    -   [body]{.title-ref} (list of ASTNode): A list of statements
        representing the body of the function.
    -   [attributes]{.title-ref} (list of str, optional): A list of
        additional attributes or modifiers for the function, such as
        [const]{.title-ref}, [volatile]{.title-ref}, etc. Defaults to an
        empty list if not provided.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`FunctionNode]{.title-ref} instance, which is useful for
    :   debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [FunctionNode]{.title-ref} in the format:

        ``` python
        ```

        \"FunctionNode(qualifier={self.qualifier},
        return_type={self.return_type}, name={self.name},
        params={self.params}, body={self.body},
        attributes={self.attributes})\"
</code></pre>
<h2 id="variabledeclarationnode-class">VariableDeclarationNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a variable declaration in an abstract syntax tree (AST). It
  includes the variable's type, name, and optionally an initial value.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [var_type]{.title-ref} (str): The data type of the variable
        (e.g., [int]{.title-ref}, [float]{.title-ref},
        [vec3]{.title-ref}).
    -   [name]{.title-ref} (str): The name of the variable.
    -   [initial_value]{.title-ref} (Optional[str]): The initial value
        assigned to the variable. Defaults to [None]{.title-ref} if not
        provided.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`VariableDeclarationNode]{.title-ref} instance, which is useful for debugging and logging.

    :   -   **Returns**: \`str\`: A string representation of the
            [VariableDeclarationNode]{.title-ref} in the format:

        ``` python
        "VariableDeclarationNode(var_type={self.var_type}, name={self.name}, initial_value={self.initial_value})"
        ```
</code></pre>
<h2 id="arrayaccessnode-class">ArrayAccessNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an array access operation in an abstract syntax tree (AST).
  It includes the array being accessed and the index used for accessing
  an element.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [array]{.title-ref} (MojoASTNode): The array from which an
        element is accessed.
    -   [index]{.title-ref} (MojoASTNode): The index used to access an
        element of the array.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ArrayAccessNode]{.title-ref} instance, which is useful
    :   for debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [ArrayAccessNode]{.title-ref} in the format:

        ``` python
        ```

        \"ArrayAccessNode(array={self.array}, index={self.index})\"
</code></pre>
<h2 id="variablenode-class-2">VariableNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a variable declaration or reference in an abstract syntax
  tree (AST). It includes the variable's type, name, and optional
  attributes.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [vtype]{.title-ref} (str): The type of the variable (e.g.,
        [\"int\"]{.title-ref}, [\"float\"]{.title-ref}).
    -   [name]{.title-ref} (str): The name of the variable.
    -   [attributes]{.title-ref} (list, optional): A list of attributes
        associated with the variable. Defaults to an empty list if not
        provided.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`VariableNode]{.title-ref} instance, which is useful for
    :   debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [VariableNode]{.title-ref} in the format:

        ``` python
        ```

        \"VariableNode(vtype=\'{self.vtype}\', name=\'{self.name}\',
        attributes={self.attributes})\"
</code></pre>
<h2 id="attributenode-class">AttributeNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an attribute associated with a variable, function, or other
  elements in an abstract syntax tree (AST). Attributes are often used
  to specify metadata or additional properties.</p>
<p><strong>Constructor Parameters</strong>:</p>
<p>:   -   [name]{.title-ref} (str): The name of the attribute (e.g.,
        [\"location\"]{.title-ref}, [\"binding\"]{.title-ref}).
    -   [args]{.title-ref} (list, optional): A list of arguments for the
        attribute. Defaults to an empty list if not provided.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`AttributeNode]{.title-ref} instance, which is useful for
    :   debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [AttributeNode]{.title-ref} in the format:

        ``` python
        ```

        \"AttributeNode(name=\'{self.name}\', args={self.args})\"
</code></pre>
<h2 id="assignmentnode-class-2">AssignmentNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an assignment operation in the abstract syntax tree (AST).
  This node is used to model the assignment of a value to a variable,
  potentially with a specific operator.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [left]{.title-ref} (MojoASTNode): The left-hand side of the
        assignment, typically a variable or an array element.
    -   [right]{.title-ref} (MojoASTNode): The right-hand side of the
        assignment, representing the value to be assigned.
    -   [operator]{.title-ref} (str, optional): The assignment operator.
        Defaults to [\"=\"]{.title-ref}. Other operators like
        [\"+=\"]{.title-ref}, [\"-=\"]{.title-ref}, etc., can be used.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`AssignmentNode]{.title-ref} instance, which is useful for
    :   debugging and logging.
        -   **Returns**: \`str\`: A string representation of the
            [AssignmentNode]{.title-ref} in the format:

        ``` python
        ```

        \"AssignmentNode(left={self.left},
        operator=\'{self.operator}\', right={self.right})\"
</code></pre>
<h2 id="ifnode-class-2">IfNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an [if]{.title-ref} statement in the abstract syntax tree
  (AST). This node is used to model conditional logic with an optional
  [else]{.title-ref} block.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [condition]{.title-ref} (MojoASTNode): The condition to be
        evaluated for the [if]{.title-ref} statement. This typically
        involves a boolean expression.
    -   [if_body]{.title-ref} (list of MojoASTNode): The body of the
        [if]{.title-ref} block, containing statements to be executed if
        the condition evaluates to [True]{.title-ref}.
    -   [else_body]{.title-ref} (list of MojoASTNode, optional): The
        body of the [else]{.title-ref} block, containing statements to
        be executed if the condition evaluates to [False]{.title-ref}.
        Defaults to [None]{.title-ref} if no [else]{.title-ref} block is
        present.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`IfNode]{.title-ref} instance, including the condition,
    :   [if_body]{.title-ref}, and [else_body]{.title-ref}.
        -   **Returns**: \`str\`: A string representation of the
            [IfNode]{.title-ref} in the format:

        ``` python
        ```

        \"IfNode(condition={self.condition}, if_body={self.if_body},
        else_body={self.else_body})\"
</code></pre>
<h2 id="fornode-class-2">ForNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a [for]{.title-ref} loop in the abstract syntax tree (AST).
  This node models the structure of a [for]{.title-ref} loop, including
  initialization, condition, update, and body.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [init]{.title-ref} (MojoASTNode): The initialization statement
        of the [for]{.title-ref} loop, which is executed once before the
        loop starts.
    -   [condition]{.title-ref} (MojoASTNode): The loop condition that
        is evaluated before each iteration. The loop continues to
        execute as long as this condition is [True]{.title-ref}.
    -   [update]{.title-ref} (MojoASTNode): The update statement
        executed after each iteration of the loop.
    -   [body]{.title-ref} (list of MojoASTNode): The body of the
        [for]{.title-ref} loop, containing the statements to be executed
        in each iteration.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ForNode]{.title-ref} instance, including the
    :   initialization, condition, update, and body.
        -   **Returns**: \`str\`: A string representation of the
            [ForNode]{.title-ref} in the format:

        ``` python
        ```

        \"ForNode(init={self.init}, condition={self.condition},
        update={self.update}, body={self.body})\"
</code></pre>
<h2 id="whilenode-class">WhileNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a [while]{.title-ref} loop in the abstract syntax tree
  (AST). This node models the structure of a [while]{.title-ref} loop,
  including its condition and body.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [condition]{.title-ref} (MojoASTNode): The condition that is
        evaluated before each iteration. The loop continues to execute
        as long as this condition is [True]{.title-ref}.
    -   [body]{.title-ref} (list of MojoASTNode): The body of the
        [while]{.title-ref} loop, containing the statements to be
        executed in each iteration.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`WhileNode]{.title-ref} instance, including the condition
    :   and body.
        -   **Returns**: \`str\`: A string representation of the
            [WhileNode]{.title-ref} in the format:

        ``` python
        ```

        \"WhileNode(condition={self.condition}, body={self.body})\"
</code></pre>
<h2 id="returnnode-class-2">ReturnNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a [return]{.title-ref} statement in the abstract syntax
  tree (AST). This node captures the value to be returned from a
  function or method.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [value]{.title-ref} (MojoASTNode or None): The value to be
        returned. If [None]{.title-ref}, it represents a return
        statement with no value.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ReturnNode]{.title-ref} instance, including the return
    :   value.
        -   **Returns**: \`str\`: A string representation of the
            [ReturnNode]{.title-ref} in the format:

        ``` python
        ```

        \"ReturnNode(value={self.value})\"
</code></pre>
<h2 id="functioncallnode-class-2">FunctionCallNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a function or method call in the abstract syntax tree
  (AST). This node captures the name of the function being called and
  the arguments passed to it.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the function or method
        being called.
    -   [args]{.title-ref} (list of MojoASTNode): The arguments passed
        to the function. Each argument is represented as an AST node.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`FunctionCallNode]{.title-ref} instance, including the
    :   function name and its arguments.
        -   **Returns**: \`str\`: A string representation of the
            [FunctionCallNode]{.title-ref} in the format:

        ``` python
        ```

        \"FunctionCallNode(name={self.name}, args={self.args})\"
</code></pre>
<h2 id="binaryopnode-class-2">BinaryOpNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a binary operation in the abstract syntax tree (AST). This
  node captures two operands and the operator used to combine them.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [left]{.title-ref} (MojoASTNode): The left operand of the binary
        operation.
    -   [op]{.title-ref} (str): The operator used in the binary
        operation (e.g., \"+\", \"-\", \"*\", \"/\").
    -   [right]{.title-ref} (MojoASTNode): The right operand of the
        binary operation.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`BinaryOpNode]{.title-ref} instance, including the left
    :   operand, the operator, and the right operand.
        -   **Returns**: \`str\`: A string representation of the
            [BinaryOpNode]{.title-ref} in the format:

        ``` python
        ```

        \"BinaryOpNode(left={self.left}, operator={self.op},
        right={self.right})\"
</code></pre>
<h2 id="unaryopnode-class-2">UnaryOpNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a unary operation in the abstract syntax tree (AST). This
  node captures the operator and its single operand.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [op]{.title-ref} (str): The operator used in the unary operation
        (e.g., \"+\", \"-\", \"++\", \"--\").
    -   [operand]{.title-ref} (MojoASTNode): The operand for the unary
        operation.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`UnaryOpNode]{.title-ref} instance, including the operator
    :   and the operand.
        -   **Returns**: \`str\`: A string representation of the
            [UnaryOpNode]{.title-ref} in the format:

        ``` python
        ```

        \"UnaryOpNode(operator={self.op}, operand={self.operand})\"
</code></pre>
<h2 id="memberaccessnode-class-2">MemberAccessNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an access operation on a member of an object in the
  abstract syntax tree (AST). This node captures the object and the
  specific member being accessed.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [object]{.title-ref} (MojoASTNode): The object or variable whose
        member is being accessed.
    -   [member]{.title-ref} (str): The name of the member being
        accessed.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`MemberAccessNode]{.title-ref} instance, including the
    :   object and the member.
        -   **Returns**: \`str\`: A string representation of the
            [MemberAccessNode]{.title-ref} in the format:

        ``` python
        ```

        \"MemberAccessNode(object={self.object},
        member={self.member})\"
</code></pre>
<h2 id="vectorconstructornode-class">VectorConstructorNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a vector constructor operation in the abstract syntax tree
  (AST). This node is used to create vectors from a set of arguments
  with a specified type.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [type_name]{.title-ref} (str): The name of the vector type
        (e.g., [\"vec2\"]{.title-ref}, [\"vec3\"]{.title-ref},
        [\"vec4\"]{.title-ref}).
    -   [args]{.title-ref} (List[MojoASTNode]): A list of arguments
        used to initialize the vector.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`VectorConstructorNode]{.title-ref} instance, including
    :   the vector type and its initialization arguments.
        -   **Returns**: \`str\`: A string representation of the
            [VectorConstructorNode]{.title-ref} in the format:

        ``` python
        ```

        \"VectorConstructorNode(type_name={self.type_name},
        args={self.args})\"
</code></pre>
<h2 id="texturesamplenode-class">TextureSampleNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a texture sampling operation in the abstract syntax tree
  (AST). This node is used to sample a texture using a specified sampler
  and texture coordinates.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [texture]{.title-ref} (MojoASTNode): The texture to be sampled.
    -   [sampler]{.title-ref} (MojoASTNode): The sampler used to sample
        the texture.
    -   [coordinates]{.title-ref} (MojoASTNode): The coordinates at
        which the texture is sampled.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`TextureSampleNode]{.title-ref} instance, including the
    :   texture, sampler, and coordinates used for sampling.
        -   **Returns**: \`str\`: A string representation of the
            [TextureSampleNode]{.title-ref} in the format:

        ``` python
        ```

        \"TextureSampleNode(texture={self.texture},
        sampler={self.sampler}, coordinates={self.coordinates})\"
</code></pre>
<h2 id="threadgroupsyncnode-class">ThreadgroupSyncNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a synchronization point for thread groups in a compute
  shader or parallel execution environment. This node ensures that all
  threads in the group reach the synchronization point before
  continuing.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   None</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ThreadgroupSyncNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [ThreadgroupSyncNode]{.title-ref} in the format:

        ``` python
        "ThreadgroupSyncNode()"
        ```
</code></pre>
<h2 id="constantbuffernode-class">ConstantBufferNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a constant buffer in a shader program, which is used to
  store uniform data that remains constant across multiple shader
  invocations.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the constant buffer.
    -   [members]{.title-ref} (list of [VariableNode]{.title-ref}): A
        list of variables that are members of the constant buffer.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ConstantBufferNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [ConstantBufferNode]{.title-ref} in the format:

        ``` python
        "ConstantBufferNode(name={self.name}, members={self.members})"
        ```
</code></pre>
<h2 id="importnode-class">ImportNode Class</h2>
<p>| <strong>Description:</strong>
| Represents an import statement in a shader program, used to include
  external modules or libraries with an optional alias.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [module_name]{.title-ref} (str): The name of the module to be
        imported.
    -   [alias]{.title-ref} (str, optional): An alias for the module,
        allowing it to be referenced with a different name in the
        shader.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ImportNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [ImportNode]{.title-ref} in the format:

        ``` python
        "ImportNode(module_name='{self.module_name}', alias='{self.alias}')"

        if an alias is provided, otherwise

        "ImportNode(module_name='{self.module_name}')"
        ```
</code></pre>
<h2 id="classnode-class">ClassNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a class definition in the shader program, including its
  name, base classes, and members.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the class.
    -   [base_classes]{.title-ref} (list of str): A list of base class
        names that this class inherits from.
    -   [members]{.title-ref} (list of [MojoASTNode]{.title-ref}): A
        list of member variables and methods that belong to the class.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`ClassNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [ClassNode]{.title-ref} in the format:

        ``` python
        "ClassNode(name={self.name}, base_classes={self.base_classes}, members={self.members})"
        ```
</code></pre>
<h2 id="decoratornode-class">DecoratorNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a decorator applied to functions or classes in the shader
  program, including the decorator's name and any optional arguments.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [name]{.title-ref} (str): The name of the decorator.
    -   [args]{.title-ref} (list of [MojoASTNode]{.title-ref},
        optional): A list of arguments for the decorator. Defaults to an
        empty list if not provided.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`DecoratorNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [DecoratorNode]{.title-ref} in the format:

        ``` python
        "DecoratorNode(name={self.name}, args={self.args})"
        ```
</code></pre>
<h2 id="switchcasenode-class">SwitchCaseNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a case in a switch statement, including the condition for
  the case and the block of code to execute if the condition is met.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [condition]{.title-ref} (MojoASTNode): The condition that
        determines if this case should be executed.
    -   [body]{.title-ref} (list of [MojoASTNode]{.title-ref}): The
        block of code to execute if the condition is met.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`SwitchCaseNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [SwitchCaseNode]{.title-ref} in the format:

        ``` python
        "SwitchCaseNode(condition={self.condition}, body={self.body})"
        ```
</code></pre>
<h2 id="switchnode-class">SwitchNode Class</h2>
<p>| <strong>Description:</strong>
| Represents a switch statement, including the expression to evaluate
  and the list of cases to handle different values of the expression.</p>
<p><strong>Constructor Parameters:</strong></p>
<p>:   -   [expression]{.title-ref} (MojoASTNode): The expression being
        evaluated in the switch statement.
    -   [cases]{.title-ref} (list of [SwitchCaseNode]{.title-ref}): A
        list of [SwitchCaseNode]{.title-ref} instances, each
        representing a case in the switch statement.</p>
<p><strong>Methods</strong>:</p>
<p>:   -   </p>
<pre><code>    \`\_\_repr\_\_()[: - \*\*Description\*\*: Returns a string representation of the \`SwitchNode]{.title-ref} instance.

    :   -   **Returns**: \`str\`: A string representation of the
            [SwitchNode]{.title-ref} in the format:

        ``` python
        "SwitchNode(expression={self.expression}, cases={self.cases})"
        ```
</code></pre>
<h1 id="mojo-lexer">Mojo Lexer</h1>
<h2 id="token-definitions-and-keywords-for-mojo">Token Definitions and Keywords for Mojo</h2>
<h3 id="token-definitions_1"><strong>Token Definitions</strong></h3>
<ul>
<li>
<p>| <code>COMMENT_SINGLE</code>: <code>#.*</code>
    | Represents a single-line comment starting with <code>#</code>.</p>
</li>
<li>
<p>| <code>COMMENT_MULTI</code>: <code>"""[\s\S]*?"""</code>
    | Represents a multi-line comment enclosed in triple double quotes
      (<code>"""</code>).</p>
</li>
<li>
<p>| <code>STRUCT</code>: <code>\bstruct\b</code>
    | Represents the <code>struct</code> keyword for defining structures.</p>
</li>
<li>
<p>| <code>LET</code>: <code>\blet\b</code>
    | Represents the <code>let</code> keyword for variable declaration.</p>
</li>
<li>
<p>| <code>VAR</code>: <code>\bvar\b</code>
    | Represents the <code>var</code> keyword for variable declaration.</p>
</li>
<li>
<p>| <code>FN</code>: <code>\bfn\b</code>
    | Represents the <code>fn</code> keyword for function definition.</p>
</li>
<li>
<p>| <code>RETURN</code>: <code>\breturn\b</code>
    | Represents the <code>return</code> keyword for returning values from
      functions.</p>
</li>
<li>
<p>| <code>IF</code>: <code>\bif\b</code>
    | Represents the <code>if</code> keyword for conditional statements.</p>
</li>
<li>
<p>| <code>ELSE</code>: <code>\belse\b</code>
    | Represents the <code>else</code> keyword for conditional statements.</p>
</li>
<li>
<p>| <code>FOR</code>: <code>\bfor\b</code>
    | Represents the <code>for</code> keyword for loop statements.</p>
</li>
<li>
<p>| <code>WHILE</code>: <code>\bwhile\b</code>
    | Represents the <code>while</code> keyword for loop statements.</p>
</li>
<li>
<p>| <code>IMPORT</code>: <code>\bimport\b</code>
    | Represents the <code>import</code> keyword for importing modules.</p>
</li>
<li>
<p>| <code>DEF</code>: <code>\bdef\b</code>
    | Represents the <code>def</code> keyword for function definition.</p>
</li>
<li>
<p>| <code>INT</code>: <code>\bInt\b</code>
    | Represents the <code>Int</code> type keyword.</p>
</li>
<li>
<p>| <code>FLOAT</code>: <code>\bFloat\b</code>
    | Represents the <code>Float</code> type keyword.</p>
</li>
<li>
<p>| <code>BOOL</code>: <code>\bBool\b</code>
    | Represents the <code>Bool</code> type keyword.</p>
</li>
<li>
<p>| <code>STRING</code>: <code>\bString\b</code>
    | Represents the <code>String</code> type keyword.</p>
</li>
<li>
<p>| <code>IDENTIFIER</code>: <code>[a-zA-Z_][a-zA-Z0-9_]*</code>
    | Represents an identifier consisting of letters, digits, and
      underscores.</p>
</li>
<li>
<p>| <code>NUMBER</code>: <code>\d+(\.\d+)?</code>
    | Represents a number, which can be an integer or a floating-point
      number.</p>
</li>
<li>
<p>| <code>LBRACE</code>: <code>\{</code>
    | Represents the left brace <code>{</code>.</p>
</li>
<li>
<p>| <code>RBRACE</code>: <code>\}</code>
    | Represents the right brace <code>}</code>.</p>
</li>
<li>
<p>| <code>LPAREN</code>: <code>\(</code>
    | Represents the left parenthesis <code>(</code>.</p>
</li>
<li>
<p>| <code>RPAREN</code>: <code>\)</code>
    | Represents the right parenthesis <code>)</code>.</p>
</li>
<li>
<p>| <code>LBRACKET</code>: <code>\[</code>
    | Represents the left bracket <code>[</code>.</p>
</li>
<li>
<p>| <code>RBRACKET</code>: <code>\]</code>
    | Represents the right bracket <code>]</code>.</p>
</li>
<li>
<p>| <code>SEMICOLON</code>: <code>;</code>
    | Represents the semicolon <code>;</code>.</p>
</li>
<li>
<p>| <code>STRING_LITERAL</code>: <code>"[^"]*"</code>
    | Represents a string literal enclosed in double quotes.</p>
</li>
<li>
<p>| <code>COMMA</code>: <code>,</code>
    | Represents the comma <code>,</code>.</p>
</li>
<li>
<p>| <code>COLON</code>: <code>:</code>
    | Represents the colon <code>:</code>.</p>
</li>
<li>
<p>| <code>LESS_EQUAL</code>: <code>&lt;=</code>
    | Represents the less-than-or-equal-to operator.</p>
</li>
<li>
<p>| <code>GREATER_EQUAL</code>: <code>&gt;=</code>
    | Represents the greater-than-or-equal-to operator.</p>
</li>
<li>
<p>| <code>LESS_THAN</code>: <code>&lt;</code>
    | Represents the less-than operator.</p>
</li>
<li>
<p>| <code>GREATER_THAN</code>: <code>&gt;</code>
    | Represents the greater-than operator.</p>
</li>
<li>
<p>| <code>EQUAL</code>: <code>==</code>
    | Represents the equality operator.</p>
</li>
<li>
<p>| <code>NOT_EQUAL</code>: <code>!=</code>
    | Represents the inequality operator.</p>
</li>
<li>
<p>| <code>PLUS_EQUALS</code>: <code>+=</code>
    | Represents the addition assignment operator.</p>
</li>
<li>
<p>| <code>MINUS_EQUALS</code>: <code>-=</code>
    | Represents the subtraction assignment operator.</p>
</li>
<li>
<p>| <code>MULTIPLY_EQUALS</code>: <code>*=</code>
    | Represents the multiplication assignment operator.</p>
</li>
<li>
<p>| <code>DIVIDE_EQUALS</code>: <code>/=</code>
    | Represents the division assignment operator.</p>
</li>
<li>
<p>| <code>PLUS</code>: <code>+</code>
    | Represents the addition operator.</p>
</li>
<li>
<p>| <code>MINUS</code>: <code>-</code>
    | Represents the subtraction operator.</p>
</li>
<li>
<p>| <code>MULTIPLY</code>: <code>*</code>
    | Represents the multiplication operator.</p>
</li>
<li>
<p>| <code>DIVIDE</code>: <code>/</code>
    | Represents the division operator.</p>
</li>
<li>
<p>| <code>AND</code>: <code>&amp;&amp;</code>
    | Represents the logical AND operator.</p>
</li>
<li>
<p>| <code>OR</code> : <code>\|\|</code>
    | Represents the logical OR operator.</p>
</li>
<li>
<p>| <code>DOT</code>: <code>\.</code>
    | Represents the dot <code>.</code> for member access.</p>
</li>
<li>
<p>| <code>EQUALS</code>: <code>=</code>
    | Represents the assignment operator.</p>
</li>
<li>
<p>| <code>WHITESPACE</code>: <code>\s+</code>
    | Represents whitespace characters (spaces, tabs, newlines).</p>
</li>
</ul>
<h3 id="keywords_1"><strong>Keywords</strong></h3>
<ul>
<li><code>struct</code>: <code>STRUCT</code></li>
<li><code>let</code>: <code>LET</code></li>
<li><code>var</code>: <code>VAR</code></li>
<li><code>fn</code>: <code>FN</code></li>
<li><code>return</code>: <code>RETURN</code></li>
<li><code>if</code>: <code>IF</code></li>
<li><code>else</code>: <code>ELSE</code></li>
<li><code>for</code>: <code>FOR</code></li>
<li><code>while</code>: <code>WHILE</code></li>
<li><code>import</code>: <code>IMPORT</code></li>
<li><code>def</code>: <code>DEF</code></li>
<li><code>Int</code>: <code>INT</code></li>
<li><code>Float</code>: <code>FLOAT</code></li>
<li><code>Bool</code>: <code>BOOL</code></li>
<li><code>String</code>: <code>STRING</code></li>
</ul>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="tokenize-method_1">Tokenize Method</h2>
<p>| <strong>Description:</strong>
| Tokenizes the input code into a list of tokens based on predefined
  patterns. It processes each segment of the code to match against the
  token patterns and converts identifiers to keywords if applicable.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - None</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Initializes the token position to zero and iterates through the
    code.</li>
<li>For each position, attempts to match the code segment with
    predefined regex patterns.</li>
<li>If a match is found, determines the token type:<ul>
<li>Converts [IDENTIFIER]{.title-ref} tokens to keywords if they
    match predefined keywords.</li>
<li>Skips tokens of types [WHITESPACE]{.title-ref},
    [COMMENT_SINGLE]{.title-ref}, and [COMMENT_MULTI]{.title-ref}.</li>
<li>Appends other tokens to the [tokens]{.title-ref} list.</li>
</ul>
</li>
<li>Moves the position index forward by the length of the matched text.</li>
<li>Raises a [SyntaxError]{.title-ref} if an illegal character is
    encountered.</li>
<li>Appends an [EOF]{.title-ref} (end-of-file) token at the end of the
    code.</li>
</ul>
<h1 id="mojo-parser">Mojo Parser</h1>
<p>Methods</p>
<p>Initializes the code generator.</p>
<h2 id="eat_2">eat</h2>
<ul>
<li><strong>Description</strong>:<ul>
<li>Consumes the current token if it matches the expected type.</li>
<li>Advances to the next token and skips any comments following the
    current token.</li>
</ul>
</li>
<li><strong>Parameters</strong>:<ul>
<li>`token_type`: The type of token expected to be consumed.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li>None</li>
</ul>
</li>
<li><strong>Raises</strong>:<ul>
<li>`SyntaxError`: If the current token does not match the
    expected token type.</li>
</ul>
</li>
</ul>
<h2 id="skip_commentsself_1">skip_comments(self)</h2>
<p>| <strong>Description:</strong>
| Skips over single-line and multi-line comments in the token stream by
  advancing past them.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - None</p>
<p>| <strong>Raises:</strong>
| - None</p>
<h2 id="parse-method_1">parse Method</h2>
<p>| <strong>Description:</strong>
| Parses the entire code to generate an abstract syntax tree (AST)
  representation. It starts by parsing the module and ensures the end of
  the file is reached.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `module`: The parsed module, which is an AST representation of the
  code.</p>
<p>| <strong>Method Details:</strong>
| - Calls [parse_module]{.title-ref} to parse the module's structure
  from the code. - Calls eat to ensure that the end-of-file (EOF) token
  is present and correctly positioned. - Returns the parsed module.</p>
<h2 id="parse_module-method">parse_module Method</h2>
<p>| <strong>Description:</strong>
| Parses the module to extract statements and constructs an abstract
  syntax tree (AST). It handles different types of statements, including
  imports, structures, classes, constant buffers, functions, variable
  declarations or assignments, and decorators.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ShaderNode`: An instance of [ShaderNode]{.title-ref} containing
  the list of parsed statements.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Iterates through tokens until the end-of-file (EOF) token is
    encountered.</li>
<li>Handles each type of statement based on the current token type:<ul>
<li><strong>IMPORT</strong>: Calls [parse_import_statement]{.title-ref} to parse
    import statements.</li>
<li><strong>STRUCT</strong>: Calls [parse_struct]{.title-ref} to parse structure
    definitions.</li>
<li><strong>CLASS</strong>: Calls [parse_class]{.title-ref} to parse class
    definitions.</li>
<li><strong>CONSTANT</strong>: Calls [parse_constant_buffer]{.title-ref} to parse
    constant buffer declarations.</li>
<li><strong>FN</strong>: Calls [parse_function]{.title-ref} to parse function
    definitions.</li>
<li><strong>LET, VAR</strong>: Calls
    [parse_variable_declaration_or_assignment]{.title-ref} to parse
    variable declarations or assignments.</li>
<li><strong>DECORATOR</strong>: Calls [parse_decorator]{.title-ref} to parse
    decorator statements.</li>
</ul>
</li>
<li>Uses [eat]{.title-ref} to consume and process the current token.</li>
<li>Returns a [ShaderNode]{.title-ref} instance containing all parsed
    statements.</li>
</ul>
<h2 id="parse_import_statement-method">parse_import_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses an import statement from the source code and constructs an
  [ImportNode]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ImportNode`: An instance with the module name and optional alias.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Consumes the [\"IMPORT\"]{.title-ref} token.</li>
<li>Extracts the module name from the [\"IDENTIFIER\"]{.title-ref}
    token.</li>
<li>Optionally handles the [\"AS\"]{.title-ref} keyword to set an alias.</li>
<li>Consumes the [\"SEMICOLON\"]{.title-ref} token if present.</li>
</ul>
<h2 id="parse_struct-method">parse_struct Method</h2>
<p>| <strong>Description:</strong>
| Parses a [struct]{.title-ref} definition from the source code and
  constructs a [StructNode]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `StructNode`: An instance with the struct's name and its members.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Consumes the [\"STRUCT\"]{.title-ref} token.</li>
<li>Extracts the struct name from the [\"IDENTIFIER\"]{.title-ref}
    token.</li>
<li>Consumes the [\"COLON\"]{.title-ref} token.</li>
<li>Iterates over subsequent tokens to parse member variables, handling
    optional type declarations and attributes.</li>
<li>Stops parsing members upon encountering [\"EOF\"]{.title-ref},
    [\"FN\"]{.title-ref}, [\"STRUCT\"]{.title-ref}, or
    [\"CLASS\"]{.title-ref} tokens.</li>
</ul>
<h2 id="parse_class-method">parse_class Method</h2>
<p>| <strong>Description:</strong>
| Parses a [class]{.title-ref} definition from the source code and
  constructs a [ClassNode]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ClassNode`: An instance representing the class with its name,
  base classes, and members.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Consumes the [\"CLASS\"]{.title-ref} token.</li>
<li>Extracts the class name from the [\"IDENTIFIER\"]{.title-ref} token.</li>
<li>Parses optional base classes enclosed in parentheses.</li>
<li>Consumes the [\"LBRACE\"]{.title-ref} token.</li>
<li>Iterates over tokens to parse class members, including functions,
    variable declarations, or nested classes.</li>
<li>Stops parsing members upon encountering the [\"RBRACE\"]{.title-ref}
    token.</li>
<li>Constructs and returns a [ClassNode]{.title-ref} with the parsed
    name, base classes, and members.</li>
</ul>
<h2 id="parse_constant_buffer-method">parse_constant_buffer Method</h2>
<p>| <strong>Description:</strong>
| Parses a constant buffer definition from the source code and
  constructs a [ConstantBufferNode]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ConstantBufferNode`: An instance representing the constant buffer
  with its name and members.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Consumes the [\"CONSTANT\"]{.title-ref} token.</li>
<li>Extracts the constant buffer name from the
    [\"IDENTIFIER\"]{.title-ref} token.</li>
<li>Consumes the [\"LBRACE\"]{.title-ref} token.</li>
<li>Iterates over tokens to parse the members of the constant buffer,
    extracting the variable type and name, and consuming the
    [\"SEMICOLON\"]{.title-ref} token.</li>
<li>Stops parsing members upon encountering the [\"RBRACE\"]{.title-ref}
    token.</li>
<li>Constructs and returns a [ConstantBufferNode]{.title-ref} with the
    parsed name and members.</li>
</ul>
<h2 id="parse_function-method_1">parse_function Method</h2>
<p>| <strong>Description:</strong>
| Parses a function definition from the source code and constructs a
  [FunctionNode]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `FunctionNode`: An instance representing the parsed function,
  including its attributes, return type, name, parameters, body, and
  additional attributes.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Parses function attributes using
    [self.parse_attributes()]{.title-ref}.</li>
<li>Checks for and consumes the [\"FN\"]{.title-ref} token, setting the
    function's qualifier if present.</li>
<li>Extracts the function name from the [\"IDENTIFIER\"]{.title-ref}
    token.</li>
<li>Consumes the [\"LPAREN\"]{.title-ref} token and parses function
    parameters using [self.parse_parameters()]{.title-ref}.</li>
<li>Consumes the [\"RPAREN\"]{.title-ref} token.</li>
<li>Checks for and consumes the [\"MINUS\"]{.title-ref} and
    [\"GREATER_THAN\"]{.title-ref} tokens to parse the return type if
    specified.</li>
<li>Parses additional attributes after the return type.</li>
<li>Parses the function body using [self.parse_block()]{.title-ref}.</li>
<li>Constructs and returns a [FunctionNode]{.title-ref} with the parsed
    information.</li>
</ul>
<h2 id="parse_parameters-method_1">parse_parameters Method</h2>
<p>| <strong>Description:</strong>
| Parses the parameter list for a function definition from the source
  code, handling type annotations and attributes.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `List[VariableNode][: A list of `VariableNode]{.title-ref}
  instances representing the parameters, including their types, names,
  and attributes.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Initializes an empty list [params]{.title-ref} to store parsed
    parameters.</li>
<li>Iterates through tokens until it encounters a [RPAREN]{.title-ref}
    token (end of parameter list).</li>
<li><strong>Attributes:</strong> Calls [self.parse_attributes()]{.title-ref} to parse
    any attributes associated with the parameter.</li>
<li><strong>Type Handling:</strong> Checks if the current token is a valid type
    ([FLOAT]{.title-ref}, [INT]{.title-ref}, [UINT]{.title-ref},
    [BOOL]{.title-ref}, [IDENTIFIER]{.title-ref}):<ul>
<li>Extracts the type and handles optional type annotations
    indicated by a [COLON]{.title-ref} token.</li>
<li>Retrieves the parameter name from the [IDENTIFIER]{.title-ref}
    token if present.</li>
<li>Parses and appends attributes specific to the parameter.</li>
<li>Creates and adds a [VariableNode]{.title-ref} to the
    [params]{.title-ref} list.</li>
</ul>
</li>
<li><strong>Comma Handling:</strong> Ensures commas are correctly placed and raises
    an error for trailing commas.</li>
<li><strong>Error Handling:</strong> Raises [SyntaxError]{.title-ref} for unexpected
    tokens or incorrect syntax in the parameter list.</li>
</ul>
<p>| <strong>Errors Raised:</strong>
| - [SyntaxError]{.title-ref} for unexpected tokens, trailing commas, or
  incorrect syntax in the parameter list.</p>
<h2 id="parse_attributes-method">parse_attributes Method</h2>
<p>| <strong>Description:</strong>
| Parses a sequence of attribute tokens from the source code, extracting
  their names and arguments.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `List[AttributeNode][: A list of `AttributeNode]{.title-ref}
  instances representing the parsed attributes.</p>
<p>| <strong>Method Details:</strong></p>
<ul>
<li>Initializes an empty list [attributes]{.title-ref} to store parsed
    attributes.</li>
<li>Continuously checks if the current token is of type
    [ATTRIBUTE]{.title-ref}.</li>
<li><strong>Attribute Content:</strong> Strips the surrounding [[[]{.title-ref} and
    []]]{.title-ref} from the attribute content to extract the core
    information.</li>
<li><strong>Parsing Attributes:</strong> Splits the content by [(]{.title-ref} to
    separate the attribute name from its arguments:<ul>
<li><strong>Name Extraction:</strong> The part before [(]{.title-ref} is the
    attribute name.</li>
<li><strong>Arguments Extraction:</strong> The part inside the parentheses is
    split by commas to get a list of arguments.</li>
</ul>
</li>
<li><strong>Creating AttributeNode:</strong> Creates an [AttributeNode]{.title-ref}
    instance with the name and arguments, and appends it to the
    [attributes]{.title-ref} list.</li>
<li><strong>Consuming Token:</strong> Calls [self.eat(\"ATTRIBUTE\")]{.title-ref} to
    advance to the next token.</li>
</ul>
<p>| <strong>Errors Raised:</strong>
| - No specific errors are raised by this method. It assumes attributes
  are well-formed according to the defined token patterns.</p>
<h2 id="parse_block-method">parse_block Method</h2>
<p>| <strong>Description:</strong>
| Parses a block of statements, which can start with either a colon or
  an opening brace, and continues until it encounters a closing brace or
  the end of the file.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `List[StatementNode][: A list of `StatementNode]{.title-ref}
  instances representing the parsed statements within the block.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Block Start:</strong><ul>
<li><strong>Colon (`:`) or Brace (`{`):</strong><ul>
<li>If the current token is [COLON]{.title-ref}, it is consumed
    to denote the start of the block.</li>
<li>If the current token is [LBRACE]{.title-ref}, it is consumed
    to denote the start of the block.</li>
<li>Raises a [SyntaxError]{.title-ref} if neither
    [COLON]{.title-ref} nor [LBRACE]{.title-ref} is found.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Parsing Statements:</strong><ul>
<li>Initializes an empty list [statements]{.title-ref} to store the
    parsed statements.</li>
<li>Continues to parse statements until encountering
    [RBRACE]{.title-ref} or [EOF]{.title-ref}.</li>
</ul>
</li>
<li><strong>Block End:</strong><ul>
<li><strong>`Closing Brace (`}`):`</strong> If a closing brace is
    encountered, it is consumed to denote the end of the block.</li>
</ul>
</li>
<li><strong>Return Statements:</strong><ul>
<li>Returns the list of parsed statements.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Raised if the block does not start with a
  [COLON]{.title-ref} or [LBRACE]{.title-ref}, or if unexpected tokens
  are found while parsing statements.</p>
<h2 id="parse_statement-method_1">parse_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses a single statement from the input code. The type of statement
  to be parsed is determined based on the current token.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `StatementNode`: The parsed statement, which can be one of several
  types including variable declarations, function definitions, control
  flow statements, or expressions.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Variable Declarations or Assignments:</strong> - <strong>Token Types:</strong>
  [FLOAT]{.title-ref}, [INT]{.title-ref}, [UINT]{.title-ref},
  [BOOL]{.title-ref}, [IDENTIFIER]{.title-ref}, [LET]{.title-ref},
  [VAR]{.title-ref} - Calls
  [parse_variable_declaration_or_assignment]{.title-ref} to handle
  variable-related statements.</p>
<ol>
<li><strong>Function Definitions:</strong><ul>
<li><strong>`Token Type:`</strong> [FN]{.title-ref}</li>
<li>Calls [parse_function]{.title-ref} to handle function
    definitions.</li>
</ul>
</li>
<li><strong>Control Flow Statements:</strong><ul>
<li><strong>`If Statements:`</strong> Token type [IF]{.title-ref}<ul>
<li>Calls [parse_if_statement]{.title-ref} to handle
    [if]{.title-ref} statements.</li>
</ul>
</li>
<li><strong>For Loops:</strong> Token type [FOR]{.title-ref}<ul>
<li>Calls [parse_for_statement]{.title-ref} to handle
    [for]{.title-ref} loops.</li>
</ul>
</li>
<li><strong>While Loops:</strong> Token type [WHILE]{.title-ref}<ul>
<li>Calls [parse_while_statement]{.title-ref} to handle
    [while]{.title-ref} loops.</li>
</ul>
</li>
<li><strong>Switch Statements:</strong> Token type [SWITCH]{.title-ref}<ul>
<li>Calls [parse_switch_statement]{.title-ref} to handle
    [switch]{.title-ref} statements.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Return Statements:</strong><ul>
<li><strong>Token Type:</strong> [RETURN]{.title-ref}</li>
<li>Calls [parse_return_statement]{.title-ref} to handle return
    statements.</li>
</ul>
</li>
<li><strong>Structures:</strong><ul>
<li><strong>Token Type:</strong> [STRUCT]{.title-ref}</li>
<li>Calls parse_struct to handle [struct]{.title-ref} definitions.</li>
</ul>
</li>
<li><strong>Expression Statements:</strong><ul>
<li><strong>`Fallback:`</strong> If none of the above tokens are matched, it
    defaults to [parse_expression_statement]{.title-ref} to handle
    any remaining expressions.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but could be
  raised by the called methods if there are issues with the statements
  being parsed.</p>
<h2 id="parse_variable_declaration_or_assignment-method">parse_variable_declaration_or_assignment Method</h2>
<p>| <strong>Description:</strong>
| Parses either a variable declaration or an assignment statement based
  on the current token.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - [VariableDeclarationNode]{.title-ref} or `AssignmentNode`: Returns
  a node representing either a variable declaration with an optional
  initial value or an assignment statement.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Variable Declaration:</strong><ul>
<li><strong>Token Types:</strong> [LET]{.title-ref}, [VAR]{.title-ref}</li>
<li><strong>Process:</strong><ul>
<li><strong>Type:</strong> Determines the variable type from the token
    ([LET]{.title-ref} or [VAR]{.title-ref}).</li>
<li><strong>Name:</strong> Extracts the variable name from the next
    [IDENTIFIER]{.title-ref} token.</li>
<li><strong>Type Annotation (Optional):</strong> If a [COLON]{.title-ref} is
    present, it indicates a type annotation, which is processed
    but not used further.</li>
<li><strong>Initial Value (Optional):</strong> If an [EQUALS]{.title-ref}
    token is present, it indicates the start of an initial value
    expression. The expression is parsed and assigned to the
    variable.</li>
<li><strong>Semicolon (Optional):</strong> Consumes the
    [SEMICOLON]{.title-ref} if it is present, marking the end of
    the statement.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Assignment:</strong><ul>
<li><strong>`Fallback:`</strong> If the current token does not indicate a
    variable declaration, it defaults to
    [parse_assignment]{.title-ref} to handle assignment statements.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but may be
  raised by [parse_expression]{.title-ref} or
  [parse_assignment]{.title-ref} if there are issues with the provided
  expressions or assignments.</p>
<h2 id="parse_if_statement-method">parse_if_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses an [if]{.title-ref} statement, including its optional
  [else]{.title-ref} block.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `IfNode`: Returns a node representing the parsed [if]{.title-ref}
  statement, including its condition, [if]{.title-ref} body, and
  optional [else]{.title-ref} body.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Start Parsing:</strong><ul>
<li><strong>Token Type:</strong> [IF]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [IF]{.title-ref} token to identify
    the start of the [if]{.title-ref} statement.</li>
</ul>
</li>
<li><strong>Left Parenthesis:</strong> [LPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [LPAREN]{.title-ref} token to
    start the condition expression.</li>
</ul>
</li>
<li><strong>Condition Expression:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse
    the condition of the [if]{.title-ref} statement.</li>
</ul>
</li>
<li><strong>Right Parenthesis:</strong> [RPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [RPAREN]{.title-ref} token to
    close the condition expression.</li>
</ul>
</li>
<li><strong>If Block:</strong><ul>
<li><strong>Method:</strong> Calls [parse_block]{.title-ref} to parse the
    block of statements that execute if the condition is true.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Optional Else Block:</strong><ul>
<li><strong>Token Type:</strong> [ELSE]{.title-ref}<ul>
<li><strong>`Process:`</strong> If the next token is [ELSE]{.title-ref}, it
    is consumed and the [else]{.title-ref} block is parsed using
    [parse_block]{.title-ref}.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li><strong>Returns:</strong> An [IfNode]{.title-ref} object with the condition,
    [if]{.title-ref} body, and optionally the [else]{.title-ref}
    body.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but may be
  triggered by [parse_expression]{.title-ref} or
  [parse_block]{.title-ref} if there are issues with the syntax.</p>
<h2 id="parse_for_statement-method">parse_for_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses a [for]{.title-ref} loop statement, including initialization,
  condition, update, and loop body.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ForNode`: Returns a node representing the parsed
  [for]{.title-ref} loop statement, including its initialization,
  condition, update expression, and body.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Start Parsing:</strong><ul>
<li><strong>Token Type:</strong> [FOR]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [FOR]{.title-ref} token to
    identify the start of the [for]{.title-ref} loop statement.</li>
</ul>
</li>
<li><strong>Left Parenthesis:</strong> [LPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [LPAREN]{.title-ref} token to
    start parsing the [for]{.title-ref} loop components.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Initialization:</strong><ul>
<li><strong>Method:</strong> Calls
    [parse_variable_declaration_or_assignment]{.title-ref} to parse
    the initialization expression of the loop (e.g., variable
    declarations or assignments).</li>
<li><strong>Token Type:</strong> [SEMICOLON]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [SEMICOLON]{.title-ref} token to
    separate initialization from the loop condition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Condition:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse the
    loop condition.</li>
<li><strong>Token Type:</strong> [SEMICOLON]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [SEMICOLON]{.title-ref} token to
    separate the condition from the update expression.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Update:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse the
    update expression (e.g., increment or decrement).</li>
<li><strong>Token Type:</strong> [RPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [RPAREN]{.title-ref} token to
    close the [for]{.title-ref} loop header.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Body:</strong><ul>
<li><strong>Method:</strong> Calls [parse_block]{.title-ref} to parse the block
    of statements that execute during each iteration of the loop.</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li><strong>Returns:</strong> A [ForNode]{.title-ref} object with initialization,
    condition, update expression, and body.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but may be
  triggered by [parse_variable_declaration_or_assignment]{.title-ref},
  [parse_expression]{.title-ref}, or [parse_block]{.title-ref} if there
  are issues with the syntax.</p>
<h2 id="parse_while_statement-method">parse_while_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses a [while]{.title-ref} loop statement, including its condition
  and loop body.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `WhileNode`: Returns a node representing the parsed
  [while]{.title-ref} loop statement, including its condition and body.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li><strong>Start Parsing:</strong><ul>
<li><strong>Token Type:</strong> [WHILE]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [WHILE]{.title-ref} token to
    identify the start of the [while]{.title-ref} loop
    statement.</li>
</ul>
</li>
<li><strong>Left Parenthesis:</strong> [LPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [LPAREN]{.title-ref} token to
    start parsing the loop condition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Condition:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse the
    loop condition (the expression that controls the loop's
    execution).</li>
<li><strong>Token Type:</strong> [RPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [RPAREN]{.title-ref} token to
    close the condition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Body:</strong><ul>
<li><strong>Method:</strong> Calls [parse_block]{.title-ref} to parse the block
    of statements that execute as long as the condition is true.</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li><strong>Returns:</strong> A [WhileNode]{.title-ref} object with the condition
    and body of the [while]{.title-ref} loop.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but may be
  triggered by [parse_expression]{.title-ref} or
  [parse_block]{.title-ref} if there are syntax issues.</p>
<h2 id="parse_switch_statementtitle-ref-method">[parse_switch_statement]{.title-ref} Method</h2>
<p>| <strong>Description:</strong>
| Parses a [switch]{.title-ref} statement, including its expression and
  cases.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `SwitchNode`: Returns a node representing the parsed
  [switch]{.title-ref} statement, including its expression and cases.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Start Parsing:</strong><ul>
<li><strong>Token Type:</strong> [SWITCH]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [SWITCH]{.title-ref} token to
    identify the start of the [switch]{.title-ref} statement.</li>
</ul>
</li>
<li><strong>Left Parenthesis:</strong> [LPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [LPAREN]{.title-ref} token to
    begin parsing the [switch]{.title-ref} expression.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Expression:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse the
    expression that the [switch]{.title-ref} statement evaluates.</li>
<li><strong>Token Type:</strong> [RPAREN]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [RPAREN]{.title-ref} token to
    close the expression.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Block:</strong><ul>
<li><strong>Left Brace:</strong> [LBRACE]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [LBRACE]{.title-ref} token to
    start parsing the block of cases.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Cases:</strong><ul>
<li><strong>Method:</strong> Calls [parse_switch_case]{.title-ref} to parse each
    case within the [switch]{.title-ref} block.</li>
<li><strong>Loop:</strong> Continues to parse cases until encountering a
    [RBRACE]{.title-ref} token.</li>
</ul>
</li>
<li><strong>End of Block:</strong><ul>
<li><strong>Right Brace:</strong> [RBRACE]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [RBRACE]{.title-ref} token to
    close the [switch]{.title-ref} block.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li><strong>Returns:</strong> A [SwitchNode]{.title-ref} object with the
    [switch]{.title-ref} expression and a list of cases.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: Not directly raised in this method but may be
  triggered by [parse_expression]{.title-ref} or
  [parse_switch_case]{.title-ref} if there are syntax issues.</p>
<h2 id="parse_switch_case-method">parse_switch_case Method</h2>
<p>| <strong>Description:</strong>
| Parses a [case]{.title-ref} or [default]{.title-ref} branch within a
  [switch]{.title-ref} statement.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `SwitchCaseNode`: Returns a node representing the parsed
  [case]{.title-ref} or [default]{.title-ref} branch, including its
  condition (if applicable) and block of statements.</p>
<p>| <strong>Method Details:</strong></p>
<ol>
<li><strong>Case Branch:</strong><ul>
<li><strong>Token Type:</strong> [CASE]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [CASE]{.title-ref} token to start
    parsing a [case]{.title-ref} branch.</li>
</ul>
</li>
<li><strong>Expression:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse
    the condition for the [case]{.title-ref}.</li>
</ul>
</li>
<li><strong>Colon:</strong> [COLON]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [COLON]{.title-ref} token to
    separate the condition from the block of statements.</li>
</ul>
</li>
<li><strong>Block:</strong><ul>
<li><strong>Method:</strong> Calls [parse_block]{.title-ref} to parse the
    statements that follow the [case]{.title-ref} condition.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Default Branch:</strong><ul>
<li><strong>Token Type:</strong> [DEFAULT]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [DEFAULT]{.title-ref} token to
    start parsing the default branch.</li>
</ul>
</li>
<li><strong>Colon:</strong> [COLON]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [COLON]{.title-ref} token to
    separate the [default]{.title-ref} from the block of
    statements.</li>
</ul>
</li>
<li><strong>Block:</strong><ul>
<li><strong>Method:</strong> Calls [parse_block]{.title-ref} to parse the
    statements that follow the [default]{.title-ref} keyword.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Error Handling:</strong><ul>
<li><strong>SyntaxError:</strong> Raises an error if the token does not match
    [CASE]{.title-ref} or [DEFAULT]{.title-ref}.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - `SyntaxError`: If the token is not [CASE]{.title-ref} or
  [DEFAULT]{.title-ref}.</p>
<h2 id="parse_return_statementtitle-ref-method">[parse_return_statement]{.title-ref} Method</h2>
<p>| <strong>Description:</strong>
| Parses a [return]{.title-ref} statement within a function, which
  specifies the value to be returned.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ReturnNode`: Returns a node representing the [return]{.title-ref}
  statement, including the value to be returned.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Return Keyword:</strong> - <strong>Token Type:</strong> [RETURN]{.title-ref} -
  <strong>Process:</strong> Consumes the [RETURN]{.title-ref} token to start parsing
  the return statement.</p>
<ol>
<li><strong>Expression:</strong><ul>
<li><strong>Method:</strong> Calls [parse_expression]{.title-ref} to parse the
    value or expression to be returned.</li>
</ul>
</li>
<li><strong>Semicolon:</strong><ul>
<li><strong>Token Type:</strong> [SEMICOLON]{.title-ref} (optional)<ul>
<li><strong>Process:</strong> Consumes the [SEMICOLON]{.title-ref} token if
    present to terminate the return statement.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="parse_expression_statement-method">parse_expression_statement Method</h2>
<p>| <strong>Description:</strong>
| Parses an expression statement, which consists of a single expression
  followed by a semicolon.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `ExpressionNode`: Returns the parsed expression node.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Expression:</strong> - <strong>Method:</strong> Calls [parse_expression]{.title-ref}
  to parse the expression part of the statement.</p>
<ol>
<li><strong>Semicolon:</strong><ul>
<li><strong>Token Type:</strong> [SEMICOLON]{.title-ref}<ul>
<li><strong>Process:</strong> Consumes the [SEMICOLON]{.title-ref} token to
    complete the statement.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> If the [SEMICOLON]{.title-ref} token is not present
  after the expression.</p>
<h2 id="parse_expression-method_1">parse_expression Method</h2>
<p>| <strong>Description:</strong>
| Parses an expression, which can be an assignment or other types of
  expressions depending on the implementation of
  [parse_assignment]{.title-ref}.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - [AssignmentNode]{.title-ref} or other expression node types: Returns
  the result of parsing an assignment or expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Delegation:</strong> - <strong>Method:</strong> Calls [parse_assignment]{.title-ref}
  to handle the parsing of assignments and potentially other
  expressions.</p>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> Depending on the implementation of
  [parse_assignment]{.title-ref}, it may raise errors related to invalid
  syntax or tokens.</p>
<h2 id="parse_assignment-method_1">parse_assignment Method</h2>
<p>| <strong>Description:</strong>
| Parses an assignment expression, including assignments with compound
  operators and ternary conditional expressions.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - [AssignmentNode]{.title-ref} or `TernaryOpNode`: Returns an
  [AssignmentNode]{.title-ref} if an assignment is parsed, or a
  [TernaryOpNode]{.title-ref} if a ternary operation is detected.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Starts by parsing the left-hand
  side of the assignment using [parse_logical_or]{.title-ref}.</p>
<ol>
<li><strong>Assignment Operators Handling:</strong><ul>
<li><strong>Condition:</strong> Checks for assignment operators
    ([EQUALS]{.title-ref}, [PLUS_EQUALS]{.title-ref},
    [MINUS_EQUALS]{.title-ref}, [MULTIPLY_EQUALS]{.title-ref},
    [DIVIDE_EQUALS]{.title-ref}).</li>
<li><strong>Action:</strong> If an assignment operator is found, it captures the
    operator and parses the right-hand side recursively.</li>
<li><strong>Return:</strong> Returns an [AssignmentNode]{.title-ref} that
    encapsulates the left-hand side, right-hand side, and operator.</li>
</ul>
</li>
<li><strong>Ternary Conditional Expressions Handling:</strong><ul>
<li><strong>Condition:</strong> If a ternary operator ([QUESTION]{.title-ref}) is
    found after the initial left-hand side parsing.</li>
<li><strong>Action:</strong> Parses the true and false branches of the ternary
    expression.</li>
<li><strong>Return:</strong> Returns a [TernaryOpNode]{.title-ref} if a ternary
    operation is detected.</li>
</ul>
</li>
<li><strong>Fallback:</strong><ul>
<li><strong>Return:</strong> Returns the parsed left-hand side if no assignment
    or ternary operation is found.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors during parsing if unexpected
  tokens are encountered.</p>
<h2 id="parse_logical_or-method">parse_logical_or Method</h2>
<p>| <strong>Description:</strong>
| Parses logical OR expressions, handling multiple chained OR
  operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the logical OR expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the OR expression using [parse_logical_and]{.title-ref}.</p>
<ol>
<li><strong>Chained OR Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is an
    [OR]{.title-ref} operator.</li>
<li><strong>Action:</strong> If an [OR]{.title-ref} operator is found, it
    captures the operator, then parses the right-hand side of the OR
    expression using [parse_logical_and]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the
    [OR]{.title-ref} operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Repeats the process to handle additional chained OR
    operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the logical OR expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_logical_and-method">parse_logical_and Method</h2>
<p>| <strong>Description:</strong>
| Parses logical AND expressions, handling multiple chained AND
  operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the logical AND expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the AND expression using [parse_equality]{.title-ref}.</p>
<ol>
<li><strong>Chained AND Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is an
    [AND]{.title-ref} operator.</li>
<li><strong>Action:</strong> If an [AND]{.title-ref} operator is found, it
    captures the operator, then parses the right-hand side of the
    AND expression using [parse_equality]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the
    [AND]{.title-ref} operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Repeats the process to handle additional chained AND
    operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the logical AND expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_equality-method">parse_equality Method</h2>
<p>| <strong>Description:</strong>
| Parses equality expressions, handling both equality ([==]{.title-ref})
  and inequality ([!=]{.title-ref}) operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the equality or inequality expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the equality expression using [parse_relational]{.title-ref}.</p>
<ol>
<li><strong>Chained Equality Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token represents an
    equality ([==]{.title-ref}) or inequality ([!=]{.title-ref})
    operator.</li>
<li><strong>Action:</strong> If such an operator is found, it captures the
    operator, then parses the right-hand side of the equality
    expression using [parse_relational]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the equality or
    inequality operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Continues to handle additional chained equality or
    inequality operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the equality or inequality expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_relational-method">parse_relational Method</h2>
<p>| <strong>Description:</strong>
| Parses relational expressions, handling operations such as less than
  ([\&lt;]{.title-ref}), greater than ([&gt;]{.title-ref}), less than or
  equal to ([\&lt;=]{.title-ref}), and greater than or equal to
  ([&gt;=]{.title-ref}).</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the relational expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the relational expression using [parse_additive]{.title-ref}.</p>
<ol>
<li><strong>Chained Relational Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token represents a
    relational operator ([\&lt;]{.title-ref}, [&gt;]{.title-ref},
    [\&lt;=]{.title-ref}, [&gt;=]{.title-ref}).</li>
<li><strong>Action:</strong> If such an operator is found, it captures the
    operator, then parses the right-hand side of the relational
    expression using [parse_additive]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the relational
    operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Continues to handle additional chained relational
    operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the relational expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_additive-method_1">parse_additive Method</h2>
<p>| <strong>Description:</strong>
| Parses additive expressions, handling addition ([+]{.title-ref}) and
  subtraction ([-]{.title-ref}) operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the additive expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the additive expression using
  [parse_multiplicative]{.title-ref}.</p>
<ol>
<li><strong>Chained Additive Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token represents an
    additive operator ([+]{.title-ref}, [-]{.title-ref}).</li>
<li><strong>Action:</strong> If such an operator is found, it captures the
    operator, then parses the right-hand side of the additive
    expression using [parse_multiplicative]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the additive
    operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Continues to handle additional chained additive
    operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the additive expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_multiplicative-method_1">parse_multiplicative Method</h2>
<p>| <strong>Description:</strong>
| Parses multiplicative expressions, handling multiplication
  ([*]{.title-ref}) and division ([/]{.title-ref}) operations.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing
  the multiplicative expression.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Initial Parsing:</strong> - <strong>Method:</strong> Begins by parsing the left-hand
  side of the multiplicative expression using [parse_unary]{.title-ref}.</p>
<ol>
<li><strong>Chained Multiplicative Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token represents a
    multiplicative operator ([*]{.title-ref}, [/]{.title-ref}).</li>
<li><strong>Action:</strong> If such an operator is found, it captures the
    operator, then parses the right-hand side of the multiplicative
    expression using [parse_unary]{.title-ref}.</li>
<li><strong>Update:</strong> Updates the [left]{.title-ref} operand to a
    [BinaryOpNode]{.title-ref} that combines the current
    [left]{.title-ref} and [right]{.title-ref} with the
    multiplicative operator.</li>
</ul>
</li>
<li><strong>Loop:</strong><ul>
<li><strong>Action:</strong> Continues to handle additional chained
    multiplicative operators, if present.</li>
</ul>
</li>
<li><strong>Return:</strong><ul>
<li><strong>Return:</strong> Returns the final [BinaryOpNode]{.title-ref}
    representing the multiplicative expression.</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_unary-method">parse_unary Method</h2>
<p>| <strong>Description:</strong>
| Parses unary operations, such as unary plus ([+]{.title-ref}) and
  unary minus ([-]{.title-ref}), and delegates to
  [parse_primary]{.title-ref} for other expressions.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - [UnaryOpNode]{.title-ref} or result of `parse_primary`: Returns a
  [UnaryOpNode]{.title-ref} for unary operations or the result of
  [parse_primary]{.title-ref} for other expressions.</p>
<p>| <strong>Method Details:</strong>
| 1. <strong>Unary Operation Handling:</strong> - <strong>Condition:</strong> Checks if the
  current token represents a unary operator ([+]{.title-ref},
  [-]{.title-ref}). - <strong>Action:</strong> If a unary operator is found, it
  captures the operator and recursively parses the operand using
  [parse_unary]{.title-ref}. - <strong>Return:</strong> Creates and returns a
  [UnaryOpNode]{.title-ref} with the captured operator and the parsed
  operand.</p>
<ol>
<li><strong>Primary Expression Handling:</strong><ul>
<li><strong>Condition:</strong> If no unary operator is present, delegates to
    [parse_primary]{.title-ref} to handle the expression.</li>
<li><strong>Return:</strong> Returns the result of [parse_primary]{.title-ref},
    which handles basic expressions (e.g., literals, variables).</li>
</ul>
</li>
</ol>
<p>| <strong>Errors Raised:</strong>
| - <strong>SyntaxError:</strong> May raise errors if unexpected tokens are
  encountered, although not explicitly handled in this method.</p>
<h2 id="parse_primary-method_1">parse_primary Method</h2>
<p>| <strong>Description:</strong>
| Parses primary expressions, which include literals, variables, type
  annotations, and function calls.</p>
<p>| <strong>Parameters:</strong>
| - None</p>
<p>| <strong>Returns:</strong>
| - A [VariableNode]{.title-ref}, a literal value, or a parsed function
  call or identifier.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li><strong>Literals and Variables:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is a literal type
    ([INT]{.title-ref}, [FLOAT]{.title-ref}, [BOOL]{.title-ref},
    [STRING]{.title-ref}) or [NUMBER]{.title-ref}.<ul>
<li><strong>Action:</strong><ul>
<li>For literal types, if followed by an
    [IDENTIFIER]{.title-ref}, it creates a
    [VariableNode]{.title-ref} with optional type
    annotation.</li>
<li>For [NUMBER]{.title-ref}, it returns the literal value.</li>
</ul>
</li>
<li><strong>Return:</strong> Constructs and returns a
    [VariableNode]{.title-ref} or literal value.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Parentheses Handling:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is an opening
    parenthesis ([LPAREN]{.title-ref}).<ul>
<li><strong>Action:</strong> If so, it parses the enclosed expression and
    expects a closing parenthesis ([RPAREN]{.title-ref}).</li>
<li><strong>Return:</strong> Returns the parsed expression enclosed by
    parentheses.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Function Calls or Identifiers:</strong><ul>
<li><strong>Condition:</strong> Handles cases where the current token indicates a
    function call or an identifier.<ul>
<li><strong>Action:</strong> Calls
    [parse_function_call_or_identifier]{.title-ref} to parse
    further.</li>
<li><strong>Return:</strong> Result of
    [parse_function_call_or_identifier]{.title-ref}.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Top-Level Keywords:</strong><ul>
<li><strong>Condition:</strong> If the current token is a top-level keyword
    ([FN]{.title-ref}, [STRUCT]{.title-ref}, [CLASS]{.title-ref},
    [LET]{.title-ref}, [VAR]{.title-ref}).<ul>
<li><strong>Action:</strong> Raises a [SyntaxError]{.title-ref} since such
    keywords should not appear in expressions.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Unexpected Tokens:</strong><ul>
<li><strong>Condition:</strong> Handles any unexpected token.<ul>
<li><strong>Action:</strong> Raises a [SyntaxError]{.title-ref} for
    unexpected tokens in the expression context.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Errors Raised:</strong> - <strong>SyntaxError:</strong> Raised for unexpected tokens or
top-level keywords encountered in the expression context.</p>
<h2 id="parse_vector_constructor-method">parse_vector_constructor Method</h2>
<p>| <strong>Description:</strong>
| Parses a vector constructor expression from the current token stream.
  This typically involves handling a list of expressions enclosed in
  parentheses, representing the components of a vector.</p>
<p>| <strong>Parameters:</strong>
| - <strong>`type_name:`</strong> A string representing the type of the vector
  (e.g., [vec2]{.title-ref}, [vec3]{.title-ref}).</p>
<p>| <strong>Returns:</strong>
| - A [VectorConstructorNode]{.title-ref} instance with the vector type
  and its components.</p>
<p><strong>Method Details:</strong></p>
<ol>
<li><strong>Opening Parenthesis:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is an opening
    parenthesis ([LPAREN]{.title-ref}).</li>
<li><strong>Action:</strong> Eats the [LPAREN]{.title-ref} token.</li>
</ul>
</li>
<li><strong>Parsing Arguments:</strong><ul>
<li><strong>Action:</strong> Initializes an empty list [args]{.title-ref} to
    store the components of the vector.</li>
<li><strong>Loop:</strong> While the current token is not a closing parenthesis
    ([RPAREN]{.title-ref}):<ul>
<li><strong>Action:</strong> Parses an expression and appends it to
    [args]{.title-ref}.</li>
<li><strong>Condition:</strong> If a comma ([COMMA]{.title-ref}) follows an
    expression, eats the comma.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Closing Parenthesis:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is a closing
    parenthesis ([RPAREN]{.title-ref}).</li>
<li><strong>Action:</strong> Eats the [RPAREN]{.title-ref} token.</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li><strong>Return:</strong> Constructs and returns a
    [VectorConstructorNode]{.title-ref} with [type_name]{.title-ref}
    and the parsed [args]{.title-ref}.</li>
</ul>
</li>
</ol>
<p><strong>Errors Raised:</strong> - <strong>None:</strong> The method assumes correct syntax for
vector constructors and handles it accordingly. However, additional
error handling may be required if the input is not as expected.</p>
<p><strong>parse_function_call Method</strong></p>
<ul>
<li><strong>Description:</strong><ul>
<li>Parses function call expressions from the current token stream.
    This involves handling function arguments enclosed in
    parentheses.</li>
</ul>
</li>
<li><strong>Parameters:</strong><ul>
<li>`name`: The name of the function being called.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>A [FunctionCallNode]{.title-ref} instance representing the
    function call with its arguments.</li>
</ul>
</li>
<li><strong>Method Details:</strong><ol>
<li><strong>Opening Parenthesis:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is an opening
    parenthesis ([LPAREN]{.title-ref}).</li>
<li><strong>Action:</strong> Eats the [LPAREN]{.title-ref} token.</li>
</ul>
</li>
<li><strong>Parsing Arguments:</strong><ul>
<li>Initializes an empty list [args]{.title-ref} to store the
    function arguments.</li>
<li>While the current token is not a closing parenthesis
    ([RPAREN]{.title-ref}):<ul>
<li>Parses an expression and appends it to
    [args]{.title-ref}.</li>
<li>If a comma ([COMMA]{.title-ref}) follows an expression,
    eats the comma.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Closing Parenthesis:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is a closing
    parenthesis ([RPAREN]{.title-ref}).</li>
<li><strong>Action:</strong> Eats the [RPAREN]{.title-ref} token.</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li>Constructs and returns a [FunctionCallNode]{.title-ref} with
    the specified [name]{.title-ref} and the parsed
    [args]{.title-ref}.</li>
</ul>
</li>
</ol>
</li>
<li><strong>Errors Raised:</strong><ul>
<li>None: The method assumes correct syntax for function calls and
    handles it accordingly. Additional error handling may be
    required if the input is not as expected.</li>
</ul>
</li>
</ul>
<p><strong>parse_member_access Method</strong></p>
<ul>
<li><strong>Description:</strong><ul>
<li>Parses member access expressions from the current token stream.
    This involves handling dot notation for accessing object members
    (e.g., [object.member]{.title-ref}).</li>
</ul>
</li>
<li><strong>Parameters:</strong><ul>
<li>`object`: The object from which the member is accessed.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>A [MemberAccessNode]{.title-ref} instance representing the
    accessed member.</li>
</ul>
</li>
<li><strong>Method Details:</strong><ol>
<li><strong>Dot Token:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is a dot
    ([DOT]{.title-ref}).</li>
<li><strong>`Action:`</strong> Eats the dot token.</li>
</ul>
</li>
<li><strong>Member Identifier:</strong><ul>
<li><strong>Condition:</strong> Ensures that the next token is an identifier
    ([IDENTIFIER]{.title-ref}).</li>
<li><strong>`Action:`</strong> Retrieves the member name from the current
    token.</li>
<li><strong>`Action:`</strong> Eats the identifier token.</li>
</ul>
</li>
<li><strong>Function Call Check:</strong><ul>
<li><strong>Condition:</strong> If the next token is an opening parenthesis
    ([LPAREN]{.title-ref}), it indicates a function call.</li>
<li><strong>`Action:`</strong> Calls the [parse_function_call]{.title-ref}
    method with the member name.</li>
</ul>
</li>
<li><strong>Nested Member Access Check:</strong><ul>
<li><strong>Condition:</strong> If the next token is another dot
    ([DOT]{.title-ref}), it indicates nested member access.</li>
<li><strong>`Action:`</strong> Recursively calls the
    [parse_member_access]{.title-ref} method with the updated
    [MemberAccessNode]{.title-ref}.</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li>Constructs and returns a [MemberAccessNode]{.title-ref} with
    the specified [object]{.title-ref} and the parsed
    [member]{.title-ref}.</li>
</ul>
</li>
</ol>
</li>
<li><strong>Errors Raised:</strong><ul>
<li>None: The method assumes correct syntax for member access and
    handles it accordingly. Additional error handling may be
    required if the input is not as expected.</li>
</ul>
</li>
</ul>
<p><strong>parse_decorator Method</strong></p>
<ul>
<li><strong>Description:</strong><ul>
<li>Parses decorator expressions from the current token stream.
    Decorators are typically used in Python to modify or enhance
    functions or classes.</li>
</ul>
</li>
<li><strong>Returns:</strong><ul>
<li>A [DecoratorNode]{.title-ref} instance representing the
    decorator with its name and arguments (if any).</li>
</ul>
</li>
<li><strong>Method Details:</strong><ol>
<li><strong>Decorator Token:</strong><ul>
<li><strong>Condition:</strong> Checks if the current token is a decorator
    ([DECORATOR]{.title-ref}).</li>
<li><strong>`Action:`</strong> Eats the decorator token.</li>
</ul>
</li>
<li><strong>Decorator Name:</strong><ul>
<li>Retrieves the decorator name from the current token.</li>
</ul>
</li>
<li><strong>Parsing Arguments (if present):</strong><ul>
<li>If the next token is an opening parenthesis
    ([LPAREN]{.title-ref}), it indicates decorator arguments.</li>
<li>Initializes an empty list [args]{.title-ref} to store the
    decorator arguments.</li>
<li>While the current token is not a closing parenthesis
    ([RPAREN]{.title-ref}):<ul>
<li>Parses an expression and appends it to
    [args]{.title-ref}.</li>
<li>If a comma ([COMMA]{.title-ref}) follows an expression,
    eats the comma.</li>
</ul>
</li>
<li>Eats the closing parenthesis ([RPAREN]{.title-ref}).</li>
</ul>
</li>
<li><strong>Return Statement:</strong><ul>
<li>Constructs and returns a [DecoratorNode]{.title-ref} with
    the specified [name]{.title-ref} and the parsed
    [args]{.title-ref}.</li>
</ul>
</li>
</ol>
</li>
<li><strong>Errors Raised:</strong><ul>
<li>None: The method assumes correct syntax for decorators and
    handles it accordingly. Additional error handling may be
    required if the input is not as expected.</li>
</ul>
</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["header.autohide", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.path", "navigation.indexes", "navigation.instant", "navigation.instant.progress", "content.code.copy"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>