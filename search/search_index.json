{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CrossGL Docs!","text":"<p>We're more than just a company, we're a group of passionate individuals working together to shape the future of AI-driven hardware optimization and cross-platform graphics development.</p> <p>With our groundbreaking tools, <code>DYSON</code> and <code>GRAPHICA</code>, we're empowering businesses to tackle inefficiencies in cloud infrastructure and graphics development.</p> <p>Solving complex problems takes collaboration, creativity, and a shared vision. At CrossGL, you won't just be joining a team\u2014you'll be joining a network of innovators and creators, all working towards a common goal of transforming AI and graphics.</p> <p>We value diverse perspectives, continuous learning, and the spirit of collaboration that drives real change. Join us in shaping the future of technology.</p> <ul> <li> <p> Set up <code>Dyson</code> in minutes</p> <p>Install <code>dyson</code> with <code>pip</code> and get up and running in minutes.</p> <p> Getting started</p> </li> <li> <p> Explore <code>Graphica</code> and <code>CrossGL</code></p> <p>Install <code>graphica</code> with <code>pip</code> and get access to our cross-platform shader language.</p> <p> Getting Started</p> </li> </ul>"},{"location":"pages/dyson/billing/","title":"Dyson Billing Overview","text":"<p>Welcome to the Dyson Billing page! Here, we'll walk you through everything you need to know about how we charge, manage credits, and track your usage. Our goal is to make the billing process transparent, flexible, and easy to manage, so you can focus on optimizing your hardware resources.</p>"},{"location":"pages/dyson/billing/#how-dyson-charges-you","title":"How Dyson Charges You","text":"<p>Dyson operates on a credit-based billing system. This means you purchase and use credits to pay for optimization services as you go. [See price here : ].</p>"},{"location":"pages/dyson/billing/#add-your-payment-method","title":"Add Your Payment Method:","text":"<ol> <li>Once you\u2019ve signed up, head to the Billing page.</li> <li>Click Go to Portal and follow the prompts to add your payment method.</li> </ol>"},{"location":"pages/dyson/billing/#receive-free-credits","title":"Receive Free Credits:","text":"<ul> <li>Upon adding your payment method, you\u2019ll receive $15 in free credits to get started! \ud83c\udf89</li> </ul>"},{"location":"pages/dyson/billing/#usage-based-charges","title":"Usage-Based Charges:","text":"<ul> <li>Dyson charges credits for each request, which can vary depending on the size, complexity, and type of hardware being used (e.g., CPU, GPU, TPU, or FPGA).</li> <li>The system tracks the number of credits required in real-time and deducts them from your balance accordingly.</li> </ul>"},{"location":"pages/dyson/billing/#view-and-manage-credits","title":"View and Manage Credits:","text":"<ul> <li>You can view your available balance, top-up credits, and set up automatic refills to avoid disruptions.</li> </ul>"},{"location":"pages/dyson/billing/#transparent-invoicing","title":"Transparent Invoicing:","text":"<ul> <li>Full usage reports and invoices are available to download from the Billing page, so you\u2019ll always have a clear picture of where your credits are going.</li> </ul>"},{"location":"pages/dyson/billing/#what-youre-charged-for","title":"What You\u2019re Charged For","text":"<p>When using Dyson, you\u2019ll be charged credits for the following services:</p> <ol> <li>Optimization Requests: Every time Dyson routes your code to the most efficient hardware, credits are deducted based on the computational load and the hardware type used.</li> <li>Hardware Usage: The cost of running tasks on specific hardware (e.g., GPUs, TPUs, FPGAs) will vary, as some hardware has higher associated costs.</li> <li>Telemetry and Monitoring: Access to real-time telemetry and performance reports are included, but certain enterprise features may incur additional charges.</li> </ol> <p>Our system ensures you\u2019re only paying for the value Dyson provides, and you\u2019ll never be charged beyond your credit balance.</p>"},{"location":"pages/dyson/billing/#how-to-view-your-credit-balance","title":"How to View Your Credit Balance","text":"<p>You can view your available credit balance directly on the Billing page. Here\u2019s how:</p> <ol> <li>Log in to your Dyson account.</li> <li>Go to the Billing section.</li> <li>You\u2019ll see your current balance at the top of the page, along with options to top-up credits or enable automatic refills.</li> </ol> <p>Additionally, you can check your credit balance via navigating to our dashboard here.</p> <p>Example: This simple UI allows you to track your credits on-the-go, so you\u2019re never left guessing how much is left in your balance.</p>"},{"location":"pages/dyson/billing/#how-to-add-credits","title":"How to Add Credits","text":"<p>Running low on credits? Here\u2019s how to top up your balance:</p> <ol> <li>Go to the Billing page.</li> <li>Click the Top-Up button.</li> <li>Select a credit package (e.g., $25, $50, $100) or enter a custom amount.</li> <li>Confirm your payment method and complete the purchase.</li> </ol> <p>To make things even easier, you can enable Auto-Refill to automatically top up your credits whenever your balance drops below a certain threshold.</p>"},{"location":"pages/dyson/billing/#how-auto-refill-works","title":"How Auto-Refill Works","text":"<p>Never get caught without credits! With Auto-Refill, Dyson will automatically add credits to your account when your balance is low.</p> <ol> <li>Go to the Billing page.</li> <li>Click Enable Auto-Refill.</li> <li>Set your trigger balance (e.g., when balance drops below 50 credits).</li> <li>Select the amount you\u2019d like to top up by (e.g., 100 credits).</li> <li>Save your preferences, and Dyson will handle the rest!</li> </ol> <p>This feature ensures uninterrupted optimization services, so you\u2019re never left without the resources you need.</p>"},{"location":"pages/dyson/billing/#view-and-download-invoices","title":"View and Download Invoices","text":"<ol> <li>Go to the Billing page.</li> <li>Click View Invoices to see a list of all past transactions.</li> <li>Download PDF versions of invoices for easy record-keeping.</li> </ol>"},{"location":"pages/dyson/billing/#need-help","title":"Need Help?","text":"<p>If you run into any issues or have questions about your billing or account, we\u2019re here to help. You can reach out via contact@crossgl.net directly.</p> <p>That\u2019s it! You\u2019re now ready to manage your Dyson credits and start exploring hardware like a pro \ud83c\udf31.</p>"},{"location":"pages/dyson/getting-started/","title":"GETTING STARTED","text":""},{"location":"pages/dyson/getting-started/#quick-start-guide","title":"Quick Start Guide","text":"<p>It\u2019s easiest to get started using our Python client. Simply install the package:</p> <ul> <li>Install the <code>dyson</code> package using pip:</li> </ul> <pre><code>pip install dyson   \n</code></pre> <ul> <li> <p>SignUp/LogIn to the Dyson <code>dashboard</code></p> </li> <li> <p>Obtain your first custom API Key for Free!</p> </li> <li> <p>Generate and securely store your API key in a <code>key.cgl</code> file.</p> </li> </ul> <pre><code>import dyson\nimport torch\nimport time\nfrom dyson import router\n\n# Define a function\ndef mat(a, b):\n    return torch.matmul(a,b)\n\n\n</code></pre>"},{"location":"pages/dyson/getting-started/#routing-your-workload","title":"Routing Your Workload","text":"<p>Add the <code>key.cgl</code> path in your code like so,</p> <pre><code>key_path = \"path/to/your/key.cgl\"\n</code></pre> <p>Add your function with <code>parameter</code> values.</p> <pre><code>hardware = router.route_hardware(\n    key_path,                     \n    physics_function,             \n    mode=\"energy-efficient\",      \n    judge=3,                      \n    run_type=\"log\",               \n    complexity=\"medium\",         \n    precision=\"normal\",           \n    multi_device=True             \n) \n</code></pre> <p>We now have the hardware name required for routing. This can be passed as a parameter to the dyson.run() function, enabling it to route to the specified hardware.</p> <pre><code># Compile the function for CUDA (or CPU)\nfunc = dyson.run(mat, target_device=hardware)\n\n# Execute the function with arguments\na = torch.randn(1000, 1000)\nb = torch.randn(1000, 1000)\nresult = func(a, b)\n\nprint(result)\n</code></pre>"},{"location":"pages/dyson/overview/","title":"Dyson Router Documentation","text":"<p>Go to app\u2007</p>"},{"location":"pages/dyson/overview/#introduction","title":"Introduction","text":"<p>The Dyson Router is a cutting-edge solution designed to dynamically route computational workloads to the most optimal hardware in real-time. By leveraging advanced AI-driven hardware mapping techniques, Dyson delivers unprecedented performance and efficiency.</p>"},{"location":"pages/dyson/overview/#key-benefits","title":"Key Benefits","text":"<ul> <li>Improved Performance: Intelligently run workloads on hardware specifically optimized for your use case</li> <li>Cost Efficiency: Achieve up to 20% cost savings on hardware usage</li> <li>Future-Proofing: Seamlessly adapt as new hardware options emerge</li> <li>Resilience: Automatically reroute workloads away from underperforming or degraded hardware</li> </ul>"},{"location":"pages/dyson/overview/#how-dyson-works","title":"How Dyson Works","text":"<p>Dyson revolutionizes hardware routing through a sophisticated three-step approach:</p> <ol> <li> <p>Hardware Profiling</p> </li> <li> <p>Builds comprehensive performance profiles for each available hardware option</p> </li> <li> <p>Ensures routing decisions are based on in-depth, data-driven analysis</p> </li> <li> <p>Dynamic Workload Routing</p> </li> <li> <p>Evaluates each request comprehensively</p> </li> <li> <p>Routes to the hardware configuration most suited to its unique requirements</p> </li> <li> <p>Continuous Optimization</p> </li> <li>Monitors performance in real-time</li> <li>Adapts dynamically to changing computational conditions</li> <li>Guarantees consistently efficient workload execution</li> </ol>"},{"location":"pages/dyson/overview/#advanced-routing-parameters","title":"Advanced Routing Parameters","text":"Parameter Description Default Value Possible Values <code>mode</code> Defines optimization criteria <code>performance</code> <code>energy-efficient</code>, <code>performance</code> <code>judge</code> Number of LLMs used to determine hardware suitability <code>1</code> Integer (1-5) <code>run_type</code> Specifies execution log type <code>minimal</code> <code>log</code>, <code>minimal</code>, <code>detailed</code> <code>complexity</code> Indicates task complexity level <code>low</code> <code>low</code>, <code>medium</code>, <code>high</code> <code>precision</code> Defines required precision level <code>normal</code> <code>low</code>, <code>normal</code>, <code>high</code> <code>multi_device</code> Enables routing across multiple devices <code>False</code> <code>True</code>, <code>False</code>"},{"location":"pages/dyson/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Always securely manage your API key</li> <li>Start with lower complexity and precision settings</li> <li>Monitor initial routing results</li> <li>Gradually increase <code>judge</code> parameter for more refined hardware selection</li> <li>Utilize <code>multi_device</code> for complex, resource-intensive workloads</li> </ol>"},{"location":"pages/dyson/overview/#support","title":"Support","text":"<p>For additional support, contact Dyson technical support support@crossgl.net.</p>"},{"location":"pages/graphica/api_reference/","title":"API References For CrossGL To DirectX , Metal And OpenGL","text":""},{"location":"pages/graphica/api_reference/#directx-code-generation","title":"DirectX Code Generation","text":"<p>The [HLSLCodeGen]{.title-ref} class within the CrossGL framework is pivotal in translating CrossGL shader abstract syntax trees (AST) into HLSL (High-Level Shader Language) code, which is essential for DirectX applications. This class systematically converts the AST (representing the logical structure of a shader) into corresponding HLSL code that can be executed in DirectX environments.</p> <ul> <li> <p>Attributes</p> <p>:   -   current_shader (ShaderNode) : The current shader node being         processed.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#methods","title":"Methods","text":"<ul> <li> <p>__init__(self) :</p> <p>Initializes the code generator.</p> </li> </ul> <p>---</p> <ul> <li> <p>generate(self, ast)</p> <p>:   Generates HLSL code from the AST.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [ast (ShaderNode)]{.title-ref} -- The abstract\n            syntax tree of the shader.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>generate_shader(self, node)</p> <p>:   Generates the HLSL code for the shader.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (ShaderNode)]{.title-ref} -- The shader node\n            of the AST.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> </li> </ul> <p>---</p> <p>check_gl_position(self, node)</p> <p>:   Checks if the [gl_Position]{.title-ref} output is assigned within     the vertex shader.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (ASTNode)]{.title-ref} -- The current node being\n            processed in the AST.\n\n-\n\n    **Returns:**\n\n    :   -   [None]{.title-ref}\n</code></pre> <p>---</p> <p>generate_intermidiate(self, node, shader_type)</p> <p>:   Generates intermediate shader code by processing a sequence of     statements.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (list\\[ASTNode\\])]{.title-ref} -- A list of AST\n            nodes representing the statements to be processed.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., vertex, fragment) for which the code is being\n            generated.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated intermediate shader\n            code as a string.\n</code></pre> <p>---</p> <p>generate_main(self, node, shader_type)</p> <p>:   Generates the main function code for a shader, tailored to the     specified shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (FunctionNode)]{.title-ref} -- The function node\n            of the AST containing the body of the main function.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., \\\"vertex\\\" or \\\"fragment\\\") for which the main\n            function code is being generated.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated main function code as\n            a string.\n</code></pre> <p>---</p> <p>generate_function(self, node)</p> <p>:   Generates the HLSL code for a function.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (FunctionNode)]{.title-ref} -- The function node\n            of the AST.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>generate_statement(self, stmt, indent=0, is_vs_input=False)</p> <p>:   Generates the HLSL code for a statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node of\n            the AST.\n        -   [indent (int)]{.title-ref} -- The indentation level.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the\n            statement is in the vertex shader input.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>generate_assignment(self, node, is_vs_input=False)</p> <p>:   Generates the HLSL code for an assignment statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment\n            node of the AST.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the\n            assignment is in the vertex shader input.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>generate_if(self, node, indent, is_vs_input=False)</p> <p>:   Generates the HLSL code for an if statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (IfNode)]{.title-ref} -- The if statement node of\n            the AST.\n        -   [indent (int)]{.title-ref} -- The indentation level.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the if\n            statement is in the vertex shader input.\n\n-\n\n    **Returns:**\n\n    :   -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>generate_for(self, node, indent, is_vs_input=False)</p> <p>:   Generates the HLSL code for a for loop statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (ForNode)]{.title-ref} -- The for loop node of the\n            AST.\n        -   [indent (int)]{.title-ref} -- The indentation level.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the for loop\n            is in the vertex shader input.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>generate_expression(self, expr, is_vs_input=False)</p> <p>:   Generates the HLSL code for an expression.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (ASTNode)]{.title-ref} -- The expression node of\n            the AST.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the\n            expression is in the vertex shader input.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated HLSL code.\n</code></pre> <p>---</p> <p>translate_expression(self, expr, is_vs_input)</p> <p>:   Translates an expression from CrossGL syntax to HLSL syntax.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (str)]{.title-ref} -- The expression in CrossGL\n            syntax.\n        -   [is_vs_input (bool)]{.title-ref} -- Whether the\n            expression is in the vertex shader input.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The translated expression.\n</code></pre> <p>---</p> <p>map_type(self, vtype)</p> <p>:   Maps CrossGL types to HLSL types.</p> <pre><code>-   **Parameters:**\n    -   [vtype (str)]{.title-ref} -- The CrossGL type.\n-   **Returns:**\n    -   [str]{.title-ref} -- The corresponding HLSL type.\n</code></pre> <p>---</p> <p>map_operator(self, op)</p> <p>:   Maps CrossGL operators to HLSL operators.</p> <pre><code>-   **Parameters:**\n    -   [op (str)]{.title-ref} -- The CrossGL operator.\n-   **Returns:**\n    -   [str]{.title-ref} -- The corresponding HLSL operator.\n</code></pre> <p>---</p> <p>Example</p> <p>Here's an example usage of the HLSLCodeGen class to generate HLSL code from a CrossGL shader:</p> <pre><code>from compiler.lexer import Lexer\nfrom compiler.parser import Parser\n\ncode = \"\"\"\nshader main {\n    input vec3 position;\n    input vec2 texCoord;\n    input mat2 depth;\n    output vec4 fragColor;\n    output float depth;\n    vec3 customFunction(vec3 random, float factor) {\n        return random * factor;\n    }\n\n    void main() {\n        vec3 color = vec3(position.x,position.y, 0.0);\n        float factor = 1.0;\n\n        if (texCoord.x &gt; 0.5) {\n            color = vec3(1.0, 0.0, 0.0);\n        } else {\n            color = vec3(0.0, 1.0, 0.0);\n        }\n\n        for (int i = 0; i &lt; 3; i = i + 1) {\n            factor = factor * 0.5;\n            color = customFunction(color, factor);\n        }\n\n        if (length(color) &gt; 1.0) {\n            color = normalize(color);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n\"\"\"\nlexer = Lexer(code)\nparser = Parser(lexer.tokens)\nast = parser.parse()\n\ncodegen = HLSLCodeGen()\nhlsl_code = codegen.generate(ast)\nprint(hlsl_code)\n</code></pre>"},{"location":"pages/graphica/api_reference/#metal-codegen","title":"Metal Codegen","text":"<p>The MetalCodeGen class in the CrossGL framework plays a crucial role in converting the abstract syntax tree (AST) of CrossGL shaders into Metal shading language (MSL) code, optimized for Apple's Metal API. This class ensures that CrossGL shaders are efficiently translated into MSL, enabling their execution on Apple platforms, including macOS, iOS, and iPadOS.</p> <ul> <li> <p>Attributes</p> <p>:   -   current_shader (ShaderNode) : The current shader node being         processed.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#methods_1","title":"Methods","text":"<p>__init__(self)</p> <p>:   Initializes the code generator.</p> <p>---</p> <p>generate(self, ast)</p> <p>:   Generates the complete shader code from the given abstract syntax     tree (AST).</p> <pre><code>-   **Parameters:**\n    -   [ast (ASTNode)]{.title-ref} -- The root node of the AST,\n        typically a ShaderNode, representing the entire shader.\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated shader code as a string,\n        or an empty string if the AST is not a ShaderNode.\n</code></pre> <p>---</p> <p>generate_shader(self, node)</p> <p>:   Generates the complete Metal shading language (MSL) code for a     shader from its abstract syntax tree (AST).</p> <pre><code>-   **Parameters:**\n    -   [node (ShaderNode)]{.title-ref} -- The root node of the AST\n        representing the entire shader, including its global inputs,\n        outputs, and shader stages (vertex and fragment).\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated MSL code as a string.\n</code></pre> <p>---</p> <p>check_gl_position(self, node)</p> <p>:   Generates intermediate shader code by processing a sequence of     statements.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (list\\[ASTNode\\])]{.title-ref} -- A list of AST\n            nodes representing the statements to be processed.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., vertex, fragment) for which the code is being\n            generated.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated intermediate shader code\n        as a string.\n</code></pre> <p>---</p> <p>generate_intermidiate(self, node, shader_type)</p> <p>:   Generates intermediate shader code by processing a sequence of     statements.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (list\\[ASTNode\\])]{.title-ref} -- A list of AST\n            nodes representing the statements to be processed.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., vertex, fragment) for which the code is being\n            generated.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated intermediate shader code\n        as a string.\n</code></pre> <p>---</p> <p>generate_function(self, node, shader_type)</p> <p>:   Generates shader function code based on the function nodes and     shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (list\\[FunctionNode\\] \\|\n            FunctionNode)]{.title-ref} -- A list of function nodes\n            or a single function node, depending on the shader type.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., \"vertex\", \"fragment\", \"global\") for which the\n            function code is being generated.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated shader function code as a\n        string.\n</code></pre> <p>---</p> <p>generate_main(self, node, shader_type)</p> <p>:   Generates the main function code for the specified shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (FunctionNode)]{.title-ref} -- The function node\n            representing the main function in the shader's AST.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\"vertex\" or \"fragment\") for which the main function\n            code is being generated.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated main function code as a\n        string.\n</code></pre> <p>---</p> <p>generate_statement(self, stmt, indent=0, shader_type=None)</p> <p>:   Generates code for a given statement, with support for different     statement types and optional indentation.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node to be\n            converted to code.\n        -   [indent (int, optional)]{.title-ref} -- The indentation\n            level for the generated code. Defaults to 0.\n        -   [shader_type (str, optional)]{.title-ref} -- The type of\n            shader (e.g., vertex, fragment), used for\n            context-specific code generation.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated code for the statement as\n        a string.\n</code></pre> <p>---</p> <p>generate_assignment(self, node, shader_type=None)</p> <p>:   Generates the code for an assignment statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment\n            node containing the variable name and the value to be\n            assigned.\n        -   [shader_type (str, optional)]{.title-ref} -- The type of\n            shader (e.g., vertex, fragment), which influences how\n            the assignment is generated.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated assignment code as a\n        string.\n</code></pre> <p>---</p> <p>generate_if(self, node, indent, shader_type=None)</p> <p>:   Generates code for an if statement, including optional else body.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (IfNode)]{.title-ref} -- The IfNode containing the\n            condition, if body statements, and optionally else body\n            statements.\n        -   [indent (int)]{.title-ref} -- The indentation level for\n            the generated code.\n        -   [shader_type (str, optional)]{.title-ref} -- The type of\n            shader (e.g., vertex, fragment), used for\n            context-specific code generation.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated if statement code as a\n        string.\n</code></pre> <p>---</p> <p>generate_for(self, node, indent, shader_type=None)</p> <p>:   Generates code for a for loop statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (ForNode)]{.title-ref} -- The ForNode containing\n            initialization, condition, update expressions, and the\n            loop body.\n        -   [indent (int)]{.title-ref} -- The indentation level for\n            the generated code.\n        -   [shader_type (str, optional)]{.title-ref} -- The type of\n            shader (e.g., vertex, fragment), used for\n            context-specific code generation.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated for loop code as a\n        string.\n</code></pre> <p>---</p> <p>generate_expression(self, expr, shader_type=None)</p> <p>:   Generates code for an expression, handling various types of     expression nodes.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (ASTNode)]{.title-ref} -- The expression node to\n            be converted into code.\n        -   [shader_type (str, optional)]{.title-ref} -- The type of\n            shader (e.g., vertex, fragment), used for\n            context-specific code generation.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated expression code as a\n        string.\n</code></pre> <p>---</p> <p>translate_expression(self, expr, shader_type)</p> <p>:   Translates an expression to its corresponding shader code     representation, based on the shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (str)]{.title-ref} -- The expression to be\n            translated.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (e.g., vertex, fragment), used for context-specific\n            translation.\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The translated expression code as a\n        string.\n</code></pre> <p>---</p> <p>map_type(self, vtype)</p> <p>:   Maps a type identifier to its corresponding shader type     representation.</p> <pre><code>-   **Parameters:**\n    -   [vtype (str)]{.title-ref} -- The type identifier to be\n        mapped.\n-   **Returns:**\n    -   [str]{.title-ref} -- The mapped shader type representation.\n</code></pre> <p>---</p> <p>map_operator(self, op)</p> <p>:   Maps an operator identifier to its corresponding shader code     representation.</p> <pre><code>-   **Parameters:**\n    -   [op (str)]{.title-ref} -- The operator identifier to be\n        mapped.\n-   **Returns:**\n    -   [str]{.title-ref} -- The mapped shader operator\n        representation.\n</code></pre> <p>---</p> <p>Example</p> <p>Here's an example usage of the MetalCodeGen class to generate Metal code from a CrossGL shader:</p> <pre><code>from compiler.lexer import Lexer\nfrom compiler.parser import Parser\n\ncode = \"\"\"\nshader main {\n    input vec3 position;\n    input vec2 texCoord;\n    input mat2 depth;\n    output vec4 fragColor;\n    output float depth;\n    vec3 customFunction(vec3 random, float factor) {\n        return random * factor;\n    }\n\n    void main() {\n        vec3 color = vec3(position.x,position.y, 0.0);\n        float factor = 1.0;\n\n        if (texCoord.x &gt; 0.5) {\n            color = vec3(1.0, 0.0, 0.0);\n        } else {\n            color = vec3(0.0, 1.0, 0.0);\n        }\n\n        for (int i = 0; i &lt; 3; i = i + 1) {\n            factor = factor * 0.5;\n            color = customFunction(color, factor);\n        }\n\n        if (length(color) &gt; 1.0) {\n            color = normalize(color);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n\"\"\"\nlexer = Lexer(code)\nparser = Parser(lexer.tokens)\nast = parser.parse()\n\ncodegen = MetalCodeGen()\nMetal_code = codegen.generate(ast)\nprint(Metal_code)\n</code></pre>"},{"location":"pages/graphica/api_reference/#opengl-codegen","title":"OpenGL Codegen","text":"<p>The [OpenGLCodeGen]{.title-ref} class in the CrossGL framework is essential for translating the abstract syntax tree (AST) of CrossGL shaders into OpenGL Shading Language (GLSL) code. This class is responsible for converting CrossGL shaders into GLSL, ensuring compatibility with OpenGL implementations across various platforms. By generating optimized GLSL code, the [OpenGLCodeGen]{.title-ref} class enables the efficient execution of shaders on systems that support OpenGL, including Windows, macOS, and Linux environments.</p> <ul> <li> <p>Attributes</p> <p>:   -   current_shader (ShaderNode) : The current shader node being         processed.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#methods_2","title":"Methods","text":"<p>__init__(self)</p> <p>:   Initializes the code generator.</p> <p>---</p> <p>generate(self, ast)</p> <p>:   Generates the shader code from the given abstract syntax tree (AST).</p> <pre><code>-   **Parameters:**\n    -   [ast (ASTNode)]{.title-ref} -- The abstract syntax tree node\n        representing the shader.\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated shader code.\n</code></pre> <p>---</p> <p>generate_shader(self, node)</p> <p>:   Generates the shader code from its abstract syntax tree (AST).</p> <pre><code>-   **Parameters:**\n    -   [node (ShaderNode)]{.title-ref} -- The shader node\n        containing global inputs, outputs, and shader sections.\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated shader code.\n</code></pre> <p>---</p> <p>generate_function(self, node, shader_type)</p> <p>:   Generates function code for the given function node and shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (FunctionNode)]{.title-ref} -- The function node\n            containing return type, name, parameters, and body.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\", \\\"fragment\\\", or \\\"global\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated function code.\n</code></pre> <p>---</p> <p>generate_main(self, node, shader_type)</p> <p>:   Generates the main function code for the given function node and     shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (FunctionNode)]{.title-ref} -- The function node\n            containing return type, name, parameters, and body.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated main function code.\n</code></pre> <p>---</p> <p>generate_statement(self, stmt, indent=0, shader_type=None)</p> <p>:   Generates code for a given statement, handling different types of     statements based on their node type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [stmt (ASTNode)]{.title-ref} -- The statement node to\n            generate code for.\n        -   [indent (int)]{.title-ref} -- The level of indentation\n            for the statement.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated code for the statement.\n</code></pre> <p>---</p> <p>generate_intermediate(self, node, shader_type)</p> <p>:   Generates intermediate code from a list of statements.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (list of ASTNode)]{.title-ref} -- The list of\n            intermediate statements to generate code for.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated intermediate code.\n</code></pre> <p>---</p> <p>generate_assignment(self, node, shader_type=None)</p> <p>:   Generates the code for an assignment statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (AssignmentNode)]{.title-ref} -- The assignment\n            node containing the variable and the value to assign.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated assignment code.\n</code></pre> <p>---</p> <p>generate_if(self, node, indent, shader_type=None)</p> <p>:   Generates the code for an [if]{.title-ref} statement.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (IfNode)]{.title-ref} -- The node representing the\n            [if]{.title-ref} statement with its condition and\n            bodies.\n        -   [indent (int)]{.title-ref} -- The level of indentation\n            for the generated code.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated [if]{.title-ref}\n        statement code.\n</code></pre> <p>---</p> <p>generate_for(self, node, indent, shader_type=None)</p> <p>:   Generates the code for a [for]{.title-ref} loop.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [node (ForNode)]{.title-ref} -- The node representing\n            the [for]{.title-ref} loop with initialization,\n            condition, update, and body.\n        -   [indent (int)]{.title-ref} -- The level of indentation\n            for the generated code.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated [for]{.title-ref} loop\n        code.\n</code></pre> <p>---</p> <p>generate_expression(self, expr, shader_type=None)</p> <p>:   Generates the code for an expression based on its type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (ASTNode)]{.title-ref} -- The expression node,\n            which could be a string, [VariableNode]{.title-ref},\n            [BinaryOpNode]{.title-ref},\n            [FunctionCallNode]{.title-ref},\n            [UnaryOpNode]{.title-ref}, [TernaryOpNode]{.title-ref},\n            or [MemberAccessNode]{.title-ref}.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The generated code for the expression.\n</code></pre> <p>---</p> <p>translate_expression(self, expr, shader_type)</p> <p>:   Translates the expression based on its type and shader type.</p> <pre><code>-\n\n    **Parameters:**\n\n    :   -   [expr (str)]{.title-ref} -- The expression to translate.\n        -   [shader_type (str)]{.title-ref} -- The type of shader\n            (\\\"vertex\\\" or \\\"fragment\\\").\n\n-   **Returns:**\n    -   [str]{.title-ref} -- The translated expression, or the\n        original expression if no translation is found.\n</code></pre> <p>---</p> <p>map_type(self, vtype)</p> <p>:   Maps the given type to its corresponding shader type.</p> <pre><code>-   **Parameters:**\n    -   [vtype (str)]{.title-ref} -- The type to be mapped.\n-   **Returns:**\n    -   [str]{.title-ref} -- The mapped shader type.\n</code></pre> <p>---</p> <p>map_operator(self, op)</p> <p>:   Maps the given operator to its corresponding shader operator.</p> <pre><code>-   **Parameters:**\n    -   [op (str)]{.title-ref} -- The operator to be mapped.\n-   **Returns:**\n    -   [str]{.title-ref} -- The mapped shader operator.\n</code></pre> <p>---</p> <p>Example</p> <p>Here's an example usage of the OpenGLCodeGen class to generate OpenGL code from a CrossGL shader:</p> <pre><code>from compiler.lexer import Lexer\nfrom compiler.parser import Parser\n\ncode = \"\"\"\nshader main {\n    input vec3 position;\n    input vec2 texCoord;\n    input mat2 depth;\n    output vec4 fragColor;\n    output float depth;\n    vec3 customFunction(vec3 random, float factor) {\n        return random * factor;\n    }\n\n    void main() {\n        vec3 color = vec3(position.x,position.y, 0.0);\n        float factor = 1.0;\n\n        if (texCoord.x &gt; 0.5) {\n            color = vec3(1.0, 0.0, 0.0);\n        } else {\n            color = vec3(0.0, 1.0, 0.0);\n        }\n\n        for (int i = 0; i &lt; 3; i = i + 1) {\n            factor = factor * 0.5;\n            color = customFunction(color, factor);\n        }\n\n        if (length(color) &gt; 1.0) {\n            color = normalize(color);\n        }\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n\"\"\"\nlexer = Lexer(code)\nparser = Parser(lexer.tokens)\nast = parser.parse()\n\ncodegen = OpenGLCodeGen()\nopengl_code = codegen.generate(ast)\nprint(opengl_code)\n</code></pre>"},{"location":"pages/graphica/api_reference/#vulkan-codegen","title":"Vulkan Codegen","text":"<p>The [VulkanCodeGen]{.title-ref} class in the CrossGL framework is pivotal for translating the abstract syntax tree (AST) of CrossGL shaders into SPIR-V compatible code, used by the Vulkan API. This class ensures that CrossGL shaders are converted into Vulkan Shading Language (GLSL for Vulkan) or directly into SPIR-V, providing compatibility with Vulkan-based applications across various platforms. By generating optimized SPIR-V code, the [VulkanCodeGen]{.title-ref} class enables efficient execution of shaders on systems that support Vulkan, including Windows, macOS, Linux, and Android environments, ensuring high performance and flexibility in rendering tasks.</p> <ul> <li> <p>Attributes</p> <p>:   -   current_shader (ShaderNode) : The current shader node being         processed.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#methods_3","title":"Methods","text":"<p>__init__(self)</p> <p>:   Initializes the code generator.</p> <p>---</p> <p>generate(self, ast)</p> <p>Generates shader code from the given abstract syntax tree (AST).</p> <ul> <li>Parameters:<ul> <li>[ast (ShaderNode)]{.title-ref} -- The abstract syntax tree node     representing the shader.</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The generated shader code, or an empty     string if the AST is not a [ShaderNode]{.title-ref}.</li> </ul> </li> </ul> <p>---</p> <p>generate_shader(self, node)</p> <p>Generates the SPIR-V code for a Vulkan shader based on the provided shader node.</p> <ul> <li>Parameters:<ul> <li>[node (ShaderNode)]{.title-ref} -- The node representing the     shader, containing inputs, outputs, functions, and other shader     components.</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The generated SPIR-V code, including SPIR-V     header information, entry points, decorations, type     declarations, global variables, constants, function     declarations, and function definitions.</li> </ul> </li> </ul> <p>---</p> <p>declare_types(self)</p> <p>Declares the necessary data types for the Vulkan SPIR-V shader.</p> <ul> <li>Parameters:<ul> <li>None</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The SPIR-V code string that includes type     declarations for [void]{.title-ref}, [boolean]{.title-ref},     [float]{.title-ref}, [integer]{.title-ref}, and [unsigned     integer]{.title-ref} types. It also dynamically generates vector     types based on the shader's input and output variables,     assigning them unique IDs.</li> </ul> </li> </ul> <p>---</p> <p>declare_global_variables(self)</p> <p>Declares global variables for shader inputs and outputs in the SPIR-V code.</p> <ul> <li>Parameters:<ul> <li>None</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The SPIR-V code string that declares     pointers to the input and output variables. It assigns unique     IDs to these variables and stores them in     [self.variable_ids]{.title-ref}. The function handles both input     and output variables, generating the appropriate     [OpTypePointer]{.title-ref} and [OpVariable]{.title-ref}     instructions for each.</li> </ul> </li> </ul> <p>---</p> <p>declare_constants(self)</p> <p>Declares constants used in the shader within the SPIR-V code.</p> <ul> <li>Parameters:<ul> <li>None</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The SPIR-V code string that defines     commonly used constants such as [0]{.title-ref} and     [1]{.title-ref} for both [float]{.title-ref} and     [int]{.title-ref} types, as well as [3]{.title-ref} for the     [int]{.title-ref} type. Each constant is represented with an     [OpConstant]{.title-ref} instruction, associating the value with     a type ([float]{.title-ref} or [int]{.title-ref}). These     constants can then be referenced within the shader code.</li> </ul> </li> </ul> <p>---</p> <p>declare_function(self, node)</p> <p>Declares a function type in SPIR-V code based on the given function node.</p> <ul> <li>Parameters:<ul> <li>[node (FunctionNode)]{.title-ref} -- The function node     representing the function declaration in the shader.</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The SPIR-V code string that defines the     function type. It includes the function's return type and     parameter types, and assigns a unique ID to this function type.     The function type is represented with an     [OpTypeFunction]{.title-ref} instruction, specifying the return     type and the types of parameters the function accepts.</li> </ul> </li> </ul> <p>---</p> <p>generate_function(self, node)</p> <p>Generates the SPIR-V code for a function based on the given function node.</p> <ul> <li>Parameters:<ul> <li>[node (FunctionNode)]{.title-ref} -- The function node     representing the function definition in the shader.</li> </ul> </li> <li>Returns:<ul> <li>[str]{.title-ref} -- The SPIR-V code string for the function.     This includes the function declaration with its type, parameter     declarations, function body, and function end. The function code     is defined using [OpFunction]{.title-ref},     [OpFunctionParameter]{.title-ref}, [OpLabel]{.title-ref},     [OpReturn]{.title-ref}, [OpUnreachable]{.title-ref}, and     [OpFunctionEnd]{.title-ref} instructions. The function is     assigned a unique ID and the function parameters are mapped to     SPIR-V function parameters. The body of the function is     generated by translating each statement into SPIR-V code.</li> </ul> </li> </ul> <p>---</p> <p>generate_statement(self, stmt)</p> <p>Generates the SPIR-V code for a given statement node.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[stmt (ASTNode)]{.title-ref} -- The statement node representing     a specific type of statement in the shader code.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the statement. The function translates different types of statements into corresponding SPIR-V instructions:\n\n    :   -   For [AssignmentNode]{.title-ref}, it generates code\n            using [OpStore]{.title-ref}.\n        -   For [IfNode]{.title-ref}, it generates conditional\n            branches using [OpBranchConditional]{.title-ref}.\n        -   For [ForNode]{.title-ref}, it generates code for the\n            initialization, condition, and update steps, and\n            loops through the body.\n        -   For [ReturnNode]{.title-ref}, it generates a return\n            statement with [OpReturnValue]{.title-ref} or\n            [OpReturn]{.title-ref} if there is no return value.\n        -   For other statements, it generates SPIR-V code for\n            expressions.\n</code></pre> </li> </ul> <p>---</p> <p>generate_assignment(self, node)</p> <p>Generates the SPIR-V code for an assignment statement.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[node (AssignmentNode)]{.title-ref} -- The assignment node     containing the variable being assigned to and the value being     assigned.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the assignment operation. The function handles assignments in two cases:\n\n    :   -   If the variable being assigned to is a shader\n            output, it uses the [OpStore]{.title-ref}\n            instruction to store the value directly to the\n            output variable.\n        -   For other variables, it generates a temporary\n            variable of the function type, assigns the value to\n            it, and then stores the value to the temporary\n            variable. This is useful for intermediate variables\n            within functions.\n</code></pre> </li> </ul> <p>---</p> <p>generate_if(self, node)</p> <p>Generates SPIR-V code for an [if]{.title-ref} statement.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[node (IfNode)]{.title-ref} -- The if-node containing the     condition, the body of statements to execute if the condition is     true, and optionally the body of statements to execute if the     condition is false.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the [if]{.title-ref} statement. The function handles the following :\n\n    :   -   **Condition Evaluation:** Evaluates the condition\n            expression and generates the necessary label IDs for\n            the [then]{.title-ref}, [else]{.title-ref}, and\n            [merge]{.title-ref} blocks.\n        -   **Branching:** Uses the\n            [OpSelectionMerge]{.title-ref} and\n            [OpBranchConditional]{.title-ref} instructions to\n            branch to the appropriate labels based on the\n            condition.\n        -   **Then Block:** Executes the statements within the\n            [if]{.title-ref} body, then branches to the merge\n            block.\n        -   **Else Block:** If there is an [else]{.title-ref}\n            body, it executes those statements and then branches\n            to the merge block.\n        -   **Merge Block:** The merge block that consolidates\n            the control flow from both the [then]{.title-ref}\n            and [else]{.title-ref} blocks.\n</code></pre> </li> </ul> <p>---</p> <p>generate_for(self, node)</p> <p>Generates SPIR-V code for a [for]{.title-ref} loop.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[node (ForNode)]{.title-ref} -- The for-node containing     initialization, condition, update, and body of the loop.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the [for]{.title-ref} loop. The function handles the following :\n\n    :   -   **Initialization:** Executes the initialization\n            statement.\n        -   **Loop Header:** Creates labels for the loop header,\n            body, continue, and merge blocks.\n        -   **Loop Merge:** Uses [OpLoopMerge]{.title-ref} to\n            define the loop structure, specifying the merge and\n            continue labels.\n        -   **Condition Check:** Uses\n            [OpBranchConditional]{.title-ref} to branch to the\n            loop body if the condition is true or to the merge\n            label if false.\n        -   **Body Execution:** Executes the statements in the\n            loop body and then branches to the continue label.\n        -   **Update and Repeat:** Executes the update\n            statement, then branches back to the loop header for\n            the next iteration.\n        -   **Merge Block:** The merge block that follows the\n            end of the loop, consolidating the control flow.\n</code></pre> </li> </ul> <p>---</p> <p>generate_expression(self, expr)</p> <p>Generates SPIR-V code for the given expression.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[expr (ExpressionNode)]{.title-ref} -- The expression node to be     converted into SPIR-V code. This can be a string,     [VariableNode]{.title-ref}, [BinaryOpNode]{.title-ref},     [FunctionCallNode]{.title-ref}, [MemberAccessNode]{.title-ref},     or other types of expression nodes.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the expression. The function handles the following cases :\n\n    :   -   **String:** Translates a simple string expression\n            directly.\n        -   **VariableNode:** Translates the variable name to\n            its corresponding SPIR-V identifier.\n        -   **BinaryOpNode:** Generates code for binary\n            operations. This involves:\n        -   Generating SPIR-V IDs for the left and right\n            operands.\n        -   Mapping the operator to its SPIR-V representation.\n        -   Constructing the appropriate SPIR-V instruction\n            using [OpBinaryOp]{.title-ref}.\n        -   **FunctionCallNode:** Handles function calls,\n            including:\n        -   **Vector Constructors:** For built-in functions like\n            [vec2]{.title-ref}, [vec3]{.title-ref}, and\n            [vec4]{.title-ref}, constructs the vector using\n            [OpCompositeConstruct]{.title-ref}.\n        -   **Regular Function Calls:** Calls functions with\n            [OpFunctionCall]{.title-ref}, handling both void and\n            non-void return types.\n        -   **MemberAccessNode:** Generates code to access a\n            member of a composite type using\n            [OpCompositeExtract]{.title-ref}.\n        -   **Default Case:** Returns the string representation\n            of the expression for any other cases.\n</code></pre> </li> </ul> <p>---</p> <p>translate_expression(self, expr)</p> <p>Translates an expression into SPIR-V code.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[expr (str)]{.title-ref} -- The expression to be translated.     This can be a variable name, a vector constructor, or a constant     value.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V code string for the given expression. The function handles the following cases :\n\n    :   -   **Variable Names:** If the expression is a variable\n            name that exists in [self.variable_ids]{.title-ref},\n            it returns the corresponding SPIR-V identifier.\n        -   **Vector Constructors:** If the expression is a\n            vector constructor (e.g., [vec3(1.0, 2.0,\n            3.0)]{.title-ref}), it translates the components\n            into SPIR-V code using\n            [OpCompositeConstruct]{.title-ref}. It splits the\n            vector components, translates each component, and\n            constructs the vector.\n        -   **Constant Values:** If the expression is a numeric\n            value, it attempts to convert it to a float and\n            generates a constant using [OpConstant]{.title-ref}\n            with type [%float]{.title-ref}.\n        -   **Unhandled Expressions:** For any other\n            expressions, it returns a comment indicating that\n            the expression is unhandled.\n</code></pre> </li> </ul> <p>---</p> <p>map_type(self, vtype)</p> <p>Maps a given type to its corresponding SPIR-V type.</p> <ul> <li> <p>Parameters:</p> <ul> <li>[vtype (str)]{.title-ref} -- The type to be mapped, which may     include types like [\\\"void\\\"]{.title-ref},     [\\\"bool\\\"]{.title-ref}, [\\\"int\\\"]{.title-ref},     [\\\"float\\\"]{.title-ref}, and various vector and matrix types.</li> </ul> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V type corresponding to the input type. The function uses a mapping dictionary to translate common GLSL types to SPIR-V types :\n\n    :   -   [\\\"void\\\"]{.title-ref} -\\&gt; [\\\"void\\\"]{.title-ref}\n        -   [\\\"bool\\\"]{.title-ref} -\\&gt; [\\\"bool\\\"]{.title-ref}\n        -   [\\\"int\\\"]{.title-ref} -\\&gt; [\\\"int\\\"]{.title-ref}\n        -   [\\\"float\\\"]{.title-ref} -\\&gt; [\\\"float\\\"]{.title-ref}\n        -   [\\\"vec2\\\"]{.title-ref} -\\&gt; [\\\"v2float\\\"]{.title-ref}\n        -   [\\\"vec3\\\"]{.title-ref} -\\&gt; [\\\"v3float\\\"]{.title-ref}\n        -   [\\\"vec4\\\"]{.title-ref} -\\&gt; [\\\"v4float\\\"]{.title-ref}\n        -   [\\\"mat2\\\"]{.title-ref} -\\&gt;\n            [\\\"mat2v2float\\\"]{.title-ref}\n        -   [\\\"mat3\\\"]{.title-ref} -\\&gt;\n            [\\\"mat3v3float\\\"]{.title-ref}\n        -   [\\\"mat4\\\"]{.title-ref} -\\&gt;\n            [\\\"mat4v4float\\\"]{.title-ref}\n</code></pre> <ul> <li>If [vtype]{.title-ref} is not in the dictionary, it returns     [vtype]{.title-ref} unchanged. This allows for custom or     unsupported types to pass through without modification.</li> </ul> </li> </ul> <p>---</p> <p>map_operator(self, op)</p> <p>Maps a given operator to its corresponding SPIR-V opcode.</p> <ul> <li> <p>Parameters:</p> <p>:   -   [op (str)]{.title-ref} -- The operator to be mapped. This         might include operators such as [\\\"PLUS\\\"]{.title-ref},         [\\\"MINUS\\\"]{.title-ref}, [\\\"MULTIPLY\\\"]{.title-ref},         [\\\"DIVIDE\\\"]{.title-ref}, [\\\"LESS_THAN\\\"]{.title-ref}, and         so on.</p> </li> <li> <p>Returns:</p> <p>:   -   </p> <pre><code>    [str]{.title-ref} -- The SPIR-V opcode corresponding to the input operator. The function uses a dictionary to translate common operators to their SPIR-V opcodes:\n\n    :   -   [\\\"PLUS\\\"]{.title-ref} -\\&gt; [\\\"OpFAdd\\\"]{.title-ref}\n        -   [\\\"MINUS\\\"]{.title-ref} -\\&gt; [\\\"OpFSub\\\"]{.title-ref}\n        -   [\\\"MULTIPLY\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFMul\\\"]{.title-ref}\n        -   [\\\"DIVIDE\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFDiv\\\"]{.title-ref}\n        -   [\\\"LESS_THAN\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdLessThan\\\"]{.title-ref}\n        -   [\\\"GREATER_THAN\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdGreaterThan\\\"]{.title-ref}\n        -   [\\\"LESS_EQUAL\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdLessThanEqual\\\"]{.title-ref}\n        -   [\\\"GREATER_EQUAL\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdGreaterThanEqual\\\"]{.title-ref}\n        -   [\\\"EQUAL\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdEqual\\\"]{.title-ref}\n        -   [\\\"NOT_EQUAL\\\"]{.title-ref} -\\&gt;\n            [\\\"OpFOrdNotEqual\\\"]{.title-ref}\n        -   [\\\"AND\\\"]{.title-ref} -\\&gt;\n            [\\\"OpLogicalAnd\\\"]{.title-ref}\n        -   [\\\"OR\\\"]{.title-ref} -\\&gt;\n            [\\\"OpLogicalOr\\\"]{.title-ref}\n</code></pre> <ul> <li>If [op]{.title-ref} is not found in the dictionary, it returns     [op]{.title-ref} unchanged, allowing for unhandled or custom     operators to pass through without modification.</li> </ul> </li> </ul> <p>---</p> <p>get_id(self)</p> <p>Generates a unique identifier for use in the SPIR-V code.</p> <ul> <li>Returns:<ul> <li>[int]{.title-ref} -- The current value of     [self.id_counter]{.title-ref}, which serves as a unique     identifier in the generated SPIR-V code. After returning the     current value, the method increments     [self.id_counter]{.title-ref} by 1 to ensure that the next call     to [get_id]{.title-ref} produces a new unique identifier.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#ast-abstract-syntax-tree","title":"AST (Abstract Syntax Tree)","text":"<p>UniformNode(ASTNode) Class</p> <p>Represents a uniform variable in the abstract syntax tree (AST) of shader code. This node is used to define uniform variables, which are global variables passed to the shader from the application.</p> <ul> <li> <p>Attributes:</p> <ul> <li>vtype (str): The type of the uniform variable (e.g.,     [int]{.title-ref}, [float]{.title-ref}, [vec3]{.title-ref}).</li> <li>name (str): The name of the uniform variable.</li> </ul> </li> <li> <p>Methods:</p> <ul> <li> <p>__repr():</p> <ul> <li>Purpose: Provides a detailed string representation of     the [UniformNode]{.title-ref} instance for debugging     purposes.</li> <li>Returns: A string in the format     [\\\"UniformNode(vtype=\\&lt;vtype&gt;,     name=\\&lt;name&gt;)\\\"]{.title-ref}.</li> </ul> </li> <li> <p>__str():</p> <ul> <li>Purpose: Provides a string representation of the uniform     declaration as it would appear in shader code.</li> <li>Returns: A string in the format :</li> </ul> <p><code>python \"uniform &lt;vtype&gt; &lt;name&gt;;\"</code></p> </li> </ul> </li> <li> <p>Example:</p> <p><code>python uniform_node = UniformNode(\"vec3\", \"lightDirection\") print(uniform_node)  # Output: uniform vec3 lightDirection; print(repr(uniform_node))  # Output: UniformNode(vtype=vec3, name=lightDirection)</code></p> </li> </ul> <p>---</p> <p>TernaryOpNode Class</p> <p>Represents a ternary operation in the abstract syntax tree (AST) of a programming language or shader code. A ternary operation is a conditional expression that evaluates to one of two values depending on the result of a condition.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `condition`: The condition expression to be evaluated.         This is typically a boolean expression.     -   `true_expr`: The expression that is evaluated and returned         if the condition is [True]{.title-ref}.     -   `false_expr`: The expression that is evaluated and         returned if the condition is [False]{.title-ref}.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_[repr](init__(self))()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`TernaryOpNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format :\n\n        ``` python\n        \"TernaryOpNode(condition=&lt;condition&gt;, true_expr=&lt;true_expr&gt;, false_expr=&lt;false_expr&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>:   <code>python     ternary_node = TernaryOpNode(\"x &gt; 0\", \"x\", \"-x\")     print(repr(ternary_node))     # Output: TernaryOpNode(condition=x &gt; 0, true_expr=x, false_expr=-x)</code></p> </li> </ul> <p>ShaderNode Class</p> <p>Represents a complete shader program in the abstract syntax tree (AST). This node encapsulates all the components of a shader, including inputs, outputs, functions, and the vertex and fragment shader sections.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `name`: The name of the shader program.     -   `global_inputs`: A list of global input variables used in         the shader.     -   `global_outputs`: A list of global output variables         produced by the shader.     -   `global_functions`: A list of global functions defined in         the shader.     -   `vertex_section`: The vertex shader section, containing         operations related to vertex processing.     -   `fragment_section`: The fragment shader section,         containing operations related to fragment (pixel)         processing.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_[repr](init__(self))()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`ShaderNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"ShaderNode(&lt;name&gt;) &lt;global_inputs&gt; &lt;global_outputs&gt; &lt;global_functions&gt; &lt;vertex_section&gt; &lt;fragment_section&gt;\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python shader_node = ShaderNode(     name=\"BasicShader\",     global_inputs=[\"position\", \"normal\"],     global_outputs=[\"color\"],     global_functions=[\"transform\", \"lighting\"],     vertex_section=\"vertex operations here\",     fragment_section=\"fragment operations here\", ) print(repr(shader_node))</p> </li> </ul> <p>VERTEXShaderNode Class</p> <p>Represents the vertex shader section of a shader program in the abstract syntax tree (AST). This node encapsulates the inputs, outputs, functions, and intermediate operations specific to the vertex shader.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `inputs`: A list of input variables used by the vertex         shader, typically including attributes like position,         normal, etc.     -   `outputs`: A list of output variables produced by the         vertex shader, such as transformed positions or interpolated         data.     -   `functions`: A list of functions defined and used within         the vertex shader.     -   `intermidiate`: The intermediate operations or         calculations performed within the vertex shader before the         final output.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_[repr](init__(self))()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`VERTEXShaderNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"VERTEXShaderNode(&lt;inputs&gt;) &lt;outputs&gt; &lt;functions&gt; &lt;intermidiate&gt;\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python vertex_shader_node = VERTEXShaderNode(     inputs=[\"position\", \"normal\"],     outputs=[\"gl_Position\"],     functions=[\"transform\", \"calculateNormal\"],     intermidiate=\"intermediate calculations here\", ) print(repr(vertex_shader_node))</p> </li> </ul> <p>---</p> <p>FRAGMENTShaderNode Class</p> <p>Represents the fragment shader section of a shader program in the abstract syntax tree (AST). This node encapsulates the inputs, outputs, functions, and intermediate operations specific to the fragment shader.</p> <ul> <li> <p>Attributes:</p> <ul> <li>`inputs`: A list of input variables used by the fragment     shader, such as interpolated data from the vertex shader.</li> <li>`outputs`: A list of output variables produced by the fragment     shader, like the final color of the pixel.</li> <li>`functions`: A list of functions defined and used within the     fragment shader.</li> <li>`intermidiate`: The intermediate operations or calculations     performed within the fragment shader before producing the final     output.</li> </ul> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_[repr](init__(self))()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`FRAGMENTShaderNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format :\n\n        ``` python\n        \"FRAGMENTShaderNode(&lt;inputs&gt;) &lt;outputs&gt; &lt;functions&gt; &lt;intermidiate&gt;\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python fragment_shader_node = FRAGMENTShaderNode(     inputs=[\"fragCoord\", \"color\"],     outputs=[\"fragColor\"],     functions=[\"applyLighting\", \"computeColor\"],     intermidiate=\"intermediate calculations here\", ) print(repr(fragment_shader_node))</p> </li> </ul> <p>FunctionNode Class</p> <p>The [FunctionNode]{.title-ref} class represents a function within the abstract syntax tree (AST) for shader code. It contains details about the function's return type, name, parameters, and body. This class is used in shader code generation to define functions that can be called within shaders.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `return_type`: The data type that the function returns. It         is a string representing the type (e.g.,         [\\\"float\\\"]{.title-ref}, [\\\"vec4\\\"]{.title-ref}).     -   `name`: The name of the function as a string.     -   `params`: A list of tuples where each tuple represents a         parameter with its type and name (e.g.,`[(\\\"float\\\",         \\\"param1\\\"), (\\\"vec3\\\", \\\"param2\\\")]`).     -   `body`: A list of statements that constitute the         function's body. Each statement can be an instance of         various AST node classes, such as         [AssignmentNode]{.title-ref}, [ReturnNode]{.title-ref}, etc.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr()[: - **Purpose**: Provides a         detailed string representation of the         `FunctionNode]{.title-ref} instance. This is useful for         debugging and logging.         -   Returns: A string that includes the function's             return type, name, parameters, and body in a format             similar to:</p> <pre><code>    ``` python\n    \"FunctionNode(return_type=&lt;return_type&gt;, name=&lt;name&gt;, params=&lt;params&gt;, body=&lt;body&gt;)\"\n    ```\n</code></pre> </li> <li> <p>Example Usage:</p> <p>``` python</p> </li> </ul> <p>VariableNode Class</p> <p>The [VariableNode]{.title-ref} class represents a variable within the abstract syntax tree (AST) for shader code. It contains details about the variable's type and name. This class is used when defining variables in shader code and is a fundamental part of shader code generation.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `vtype`: The data type of the variable, represented as a         string (e.g., [\\\"float\\\"]{.title-ref},         [\\\"vec3\\\"]{.title-ref}).     -   `name`: The name of the variable as a string (e.g.,         [\\\"position\\\"]{.title-ref}, [\\\"color\\\"]{.title-ref}).</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr()[: - **Purpose**: Provides a         detailed string representation of the         `VariableNode]{.title-ref} instance. This is useful for         debugging and logging.</p> <pre><code>    -   **Returns**: A string that includes the variable's type\n        and name in a format similar to:\n\n    ``` python\n    \"VariableNode(vtype=&lt;vtype&gt;, name=&lt;name&gt;)\"\n    ```\n</code></pre> </li> <li> <p>Example Usage:</p> <p>``` python</p> </li> </ul> <p>AssignmentNode Class</p> <p>The [AssignmentNode]{.title-ref} class represents an assignment operation within the abstract syntax tree (AST) for shader code. It captures the assignment of a value to a variable, which is a fundamental operation in shaders and other programming languages.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `name`: The name of the variable being assigned a value.         This is typically a string representing the variable's         identifier (e.g., [\\\"color\\\"]{.title-ref},         [\\\"position\\\"]{.title-ref}).     -   `value`: The value being assigned to the variable. This         can be a more complex expression or value, represented as an         instance of another node class or a string.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr()[: - **Purpose**: Provides a detailed         string representation of the `AssignmentNode]{.title-ref}         instance. This method is useful for debugging and         visualizing the node's structure.</p> <pre><code>    -   **Returns**: A string that includes the variable name\n        and the assigned value, formatted like:\n\n    ``` python\n    \"AssignmentNode(name=&lt;name&gt;, value=&lt;value&gt;)\"\n    ```\n</code></pre> </li> <li> <p>Example Usage:</p> <p>``` python</p> </li> </ul> <p>IfNode Class</p> <p>The [IfNode]{.title-ref} class represents a conditional statement within the abstract syntax tree (AST) for shader code. It captures the structure of an [if]{.title-ref} statement, including the condition to be evaluated and the bodies of code to execute based on whether the condition is true or false.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `condition`: An expression or condition that determines         which body of code will be executed. This is often an         instance of an expression node, representing a boolean         condition.     -   `if_body`: A list of statements or nodes that are executed         if the condition evaluates to true.     -   `else_body`: An optional list of statements or nodes that         are executed if the condition evaluates to false. This can         be [None]{.title-ref} if there is no [else]{.title-ref}         part.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr()[: - **Purpose**: Provides a detailed         string representation of the `IfNode]{.title-ref} instance.         This method is useful for debugging and understanding the         structure of the node.</p> <pre><code>    -   **Returns**: A string that includes the condition,\n        [if_body]{.title-ref}, and optionally the\n        [else_body]{.title-ref}, formatted like:\n\n    ``` python\n    \"IfNode(condition=&lt;condition&gt;, if_body=&lt;if_body&gt;, else_body=&lt;else_body&gt;)\"\n    ```\n</code></pre> </li> <li> <p>Example Usage:</p> <p>``` python</p> </li> </ul> <p>ForNode Class</p> <p>Represents a [for]{.title-ref} loop within the abstract syntax tree (AST) for shader code. This node encapsulates the initialization, condition, update, and body of the [for]{.title-ref} loop.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `init`: The initialization statement or expression         executed before the loop starts.     -   `condition`: The expression evaluated before each         iteration to determine if the loop should continue.     -   `update`: The expression or statement executed at the end         of each loop iteration, typically used to update the loop         variable or state.     -   `body`: The list of statements or nodes that make up the         body of the loop, executed repeatedly as long as the         [condition]{.title-ref} is true.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_[repr](init__(self))()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`ForNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"ForNode(init=&lt;init&gt;, condition=&lt;condition&gt;, update=&lt;update&gt;, body=&lt;body&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python for_node = ForNode(     init=AssignmentNode(name=\"i\", value=\"0\"),     condition=\"i &lt; 10\",     update=AssignmentNode(name=\"i\", value=\"i + 1\"),     body=[         AssignmentNode(name=\"result\", value=\"result + i\")     ] ) print(repr(for_node))</p> </li> </ul> <p>ReturnNode Class</p> <p>Represents a return statement within the abstract syntax tree (AST) for shader code. This node encapsulates the value to be returned from a function.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `value`: The expression or value to be returned from the         function.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`ReturnNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"ReturnNode(value=&lt;value&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python return_node = ReturnNode(value=\"result\") print(repr(return_node))</p> </li> </ul> <p>FunctionCallNode Class</p> <p>Represents a function call within the abstract syntax tree (AST) for shader code. This node captures the function name and its arguments.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `name`: The name of the function being called.     -   `args`: A list of arguments passed to the function.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`FunctionCallNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"FunctionCallNode(name=&lt;name&gt;, args=&lt;args&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python func_call_node = FunctionCallNode(name=\"someFunction\", args=[\"arg1\", \"arg2\"]) print(repr(func_call_node))</p> </li> </ul> <p>BinaryOpNode Class</p> <p>Represents a binary operation within the abstract syntax tree (AST) for shader code. This node captures the left operand, operator, and right operand of the operation.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `left`: The left operand of the binary operation.     -   `op`: The operator used for the binary operation.     -   `right`: The right operand of the binary operation.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`BinaryOpNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"BinaryOpNode(left=&lt;left&gt;, op=&lt;op&gt;, right=&lt;right&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python binary_op_node = BinaryOpNode(left=\"a\", op=\"PLUS\", right=\"b\") print(repr(binary_op_node))</p> </li> </ul> <p>MemberAccessNode Class</p> <p>Represents an access operation for a member of an object within the abstract syntax tree (AST) for shader code. This node captures the object and the specific member being accessed.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `object`: The object whose member is being accessed.     -   `member`: The specific member of the object being         accessed.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`MemberAccessNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"MemberAccessNode(object=&lt;object&gt;, member=&lt;member&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python member_access_node = MemberAccessNode(object=\"myStruct\", member=\"x\") print(repr(member_access_node))</p> </li> </ul> <p>UnaryOpNode Class</p> <p>Represents a unary operation within the abstract syntax tree (AST) for shader code. This node captures the operator and the single operand of the operation.</p> <ul> <li> <p>Attributes:</p> <p>:   -   `op`: The operator for the unary operation.     -   `operand`: The single operand on which the unary operation         is applied.</p> </li> <li> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Purpose\\*\\*: Provides a detailed string representation of the \\`UnaryOpNode]{.title-ref} instance for debugging purposes.\n\n    :   -   **Returns**: A string in the format:\n\n        ``` python\n        \"UnaryOpNode(op=&lt;op&gt;, operand=&lt;operand&gt;)\"\n        ```\n</code></pre> </li> <li> <p>Example:</p> <p>``` python unary_op_node = UnaryOpNode(op=\"NEG\", operand=\"x\") print(repr(unary_op_node))</p> </li> </ul> <p>Explanation:</p> <ul> <li>`op`: Represents the unary operator. This could be an operation     such as negation (-), logical NOT (!), or any other unary operation.</li> <li>`operand`: Represents the operand on which the unary operation is     performed. This is typically a variable or an expression.</li> </ul> <p>The [UnaryOpNode]{.title-ref} class is essential for representing unary operations in shader code. It enables the AST to handle and process operations that involve a single operand, facilitating the interpretation and transformation of shader code that includes unary operations.</p>"},{"location":"pages/graphica/api_reference/#output-shadernodebasicshader-position-normal-color-transform-lighting-vertex-operations-here-fragment-operations-here","title":"Output: ShaderNode('BasicShader') ['position', 'normal'] ['color'] ['transform', 'lighting'] 'vertex operations here' 'fragment operations here'","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-vertexshadernodeposition-normal-gl_position-transform-calculatenormal-intermediate-calculations-here","title":"Output: VERTEXShaderNode(['position', 'normal']) ['gl_Position'] ['transform', 'calculateNormal'] 'intermediate calculations here'","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-fragmentshadernodefragcoord-color-fragcolor-applylighting-computecolor-intermediate-calculations-here","title":"Output: FRAGMENTShaderNode(['fragCoord', 'color']) ['fragColor'] ['applyLighting', 'computeColor'] 'intermediate calculations here'","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#define-a-function-node","title":"Define a function node","text":"<p>function_node = FunctionNode(     return_type=\"float\",     name=\"calculateLighting\",     params=[(\"vec3\", \"position\"), (\"vec3\", \"normal\")],     body=[         AssignmentNode(name=\"result\", value=BinaryOpNode(left=\"position\", op=\"MULTIPLY\", right=\"normal\")),         ReturnNode(value=\"result\")     ] )</p>"},{"location":"pages/graphica/api_reference/#print-the-representation","title":"Print the representation","text":"<p>print(repr(function_node))</p>"},{"location":"pages/graphica/api_reference/#output-functionnodereturn_typefloat-namecalculatelighting-paramsvec3-position-vec3-normal-bodyassignmentnodenameresult-valuebinaryopnodeleftposition-opmultiply-rightnormal-returnnodevalueresult","title":"Output: FunctionNode(return_type=float, name=calculateLighting, params=[('vec3', 'position'), ('vec3', 'normal')], body=[AssignmentNode(name=result, value=BinaryOpNode(left=position, op=MULTIPLY, right=normal)), ReturnNode(value=result)])","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#define-a-variable-node","title":"Define a variable node","text":"<p>variable_node = VariableNode(vtype=\"vec3\", name=\"position\")</p>"},{"location":"pages/graphica/api_reference/#print-the-representation_1","title":"Print the representation","text":"<p>print(repr(variable_node))</p>"},{"location":"pages/graphica/api_reference/#output-variablenodevtypevec3-nameposition","title":"Output: VariableNode(vtype=vec3, name=position)","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#define-an-assignment-node","title":"Define an assignment node","text":"<p>assignment_node = AssignmentNode(name=\"color\", value=\"vec4(1.0, 0.0, 0.0, 1.0)\")</p>"},{"location":"pages/graphica/api_reference/#print-the-representation_2","title":"Print the representation","text":"<p>print(repr(assignment_node))</p>"},{"location":"pages/graphica/api_reference/#output-assignmentnodenamecolor-valuevec410-00-00-10","title":"Output: AssignmentNode(name=color, value=vec4(1.0, 0.0, 0.0, 1.0))","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#define-an-if-node","title":"Define an if-node","text":"<p>if_node = IfNode(     condition=\"x &gt; 0\",     if_body=[         AssignmentNode(name=\"result\", value=\"1.0\")     ],     else_body=[         AssignmentNode(name=\"result\", value=\"0.0\")     ] )</p>"},{"location":"pages/graphica/api_reference/#print-the-representation_3","title":"Print the representation","text":"<p>print(repr(if_node))</p>"},{"location":"pages/graphica/api_reference/#output-ifnodeconditionx-0-if_bodyassignmentnodenameresult-value10-else_bodyassignmentnodenameresult-value00","title":"Output: IfNode(condition=x &gt; 0, if_body=[AssignmentNode(name=result, value=1.0)], else_body=[AssignmentNode(name=result, value=0.0)])","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-fornodeinitassignmentnodenamei-value0-conditioni-10-updateassignmentnodenamei-valuei-1-bodyassignmentnodenameresult-valueresult-i","title":"Output: ForNode(init=AssignmentNode(name=i, value=0), condition=i &lt; 10, update=AssignmentNode(name=i, value=i + 1), body=[AssignmentNode(name=result, value=result + i)])","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-returnnodevalueresult","title":"Output: ReturnNode(value=result)","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-functioncallnodenamesomefunction-argsarg1-arg2","title":"Output: FunctionCallNode(name=someFunction, args=['arg1', 'arg2'])","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-binaryopnodelefta-opplus-rightb","title":"Output: BinaryOpNode(left=a, op=PLUS, right=b)","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-memberaccessnodeobjectmystruct-memberx","title":"Output: MemberAccessNode(object=myStruct, member=x)","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#output-unaryopnodeopneg-operandx","title":"Output: UnaryOpNode(op=NEG, operand=x)","text":"<p>```</p>"},{"location":"pages/graphica/api_reference/#lexer","title":"Lexer","text":"<p>The [TOKENS]{.title-ref} list defines regular expressions for various tokens used in shader code. These tokens are used by a lexer to tokenize shader source code into meaningful components. The [KEYWORDS]{.title-ref} dictionary maps shader language keywords to their corresponding token types.</p> <p>Here's a breakdown of the token types and their corresponding regular expressions:</p>"},{"location":"pages/graphica/api_reference/#token-definitions","title":"Token Definitions","text":"<ul> <li>Comments<ul> <li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with     [//]{.title-ref}.</li> <li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed between     [/*]{.title-ref} and [*/]{.title-ref}.</li> </ul> </li> <li>Shader Language Keywords<ul> <li><code>SHADER</code>: Matches the [shader]{.title-ref} keyword.</li> <li><code>INPUT</code>: Matches the [input]{.title-ref} keyword.</li> <li><code>OUTPUT</code>: Matches the [output]{.title-ref} keyword.</li> <li><code>VOID</code>: Matches the [void]{.title-ref} keyword.</li> <li><code>MAIN</code>: Matches the [main]{.title-ref} keyword.</li> <li><code>UNIFORM</code>: Matches the [uniform]{.title-ref} keyword.</li> <li><code>VECTOR</code>: Matches [vec2]{.title-ref}, [vec3]{.title-ref}, or     [vec4]{.title-ref}.</li> <li><code>MATRIX</code>: Matches [mat2]{.title-ref}, [mat3]{.title-ref}, or     [mat4]{.title-ref}.</li> <li><code>BOOL</code>: Matches the [bool]{.title-ref} keyword.</li> <li><code>VERTEX</code>: Matches the [vertex]{.title-ref} keyword.</li> <li><code>FRAGMENT</code>: Matches the [fragment]{.title-ref} keyword.</li> </ul> </li> <li>Data Types<ul> <li><code>FLOAT_NUMBER</code>: Matches floating-point numbers (e.g.,     [1.0]{.title-ref}, [0.5]{.title-ref}, [3.]{.title-ref}).</li> <li><code>FLOAT</code>: Matches the [float]{.title-ref} keyword.</li> <li><code>INT</code>: Matches the [int]{.title-ref} keyword.</li> <li><code>UINT</code>: Matches the [uint]{.title-ref} keyword.</li> <li><code>DOUBLE</code>: Matches the [double]{.title-ref} keyword.</li> <li><code>SAMPLER2D</code>: Matches the [sampler2D]{.title-ref} keyword.</li> </ul> </li> <li>Identifiers and Constants<ul> <li><code>IDENTIFIER</code>: Matches variable and function names.</li> <li><code>NUMBER</code>: Matches integer numbers (e.g., [1]{.title-ref},     [42]{.title-ref}).</li> </ul> </li> <li>Operators and Punctuation<ul> <li><code>ASSIGN_SHIFT_RIGHT</code>: Matches [&gt;&gt;=]{.title-ref}.</li> <li><code>ASSIGN_SHIFT_LEFT</code>: Matches [\\&lt;\\&lt;=]{.title-ref}.</li> <li><code>ASSIGN_ADD</code>: Matches [+=]{.title-ref}.</li> <li><code>ASSIGN_SUB</code>: Matches [-=]{.title-ref}.</li> <li><code>ASSIGN_MUL</code>: Matches [*=]{.title-ref}.</li> <li><code>ASSIGN_DIV</code>: Matches [/=]{.title-ref}.</li> <li><code>ASSIGN_AND</code>: Matches [&amp;=]{.title-ref}.</li> <li><code>ASSIGN_OR</code>: Matches [|=]{.title-ref}.</li> <li><code>ASSIGN_XOR</code>: Matches [\\^=]{.title-ref}.</li> <li><code>ASSIGN_MOD</code>: Matches [%=]{.title-ref}.</li> <li><code>BITWISE_SHIFT_LEFT</code>: Matches [\\&lt;\\&lt;]{.title-ref}.</li> <li><code>BITWISE_SHIFT_RIGHT</code>: Matches [&gt;&gt;]{.title-ref}.</li> <li><code>LESS_EQUAL</code>: Matches [\\&lt;=]{.title-ref}.</li> <li><code>GREATER_EQUAL</code>: Matches [&gt;=]{.title-ref}.</li> <li><code>GREATER_THAN</code>: Matches [&gt;]{.title-ref}.</li> <li><code>LESS_THAN</code>: Matches [\\&lt;]{.title-ref}.</li> <li><code>INCREMENT</code>: Matches [++]{.title-ref}.</li> <li><code>DECREMENT</code>: Matches [--]{.title-ref}.</li> <li><code>EQUAL</code>: Matches [==]{.title-ref}.</li> <li><code>NOT_EQUAL</code>[: Matches ]{.title-ref}!=`.</li> <li><code>LOGICAL_AND</code>: Matches [&amp;&amp;]{.title-ref}.</li> <li><code>LOGICAL_OR</code>: Matches [||]{.title-ref}.</li> <li><code>XOR</code>: Matches [\\^]{.title-ref}.</li> <li><code>NOT</code>: Matches [!]{.title-ref}.</li> <li><code>PLUS</code>: Matches [+]{.title-ref}.</li> <li><code>MINUS</code>: Matches [-]{.title-ref}.</li> <li><code>MULTIPLY</code>: Matches [*]{.title-ref}.</li> <li><code>DIVIDE</code>: Matches [/]{.title-ref}.</li> <li><code>MOD</code>: Matches [%]{.title-ref}.</li> <li><code>DOT</code>: Matches [.]{.title-ref}.</li> <li><code>EQUALS</code>: Matches [=]{.title-ref}.</li> <li><code>QUESTION</code>: Matches [?]{.title-ref}.</li> <li><code>COLON</code>: Matches [:]{.title-ref}.</li> </ul> </li> <li>Brackets and Delimiters<ul> <li><code>LBRACE</code>: Matches [{]{.title-ref}.</li> <li><code>RBRACE</code>: Matches [}]{.title-ref}.</li> <li><code>LPAREN</code>: Matches [(]{.title-ref}.</li> <li><code>RPAREN</code>: Matches [)]{.title-ref}.</li> <li><code>SEMICOLON</code>: Matches [;]{.title-ref}.</li> <li><code>COMMA</code>: Matches [,]{.title-ref}.</li> </ul> </li> <li>Whitespace and Miscellaneous<ul> <li><code>WHITESPACE</code>: Matches any whitespace characters.</li> <li><code>CONST</code>: Matches the [const]{.title-ref} keyword.</li> <li><code>BITWISE_AND</code>: Matches [&amp;]{.title-ref}.</li> <li><code>BITWISE_OR</code>: Matches [|]{.title-ref}.</li> <li><code>BITWISE_XOR</code>: Matches [\\^]{.title-ref}.</li> <li><code>BITWISE_NOT</code>: Matches [\\~]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#keywords-dictionary","title":"Keywords Dictionary","text":"<p>The [KEYWORDS]{.title-ref} dictionary maps shader language keywords to their corresponding token types. This helps in identifying and categorizing keywords during tokenization.</p> <p>This setup allows a lexer to parse shader code and generate tokens that can be used for further processing, such as syntax checking, code generation, or transformation.</p> <p>Attributes: - code (str): The input code to tokenize - tokens (list): A list of tokens generated from the input code</p>"},{"location":"pages/graphica/api_reference/#methods_4","title":"Methods","text":"<p>__init__(self):</p> <p>Initializes the code generator.</p> <p>---</p> <p>Tokenize :</p> <p>This method is designed to process a string of shader code and convert it into a list of tokens based on predefined regular expressions. Here's a detailed explanation of what each part of the method does:</p> <ol> <li>Initialization:<ul> <li>`pos = 0`: Initializes the position counter to start from the     beginning of the code.</li> </ul> </li> <li>Token Matching Loop:<ul> <li>The [while]{.title-ref} loop continues as long as     [pos]{.title-ref} is less than the length of     [self.code]{.title-ref}.</li> <li>`match = None`: Initializes the [match]{.title-ref} variable     to store the result of regex matching.</li> </ul> </li> <li>Regex Matching:<ul> <li>The [for]{.title-ref} loop iterates over each token type and its     corresponding pattern in the [TOKENS]{.title-ref} list.</li> <li>`regex = re.compile(pattern)`: Compiles the regex pattern for     the current token type.</li> <li>`match = regex.match(self.code, pos)`: Attempts to match the     regex pattern against the code starting at the current position.</li> </ul> </li> <li>Handling Matches:<ul> <li> <p>If a match is found:</p> <p>:   -   `text = match.group(0)`: Extracts the matched text.     -   `if token_type == \\\"IDENTIFIER\\\" and text in         KEYWORDS`: Checks if the identifier is a keyword and         updates the token type accordingly.     -   `if token_type != \\\"WHITESPACE\\\"`: Skips whitespace         tokens and does not append them to the list of tokens.     -   `self.tokens.append(token)[: Appends the token (type         and text) to the `self.tokens]{.title-ref} list.     -   `pos = match.end(0)`: Updates the position counter to         the end of the matched text.     -   `break`: Exits the [for]{.title-ref} loop to continue         with the next position. 5.  Handling Unmatched Characters:     -   </p> <p>If no match is found ([if not match]{.title-ref}):</p> <p>:   -   `unmatched_char = self.code[pos]`: Captures the         character at the current position.     -   `highlighted_code`: Highlights the illegal character         in the code for easier debugging.     -   Raises a [SyntaxError]{.title-ref} with a message         indicating the illegal character and its position. 6.  End of File Token:     -   `self.tokens.append((\\\"EOF\\\", None))`: Appends an \"EOF\" (end of file) token to indicate the end of the token stream.</p> </li> </ul> </li> </ol> <p>---</p> <p>Key Points:</p> <ul> <li>Efficient Matching: By using regex patterns and the     [re.match]{.title-ref} method, the tokenizer efficiently matches     different types of tokens.</li> <li>Error Handling: Properly raises a [SyntaxError]{.title-ref} when     encountering illegal characters.</li> <li>Token Management: Handles and stores tokens while skipping     unnecessary whitespace and maintaining the position in the code.</li> </ul> <p>This method ensures that the input shader code is tokenized correctly, allowing further processing like parsing or code generation to be performed.</p>"},{"location":"pages/graphica/api_reference/#parser","title":"Parser","text":"<p>This parser generates an abstract syntax tree (AST) from a list of tokens.</p> <p>Attributes:</p> <p>:   -   tokens (list): A list of tokens generated from the input code</p>"},{"location":"pages/graphica/api_reference/#methods_5","title":"Methods","text":"<ul> <li> <p>__init__(self) :</p> <p>Initializes the code generator.</p> </li> </ul> <p>---</p> <ul> <li> <p>skip_comments:</p> <p>:   -   Description: This method iterates through the token list         and advances the position until the current token is no         longer identified as a comment. It handles both single-line         and multi-line comments by continuously consuming tokens         classified as [COMMENT_SINGLE]{.title-ref} or         [COMMENT_MULTI]{.title-ref}.     -   Parameters: None     -   Returns: None</p> </li> </ul> <p>---</p> <ul> <li> <p>eat :</p> <p>:   -   Description: This method checks if the current token         matches the specified [token_type]{.title-ref}. If it does,         the token is consumed, and the position is incremented to         the next token. After consuming the token, comments are         skipped by calling skip_comments. If the current token does         not match the expected token type, a         [SyntaxError]{.title-ref} is raised.</p> <pre><code>-\n\n    **Parameters**:\n\n    :   -   [token_type]{.title-ref} (str): The expected token\n            type.\n\n-   **Returns**: None\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse_uniforms:</p> <p>:   -   Description: This method processes the shader code to         identify and extract uniform declarations. It starts by         consuming the [\\\"UNIFORM\\\"]{.title-ref} token and then reads         the uniform's type and name. The method expects uniform         types to be one of [\\\"VECTOR\\\"]{.title-ref},         [\\\"FLOAT\\\"]{.title-ref}, [\\\"DOUBLE\\\"]{.title-ref},         [\\\"UINT\\\"]{.title-ref}, [\\\"INT\\\"]{.title-ref}, or         [\\\"SAMPLER2D\\\"]{.title-ref}. After parsing the type and         name, it consumes the following [\\\"SEMICOLON\\\"]{.title-ref}         token. The method returns a list of         [UniformNode]{.title-ref} objects representing the parsed         uniform declarations.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`list\\`: A list of [UniformNode]{.title-ref}\n            objects.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token is not\n            [\\\"UNIFORM\\\"]{.title-ref} or if an unexpected token\n            is encountered when parsing the uniform type.\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse :</p> <p>:   -   Description: This method initiates the parsing process         for the shader code. It calls the parse_shader method to         handle the specifics of shader code parsing and constructs         the abstract syntax tree (AST) that represents the structure         and components of the shader.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`ShaderNode\\`: The root node of the abstract syntax\n            tree (AST) representing the parsed shader code.\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse_shader:</p> <p>:   -   Description: This method processes the shader code to         construct a [ShaderNode]{.title-ref} object. It starts by         consuming the \"SHADER\" token and then skips any comments. It         extracts the shader's name, then parses global inputs,         uniforms, outputs, and sections for vertex and fragment         shaders. It also collects global functions. The method         continues parsing until it encounters the closing brace of         the shader definition and constructs a         [ShaderNode]{.title-ref} representing the shader's         structure.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`ShaderNode\\`: The root node of the abstract syntax\n            tree (AST) representing the parsed shader code.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match\n            the expected token type, indicating a syntax issue\n            in the shader code.\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse_shader_section:</p> <p>:   -   Description: This method processes a specific shader         section, either \"VERTEX\" or \"FRAGMENT\", by consuming the         section header and opening brace. It then collects and         processes inputs, outputs, functions, and intermediate         statements until it encounters the closing brace. It         constructs and returns a [VERTEXShaderNode]{.title-ref} or         [FRAGMENTShaderNode]{.title-ref} based on the         [section_type]{.title-ref} parameter.</p> <pre><code>-\n\n    **Parameters**:\n\n    :   -   [section_type]{.title-ref} (str): The type of shader\n            section to parse, either \"VERTEX\" or \"FRAGMENT\".\n\n-\n\n    **Returns**:\n\n    :   -   [VERTEXShaderNode]{.title-ref} or\n            \\`FRAGMENTShaderNode\\`: The root node of the AST for\n            the specified shader section.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match\n            the expected token type, indicating a syntax issue\n            in the shader section.\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse_inputs:</p> <p>:   -   Description: This method processes and extracts input         declarations from the shader code by consuming the \"INPUT\"         token, followed by the variable type and name. It collects         these declarations into a list until it encounters a token         that is not an \"INPUT\".</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`list\\`: A list of tuples representing the input\n            declarations, where each tuple contains the type and\n            name of an input.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match\n            the expected input types (VECTOR, FLOAT, DOUBLE,\n            UINT, INT, MATRIX, or SAMPLER2D).\n</code></pre> </li> </ul> <p>---</p> <ul> <li> <p>parse_outputs:</p> <p>:   -   Description: This method processes and extracts output         declarations from the shader code by consuming the \"OUTPUT\"         token, followed by the variable type and name. It continues         to collect these declarations into a list until it         encounters a token that is not an \"OUTPUT\".</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`list\\`: A list of tuples representing the output\n            declarations, where each tuple contains the type and\n            name of an output.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match\n            the expected output types (VECTOR, FLOAT, DOUBLE,\n            UINT, INT, MATRIX, or SAMPLER2D).\n</code></pre> </li> </ul> <p>---</p> <p>parse_function</p> <p>:   -   Description: This method processes a function declaration by         extracting the return type, function name, parameters, and body.         It expects either \"MAIN\" or an \"IDENTIFIER\" as the function         name, then parses the function's parameters enclosed in         parentheses, and finally, parses the function's body within         curly braces.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`FunctionNode\\`: A [FunctionNode]{.title-ref} object\n            representing the parsed function declaration, including\n            its return type, name, parameters, and body.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected format for a function declaration, such as not\n            finding \"MAIN\" or an \"IDENTIFIER\" where expected.\n</code></pre> <p>parse_parameters</p> <p>:   -   Description: This method processes function parameters by         collecting them into a list. It handles multiple parameters         separated by commas and continues parsing until the closing         parenthesis is encountered.</p> <pre><code>-   **Parameters**: None.\n\n-\n\n    **Returns**:\n\n    :   -   \\`list\\`: A list of function parameters, where each\n            parameter is represented according to the shader\n            language's syntax.\n\n-\n\n    **Raises**:\n\n    :   -   [None]{.title-ref}.\n</code></pre> <p>parse_parameter</p> <p>:   -   Description: This method extracts the type and name of a         function parameter. It processes the parameter type using the         [parse_type]{.title-ref} method and captures the parameter name         from the current token.</p> <pre><code>-   **Parameters**: None.\n\n-\n\n    **Returns**:\n\n    :   -   \\`tuple\\`: A tuple containing the parameter type and\n            name.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected type for a parameter.\n</code></pre> <p>parse_type</p> <p>:   -   Description: This method identifies and returns the type of         a shader variable or function. It handles basic shader types         such as [void]{.title-ref}, [VECTOR]{.title-ref},         [FLOAT]{.title-ref}, [DOUBLE]{.title-ref}, [UINT]{.title-ref},         [INT]{.title-ref}, [MATRIX]{.title-ref},         [SAMPLER2D]{.title-ref}, and user-defined types. The method         checks the current token and returns the appropriate type         string.</p> <pre><code>-   **Parameters**: None.\n\n-\n\n    **Returns**:\n\n    :   -   \\`str\\`: The name of the type.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match a\n            valid type declaration.\n</code></pre> <p>parse_body</p> <p>:   -   Description: This method processes the statements within a         function body, constructing a list of statements by identifying         and parsing control structures ([IF]{.title-ref},         [FOR]{.title-ref}), return statements, and assignments or         function calls. It continues parsing until it encounters a         closing brace [RBRACE]{.title-ref} or end-of-file         [EOF]{.title-ref}.</p> <pre><code>-   **Parameters**: None.\n\n-\n\n    **Returns**:\n\n    :   -   \\`list\\`: A list of statements contained in the function\n            body.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If an unexpected token is encountered\n            while parsing the function body.\n</code></pre> <p>parse_if_statement</p> <p>:   -   Description: This method processes an [if]{.title-ref}         statement by extracting the condition, the body of the         [if]{.title-ref} block, and optionally the [else]{.title-ref}         block if present. It constructs an [IfNode]{.title-ref} object         representing the parsed [if]{.title-ref} statement, including         its condition and the corresponding bodies for the         [if]{.title-ref} and [else]{.title-ref} branches.</p> <pre><code>-   **Parameters**: None.\n\n-\n\n    **Returns**:\n\n    :   -   \\`IfNode\\`: An [IfNode]{.title-ref} object representing\n            the [if]{.title-ref} statement, including the condition\n            and the bodies for both the [if]{.title-ref} and\n            [else]{.title-ref} blocks.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected structure of an [if]{.title-ref} statement.\n</code></pre> <p>peak</p> <p>:   -   Description: This method retrieves the token that is         [n]{.title-ref} positions ahead in the token list without         advancing the current position. It allows inspection of future         tokens for decision-making during parsing.</p> <pre><code>-\n\n    **Parameters**:\n\n    :   -   \\`n (int)\\`: The number of tokens to peek ahead in the\n            token list.\n\n-\n\n    **Returns**:\n\n    :   -   \\`tuple\\`: The nth token ahead in the token list.\n\n-\n\n    **Raises**:\n\n    :   -   \\`IndexError\\`: If peeking beyond the end of the token\n            list.\n</code></pre> <p>parse_for_loop</p> <p>:   -   Description: This method processes the components of a for         loop, including initialization, condition, update, and body. It         constructs a [ForNode]{.title-ref} object representing the for         loop structure.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`ForNode\\`: An object representing the parsed for loop,\n            including its initialization, condition, update, and\n            body.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected for loop structure.\n</code></pre> <p>parse_update</p> <p>:   -   Description: This method interprets an update statement,         handling both increment and decrement operations. It constructs         a [VariableNode]{.title-ref} object representing the update         statement with the appropriate operation.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the update\n            statement, which could be a [VariableNode]{.title-ref}\n            reflecting an increment or decrement operation.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected update statement structure.\n</code></pre> <p>parse_return_statement</p> <p>:   -   Description: This method interprets a return statement,         capturing the values to be returned. It constructs a         [ReturnNode]{.title-ref} object that represents the return         statement with the appropriate return values.</p> <pre><code>-   **Parameters**: None\n\n-\n\n    **Returns**:\n\n    :   -   \\`ReturnNode\\`: An object representing the return\n            statement, containing a list of values to be returned.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected return statement structure.\n</code></pre> <p>parse_assignment_or_function_call</p> <p>:   -   Description: This method interprets either an assignment         statement or a function call. It handles various types of         assignment operations and updates to variables. Additionally, it         processes function calls when the identifier is followed by         parentheses.</p> <pre><code>-\n\n    **Parameters**:\n\n    :   -   [update_condition]{.title-ref} (bool, optional): A flag\n            indicating whether the parsing should handle special\n            update conditions (e.g., increment or decrement\n            operations). Default is [False]{.title-ref}.\n\n-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the assignment or\n            function call. This could be an\n            [AssignmentNode]{.title-ref},\n            [FunctionCallNode]{.title-ref}, or a modified\n            [VariableNode]{.title-ref} if an increment or decrement\n            operation is detected.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match any\n            expected patterns for assignments, function calls, or\n            updates.\n</code></pre> <p>parse_variable_declaration</p> <p>:   -   Description: This method parses a variable declaration,         handling both simple declarations and assignments. It constructs         a [VariableNode]{.title-ref} or [BinaryOpNode]{.title-ref}         representing the variable declaration or assignment, including         handling for member access and compound assignments.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   [VariableNode]{.title-ref} or \\`BinaryOpNode\\`: An\n            object representing the variable declaration or\n            assignment.\n\n-\n\n    **Raises**:\n\n    :   -   [SyntaxError]{.title-ref} : If the current token does\n            not match the expected variable declaration or\n            assignment structure.\n</code></pre> <p>parse_assignment</p> <p>:   -   Description: This method parses an assignment statement,         including various assignment operators. It constructs a         [BinaryOpNode]{.title-ref} representing the assignment         operation, with the variable name and the assigned value.</p> <pre><code>-\n\n    **Attributes**:\n\n    :   -   \\`name (str)\\`: The name of the variable being assigned.\n\n-\n\n    **Returns**:\n\n    :   -   \\`BinaryOpNode\\`: An object representing the assignment\n            statement.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected assignment operator or structure.\n</code></pre> <p>parse_additive</p> <p>:   -   Description: This method parses an additive expression,         which includes addition and subtraction operations. It         constructs a [BinaryOpNode]{.title-ref} representing the         additive expression, handling multiple operations as needed.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the additive\n            expression.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: Not applicable for this method, as it\n            does not handle syntax errors directly.\n</code></pre> <p>parse_multiplicative</p> <p>:   -   Description: This method parses a multiplicative expression,         which includes multiplication and division operations. It         constructs a [BinaryOpNode]{.title-ref} representing the         multiplicative expression, handling multiple operations as         needed.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the multiplicative\n            expression.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: Not applicable for this method, as it\n            does not handle syntax errors directly.\n</code></pre> <p>parse_unary</p> <p>:   -   Description: This method parses a unary expression,         including unary plus and minus operations. It constructs a         [UnaryOpNode]{.title-ref} representing the unary expression or         proceeds to parse a primary expression if no unary operators are         present.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the unary\n            expression.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: Not applicable for this method, as it\n            does not handle syntax errors directly.\n</code></pre> <p>parse_primary</p> <p>:   -   Description: This method parses primary expressions, which         include parenthesized expressions, numeric literals, and         identifiers. It handles different token types to construct the         appropriate AST node or value. If the token is not recognized as         a valid primary expression, it raises a         [SyntaxError]{.title-ref}.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the primary\n            expression, which could be a value or a node from a\n            function call or identifier.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match a\n            valid primary expression.\n</code></pre> <p>parse_function_call</p> <p>:   -   Description: This method interprets a function call by         reading the function name and its arguments. It constructs a         [FunctionCallNode]{.title-ref} object representing the function         call with the parsed arguments.</p> <pre><code>-\n\n    **Attributes**:\n\n    :   -   \\`name (str)\\`: The name of the function being called.\n\n-\n\n    **Returns**:\n\n    :   -   \\`FunctionCallNode\\`: An object representing the\n            function call, including the function name and a list of\n            arguments.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected structure for a function call.\n</code></pre> <p>parse_expression</p> <p>:   -   Description: This method interprets an expression, handling         various operators to construct a [BinaryOpNode]{.title-ref} that         represents the expression's structure.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the parsed\n            expression, which could be a [BinaryOpNode]{.title-ref}\n            reflecting the expression's operators and operands.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected structure for an expression.\n</code></pre> <p>parse_ternary</p> <p>:   -   Description: This method interprets a ternary expression,         handling the ternary operator ([? :]{.title-ref}) to construct a         [TernaryOpNode]{.title-ref} that represents the ternary         expression's condition and its two possible outcomes.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing the parsed ternary\n            expression, which could be a [TernaryOpNode]{.title-ref}\n            reflecting the condition and both branches of the\n            ternary operator.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected structure for a ternary expression.\n</code></pre> <p>parse_function_call_or_identifier</p> <p>:   -   Description: This method determines whether the current         token represents a function call or a simple identifier. It         constructs a [FunctionCallNode]{.title-ref} if it detects a         function call, or a [VariableNode]{.title-ref} if it detects an         identifier. It also handles member access if a dot         ([.]{.title-ref}) follows the identifier.</p> <pre><code>-\n\n    **Returns**:\n\n    :   -   \\`ASTNode\\`: An object representing either a\n            [FunctionCallNode]{.title-ref} for function calls, a\n            [VariableNode]{.title-ref} for identifiers, or a member\n            access node if applicable.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token does not match the\n            expected structure for a function call or identifier.\n</code></pre> <p>parse_member_access</p> <p>:   -   Description: This method parses member access operations,         such as accessing a field of an object. It constructs a         [MemberAccessNode]{.title-ref} representing the member access         and handles cases where multiple member accesses are chained.</p> <pre><code>-\n\n    **Attributes**:\n\n    :   -   \\`object (str)\\`: The object being accessed.\n\n-\n\n    **Returns**:\n\n    :   -   \\`MemberAccessNode\\`: An object representing the member\n            access operation.\n\n-\n\n    **Raises**:\n\n    :   -   \\`SyntaxError\\`: If the current token is not a valid\n            identifier following the dot ([.]{.title-ref}), or if\n            the structure of the member access is not valid.\n</code></pre>"},{"location":"pages/graphica/api_reference/#api-references-for-directx-metal-and-opengl-to-crossgl","title":"API References For DirectX , Metal And OpenGL To CrossGL","text":""},{"location":"pages/graphica/api_reference/#directx-ast","title":"DirectX AST","text":""},{"location":"pages/graphica/api_reference/#ternaryopnode","title":"TernaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a ternary operation in an abstract syntax tree (AST).</li> <li>Contains the condition, the expression to evaluate if the     condition is true, and the expression to evaluate if the     condition is false.</li> </ul> </li> <li>Attributes:<ul> <li>`condition`: The condition expression for the ternary     operation.</li> <li>`true_expr`: The expression evaluated when the condition is     true.</li> <li>`false_expr`: The expression evaluated when the condition is     false.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [TernaryOpNode]{.title-ref} instance, including the     condition, true expression, and false expression.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#shadernode","title":"ShaderNode","text":"<ul> <li>Description:<ul> <li>Represents a shader in an abstract syntax tree (AST).</li> <li>Contains structures for vertex and pixel shader inputs and     outputs, as well as functions defined within the shader.</li> </ul> </li> <li>Attributes:<ul> <li>`vsinput_struct`: The structure defining the inputs for the     vertex shader.</li> <li>`vsoutput_struct`: The structure defining the outputs for the     vertex shader.</li> <li>`psinput_struct`: The structure defining the inputs for the     pixel shader.</li> <li>`psoutput_struct`: The structure defining the outputs for the     pixel shader.</li> <li>`functions`: The list of functions defined within the shader.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [ShaderNode]{.title-ref} instance, including the vertex and     pixel shader input/output structures and functions.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#structnodetitle-ref","title":"[StructNode]{.title-ref}","text":"<ul> <li>Description:<ul> <li>Represents a structure in an abstract syntax tree (AST).</li> <li>Contains the name of the structure and its members.</li> </ul> </li> <li>Attributes:<ul> <li>`name`: The name of the structure.</li> <li>`members`: The list of members (fields) within the structure.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [StructNode]{.title-ref} instance, including the structure's     name and its members.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#functionnode","title":"FunctionNode","text":"<ul> <li>Description:<ul> <li>Represents a function in an abstract syntax tree (AST).</li> <li>Contains the function's return type, name, parameters, and body.</li> </ul> </li> <li>Attributes:<ul> <li>`return_type`: The return type of the function.</li> <li>`name`: The name of the function.</li> <li>`params`: The list of parameters for the function.</li> <li>`body`: The body of the function, containing the statements to     be executed.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [FunctionNode]{.title-ref} instance, including the return     type, name, parameters, and body of the function.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#variablenode","title":"VariableNode","text":"<ul> <li>Description:<ul> <li>Represents a variable in an abstract syntax tree (AST).</li> <li>Contains the variable's type, name, and optional semantic     information.</li> </ul> </li> <li>Attributes:<ul> <li>`vtype`: The type of the variable.</li> <li>`name`: The name of the variable.</li> <li>`semantic`: Optional semantic information associated with the     variable.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [VariableNode]{.title-ref} instance, including the     variable's type, name, and semantic information.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#assignmentnode","title":"AssignmentNode","text":"<ul> <li>Description:<ul> <li>Represents an assignment operation in an abstract syntax tree     (AST).</li> <li>Contains the left-hand side (variable or expression), right-hand     side (value or expression), and the operator used for the     assignment.</li> </ul> </li> <li>Attributes:<ul> <li>`left`: The left-hand side of the assignment (variable or     expression).</li> <li>`right`: The right-hand side of the assignment (value or     expression).</li> <li>`operator`: The operator used for the assignment, defaulting     to [\\\"=\\\"]{.title-ref}.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [AssignmentNode]{.title-ref} instance, including the     left-hand side, operator, and right-hand side of the     assignment.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#ifnode","title":"IfNode","text":"<ul> <li>Description:<ul> <li>Represents an [if]{.title-ref} statement in an abstract syntax     tree (AST).</li> <li>Contains the condition for the [if]{.title-ref} statement, the     body to execute if the condition is true, and an optional body     for the [else]{.title-ref} branch.</li> </ul> </li> <li>Attributes:<ul> <li>`condition`: The condition to evaluate for the     [if]{.title-ref} statement.</li> <li>`if_body`: The body of code to execute if the condition is     true.</li> <li>`else_body`: The optional body of code to execute if the     condition is false.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the [IfNode]{.title-ref}     instance, including the condition, [if]{.title-ref} body,     and [else]{.title-ref} body.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#fornode","title":"ForNode","text":"<ul> <li>Description:<ul> <li>Represents a [for]{.title-ref} loop statement in an abstract     syntax tree (AST).</li> <li>Contains the initialization, condition, update expression, and     the body of the loop.</li> </ul> </li> <li>Attributes:<ul> <li>`init`: The initialization expression for the     [for]{.title-ref} loop.</li> <li>`condition`: The condition to evaluate for continuing the     loop.</li> <li>`update`: The update expression to modify the loop variable.</li> <li>`body`: The body of code to execute during each iteration of     the loop.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the [ForNode]{.title-ref}     instance, including the initialization, condition, update,     and body of the [for]{.title-ref} loop.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#returnnode","title":"ReturnNode","text":"<ul> <li>Description:<ul> <li>Represents a [return]{.title-ref} statement in an abstract     syntax tree (AST).</li> <li>Contains the value to be returned from a function or method.</li> </ul> </li> <li>Attributes:<ul> <li>`value`: The value to return from the function or method.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [ReturnNode]{.title-ref} instance, including the value to be     returned.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#functioncallnode","title":"FunctionCallNode","text":"<ul> <li>Description:<ul> <li>Represents a function call in an abstract syntax tree (AST).</li> <li>Contains the name of the function being called and the arguments     passed to it.</li> </ul> </li> <li>Attributes:<ul> <li>`name`: The name of the function being called.</li> <li>`args`: The list of arguments passed to the function.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [FunctionCallNode]{.title-ref} instance, including the     function name and arguments.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#binaryopnode","title":"BinaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a binary operation in an abstract syntax tree (AST).</li> <li>Contains the left operand, the operator used, and the right     operand.</li> </ul> </li> <li>Attributes:<ul> <li>`left`: The left operand of the binary operation.</li> <li>`op`: The operator used in the binary operation.</li> <li>`right`: The right operand of the binary operation.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [BinaryOpNode]{.title-ref} instance, including the left     operand, operator, and right operand.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#memberaccessnode","title":"MemberAccessNode","text":"<ul> <li>Description:<ul> <li>Represents access to a member of an object in an abstract syntax     tree (AST).</li> <li>Contains the object being accessed and the member being     accessed.</li> </ul> </li> <li>Attributes:<ul> <li>`object`: The object whose member is being accessed.</li> <li>`member`: The member of the object being accessed.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [MemberAccessNode]{.title-ref} instance, including the     object and the member.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#vectorconstructornode","title":"VectorConstructorNode","text":"<ul> <li>Description:<ul> <li>Represents a vector constructor in an abstract syntax tree     (AST).</li> <li>Contains the type of the vector and the arguments used to     initialize it.</li> </ul> </li> <li>Attributes:<ul> <li>`type_name`: The type of the vector being constructed.</li> <li>`args`: The list of arguments used to initialize the vector.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [VectorConstructorNode]{.title-ref} instance, including the     vector type and arguments.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#unaryopnode","title":"UnaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a unary operation in an abstract syntax tree (AST).</li> <li>Contains the operator used and the operand on which the     operation is performed.</li> </ul> </li> <li>Attributes:<ul> <li>`op`: The operator used in the unary operation.</li> <li>`operand`: The operand on which the unary operation is     applied.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Returns a string representation of the     [UnaryOpNode]{.title-ref} instance, including the operator     and operand.</li> </ul> </li> <li>`__str__`:<ul> <li>Returns a formatted string of the unary operation, showing     the operator followed by the operand.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#directx-lexer","title":"DirectX Lexer","text":""},{"location":"pages/graphica/api_reference/#tokens","title":"Tokens","text":"<ul> <li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with <code>//</code>.</li> <li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed by     <code>/* ... */</code>.</li> <li><code>STRUCT</code>: Matches the keyword <code>struct</code>.</li> <li><code>CBUFFER</code>: Matches the keyword <code>cbuffer</code>.</li> <li><code>TEXTURE2D</code>: Matches the keyword <code>Texture2D</code>.</li> <li><code>SAMPLER_STATE</code>: Matches the keyword <code>SamplerState</code>.</li> <li><code>FVECTOR</code>: Matches float vector types (e.g., <code>float2</code>, <code>float3</code>,     <code>float4</code>).</li> <li><code>FLOAT</code>: Matches the keyword <code>float</code>.</li> <li><code>INT</code>: Matches the keyword <code>int</code>.</li> <li><code>UINT</code>: Matches the keyword <code>uint</code>.</li> <li><code>BOOL</code>: Matches the keyword <code>bool</code>.</li> <li><code>MATRIX</code>: Matches matrix types (e.g., <code>float2x2</code>, <code>float3x3</code>,     <code>float4x4</code>).</li> <li><code>VOID</code>: Matches the keyword <code>void</code>.</li> <li><code>RETURN</code>: Matches the keyword <code>return</code>.</li> <li><code>IF</code>: Matches the keyword <code>if</code>.</li> <li><code>ELSE_IF</code>: Matches <code>else if</code> keyword.</li> <li><code>ELSE</code>: Matches the keyword <code>else</code>.</li> <li><code>FOR</code>: Matches the keyword <code>for</code>.</li> <li><code>REGISTER</code>: Matches the keyword <code>register</code>.</li> <li><code>SEMANTIC</code>: Matches semantic annotations (e.g., <code>: POSITION</code>).</li> <li><code>IDENTIFIER</code>: Matches identifiers (variable names, function names,     etc.).</li> <li><code>NUMBER</code>: Matches numerical literals (integers and floats).</li> <li><code>LBRACE</code>: Matches the left brace <code>{</code>.</li> <li><code>RBRACE</code>: Matches the right brace <code>}</code>.</li> <li><code>LPAREN</code>: Matches the left parenthesis <code>(</code>.</li> <li><code>RPAREN</code>: Matches the right parenthesis <code>)</code>.</li> <li><code>LBRACKET</code>: Matches the left bracket <code>[</code>.</li> <li><code>RBRACKET</code>: Matches the right bracket <code>]</code>.</li> <li><code>SEMICOLON</code>: Matches the semicolon <code>;</code>.</li> <li><code>COMMA</code>: Matches the comma <code>,</code>.</li> <li><code>COLON</code>: Matches the colon <code>:</code>.</li> <li><code>QUESTION</code>: Matches the question mark <code>?</code>.</li> <li><code>LESS_EQUAL</code>: Matches the less than or equal to operator <code>&lt;=</code>.</li> <li><code>GREATER_EQUAL</code>: Matches the greater than or equal to operator <code>&gt;=</code>.</li> <li><code>LESS_THAN</code>: Matches the less than operator <code>&lt;</code>.</li> <li><code>GREATER_THAN</code>: Matches the greater than operator <code>&gt;</code>.</li> <li><code>EQUAL</code>: Matches the equality operator <code>==</code>.</li> <li><code>NOT_EQUAL</code>: Matches the not equal to operator <code>!=</code>.</li> <li><code>PLUS_EQUALS</code>: Matches the <code>+=</code> operator.</li> <li><code>MINUS_EQUALS</code>: Matches the <code>-=</code> operator.</li> <li><code>MULTIPLY_EQUALS</code>: Matches the <code>*=</code> operator.</li> <li><code>DIVIDE_EQUALS</code>: Matches the <code>/=</code> operator.</li> <li><code>AND</code>: Matches the logical AND operator <code>&amp;&amp;</code>.</li> <li><code>OR</code>: Matches the logical OR operator <code>||</code>.</li> <li><code>DOT</code>: Matches the dot operator <code>.</code>.</li> <li><code>MULTIPLY</code>: Matches the multiplication operator <code>*</code>.</li> <li><code>DIVIDE</code>: Matches the division operator <code>/</code>.</li> <li><code>PLUS</code>: Matches the addition operator <code>+</code>.</li> <li><code>MINUS</code>: Matches the subtraction operator <code>-</code>.</li> <li><code>EQUALS</code>: Matches the assignment operator <code>=</code>.</li> <li><code>WHITESPACE</code>: Matches whitespace characters.</li> </ul>"},{"location":"pages/graphica/api_reference/#keywords","title":"Keywords","text":"<ul> <li><code>struct</code>: Maps to <code>STRUCT</code>.</li> <li><code>cbuffer</code>: Maps to <code>CBUFFER</code>.</li> <li><code>Texture2D</code>: Maps to <code>TEXTURE2D</code>.</li> <li><code>SamplerState</code>: Maps to <code>SAMPLER_STATE</code>.</li> <li><code>float</code>: Maps to <code>FLOAT</code>.</li> <li><code>float2</code>, <code>float3</code>, <code>float4</code>: Map to <code>FVECTOR</code>.</li> <li><code>int</code>: Maps to <code>INT</code>.</li> <li><code>uint</code>: Maps to <code>UINT</code>.</li> <li><code>bool</code>: Maps to <code>BOOL</code>.</li> <li><code>void</code>: Maps to <code>VOID</code>.</li> <li><code>return</code>: Maps to <code>RETURN</code>.</li> <li><code>if</code>: Maps to <code>IF</code>.</li> <li><code>else</code>: Maps to <code>ELSE</code>.</li> <li><code>for</code>: Maps to <code>FOR</code>.</li> <li><code>register</code>: Maps to <code>REGISTER</code>.</li> </ul> <ul> <li>Description:<ul> <li>Initializes the lexer with the given source code.</li> <li>Tokenizes the source code into a list of tokens.</li> </ul> </li> <li>Parameters:<ul> <li>`code`: The source code to be tokenized.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#tokenize-1","title":"Tokenize:","text":"<ul> <li>Description:<ul> <li>Tokenizes the source code into a list of tokens based on defined     patterns.</li> <li>Iterates through the source code, matches patterns, and     categorizes tokens, while ignoring whitespace and comments.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>`SyntaxError`: If an illegal character is encountered in the     source code.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#directx-parser","title":"DirectX Parser","text":"<p>::: {#init__-1}</p> <p>:::</p> <ul> <li>Description:<ul> <li>Initializes the parser with a list of tokens.</li> <li>Sets the initial position and current token, and skips any     initial comments.</li> </ul> </li> <li>Parameters:<ul> <li>`tokens`: The list of tokens to be parsed.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#skip_comments","title":"skip_comments","text":"<ul> <li>Description:<ul> <li>Skips over tokens that are comments (both single-line and     multi-line) in the source code.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#eat","title":"eat","text":"<ul> <li>Description:<ul> <li>Consumes the current token if it matches the expected type.</li> <li>Advances to the next token and skips any comments following the     current token.</li> </ul> </li> <li>Parameters:<ul> <li>`token_type`: The type of token expected to be consumed.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>`SyntaxError`: If the current token does not match the     expected token type.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse","title":"parse","text":"<ul> <li>Description:<ul> <li>Parses the entire shader code by calling parse_shader.</li> <li>Ensures that the end of the file (EOF) is reached after parsing.</li> </ul> </li> <li>Returns:<ul> <li>The parsed shader object.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_shader","title":"parse_shader","text":"<ul> <li>Description:<ul> <li>Parses the shader code to extract structures and functions.</li> <li>Identifies and assigns structures to specific shader stages and     collects functions.</li> </ul> </li> <li>Returns:<ul> <li>A [ShaderNode]{.title-ref} object containing the parsed     structures and functions.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_struct","title":"parse_struct","text":"<ul> <li>Description:<ul> <li>Parses a structure definition, including its name and members.</li> <li>Processes each member's type, name, and optional semantic     information.</li> </ul> </li> <li>Returns:<ul> <li>A [StructNode]{.title-ref} object representing the parsed     structure.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function","title":"parse_function","text":"<ul> <li>Description:<ul> <li>Parses a function definition, including its return type, name,     parameters, and body.</li> <li>Handles optional semantic tokens and constructs a     [FunctionNode]{.title-ref} with the parsed details.</li> </ul> </li> <li>Returns:<ul> <li>A [FunctionNode]{.title-ref} object representing the parsed     function.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_parameters","title":"parse_parameters","text":"<ul> <li>Description:<ul> <li>Parses function parameters, including their types, names, and     optional semantic information.</li> <li>Continues parsing until the closing parenthesis is encountered.</li> </ul> </li> <li>Returns:<ul> <li>A list of [VariableNode]{.title-ref} objects representing the     function parameters.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_block","title":"parse_block","text":"<ul> <li>Description:<ul> <li>Parses a block of statements enclosed in braces.</li> <li>Collects and returns statements until the closing brace is     encountered.</li> </ul> </li> <li>Returns:<ul> <li>A list of statements parsed from the block.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_statement","title":"parse_statement","text":"<ul> <li>Description:<ul> <li>Parses different types of statements based on the current token.</li> <li>Handles variable declarations or assignments, [if]{.title-ref}     statements, [for]{.title-ref} loops, [return]{.title-ref}     statements, and expressions.</li> </ul> </li> <li>Returns:<ul> <li>A statement node representing the parsed statement.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_variable_declaration_or_assignment","title":"parse_variable_declaration_or_assignment","text":"<ul> <li>Description:<ul> <li>Parses variable declarations, assignments, and other related     statements based on the current token.</li> <li>Handles various scenarios including simple declarations,     assignments with expressions, and compound assignments.</li> </ul> </li> <li>Returns:<ul> <li>A node representing a variable declaration or assignment, or an     expression statement if none of the previous conditions are met.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_if_statement","title":"parse_if_statement","text":"<ul> <li>Description:<ul> <li>Parses an [if]{.title-ref} statement, including its condition,     the body of the [if]{.title-ref} block, and optionally an     [else]{.title-ref} or [else if]{.title-ref} block.</li> <li>Handles nested [else if]{.title-ref} statements by delegating to     [parse_else_if_statement]{.title-ref} if the next token is     [ELSE_IF]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>An [IfNode]{.title-ref} representing the parsed [if]{.title-ref}     statement, including its condition, [if]{.title-ref} block, and     optional [else]{.title-ref} or [else if]{.title-ref} block.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_else_if_statement","title":"parse_else_if_statement","text":"<ul> <li>Description:<ul> <li>Parses an [else if]{.title-ref} statement, including its     condition, the body of the [else if]{.title-ref} block, and     optionally an [else]{.title-ref} or another [else     if]{.title-ref} block.</li> <li>Handles nested [else if]{.title-ref} statements by calling     [parse_else_if_statement]{.title-ref} recursively.</li> </ul> </li> <li>Returns:<ul> <li>An [IfNode]{.title-ref} representing the parsed [else     if]{.title-ref} statement, including its condition, [else     if]{.title-ref} block, and optional [else]{.title-ref} or nested     [else if]{.title-ref} blocks.</li> </ul> </li> <li>Raises:<ul> <li>None</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_for_statement","title":"parse_for_statement","text":"<ul> <li>Description:<ul> <li>Parses a [for]{.title-ref} loop statement, including     initialization, loop condition, update expression, and the loop     body.</li> <li>Handles initialization of variables or simple expressions.</li> <li>Extracts and processes the condition and update expressions,     along with the body of the loop.</li> </ul> </li> <li>Returns:<ul> <li>A [ForNode]{.title-ref} representing the parsed     [for]{.title-ref} loop statement, including the initialization,     condition, update expression, and body of the loop.</li> </ul> </li> <li>Raises:<ul> <li>[SyntaxError]{.title-ref} if the [for]{.title-ref} statement's     syntax is incorrect or missing required components.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_return_statement","title":"parse_return_statement","text":"<ul> <li>Description:<ul> <li>Parses a [return]{.title-ref} statement.</li> <li>Extracts the return value and ensures it is followed by a     semicolon.</li> </ul> </li> <li>Returns:<ul> <li>A [ReturnNode]{.title-ref} containing the parsed return value.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_expression_statement","title":"parse_expression_statement","text":"<ul> <li>Description:<ul> <li>Parses a statement that consists of an expression followed by a     semicolon.</li> <li>Handles expressions that may be standalone or part of more     complex statements.</li> </ul> </li> <li>Returns:<ul> <li>The parsed expression, which could be any valid expression node     ([BinaryOpNode]{.title-ref}, [UnaryOpNode]{.title-ref},     [FunctionCallNode]{.title-ref}, etc.).</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_expression","title":"parse_expression","text":"<ul> <li>Description:<ul> <li>Parses an expression that may involve assignment operators,     ternary operations, and logical operations.</li> <li>Handles assignment ([=]{.title-ref}, [+=]{.title-ref},     [-=]{.title-ref}, [*=]{.title-ref}, [/=]{.title-ref}) and     ternary ([condition ? true_expr : false_expr]{.title-ref})     operators.</li> </ul> </li> <li>Returns:<ul> <li>The root node of the parsed expression, which could be an     [AssignmentNode]{.title-ref}, [TernaryOpNode]{.title-ref}, or     another type of expression node.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_assignment","title":"parse_assignment","text":"<ul> <li>Description:<ul> <li>Parses an assignment expression, which can be a simple     assignment or involve nested assignments.</li> <li>Handles the assignment operator ([=]{.title-ref}) and     recursively parses the right-hand side of the assignment.</li> </ul> </li> <li>Returns:<ul> <li>An [AssignmentNode]{.title-ref} representing the assignment     operation, or the left-hand side expression if no assignment     operator is found.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_logical_or","title":"parse_logical_or","text":"<ul> <li>Description:<ul> <li>Parses logical OR expressions, handling multiple OR operations.</li> <li>Constructs a binary operation node for each logical OR     ([||]{.title-ref}) encountered.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the logical OR     operation, with nested binary operations for multiple OR     expressions.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_logical_and","title":"parse_logical_and","text":"<ul> <li>Description:<ul> <li>Parses logical AND expressions, handling multiple AND     operations.</li> <li>Constructs a binary operation node for each logical AND     ([&amp;&amp;]{.title-ref}) encountered.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the logical AND     operation, with nested binary operations for multiple AND     expressions.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_equality","title":"parse_equality","text":"<ul> <li>Description:<ul> <li>Parses equality and inequality expressions, handling multiple     equality checks.</li> <li>Constructs a binary operation node for each equality     ([==]{.title-ref}) or inequality ([!=]{.title-ref}) operation     encountered.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the equality or     inequality operation, with nested binary operations for multiple     equality checks.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_relational","title":"parse_relational","text":"<ul> <li>Description:<ul> <li>Parses relational expressions, handling comparisons like less     than ([\\&lt;]{.title-ref}), greater than ([&gt;]{.title-ref}), less     than or equal to ([\\&lt;=]{.title-ref}), and greater than or equal     to ([&gt;=]{.title-ref}).</li> <li>Constructs a binary operation node for each relational operation     encountered.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the relational     operation, with nested binary operations for multiple     comparisons.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_additive","title":"parse_additive","text":"<ul> <li>Description:<ul> <li>Parses additive expressions, which involve addition     ([+]{.title-ref}) and subtraction ([-]{.title-ref}).</li> <li>Constructs a [BinaryOpNode]{.title-ref} for each additive     operation, with nested binary operations for multiple additions     or subtractions.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the additive     operation, with nested binary operations for multiple additive     expressions.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_multiplicative","title":"parse_multiplicative","text":"<ul> <li>Description:<ul> <li>Parses multiplicative expressions, which include multiplication     ([*]{.title-ref}) and division ([/]{.title-ref}).</li> <li>Constructs a [BinaryOpNode]{.title-ref} for each multiplicative     operation, handling nested expressions where multiple     multiplicative operations are present.</li> </ul> </li> <li>Returns:<ul> <li>A [BinaryOpNode]{.title-ref} representing the multiplicative     operation, including any nested operations.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_unary","title":"parse_unary","text":"<ul> <li>Parameters:<ul> <li>None (The [parse_unary]{.title-ref} function does not take any     explicit parameters.)</li> </ul> </li> <li>Description:<ul> <li>The [parse_unary]{.title-ref} function is responsible for     parsing unary expressions in a mathematical expression.</li> <li>Unary expressions involve a single operand (e.g.,     [-x]{.title-ref}, [+y]{.title-ref}), where the unary operator     ([+]{.title-ref} or [-]{.title-ref}) is applied to the operand.</li> <li>If the current token corresponds to a unary operator     ([PLUS]{.title-ref} or [MINUS]{.title-ref}), the function     processes it and recursively parses the operand.</li> <li>Otherwise, it falls back to parsing the primary expression     (e.g., literals, identifiers, function calls).</li> </ul> </li> <li>Returns:<ul> <li>A [UnaryOpNode]{.title-ref} representing the unary operation,     including any nested unary expressions.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_primary","title":"parse_primary","text":"<ul> <li>Parameters:<ul> <li>None</li> </ul> </li> <li>Description:<ul> <li>Handles the parsing of primary expressions in a mathematical     expression.</li> <li>Primary expressions include literals (e.g., integers, floats,     vectors), identifiers (variable names), function calls, and     parenthesized expressions (nested expressions within     parentheses).</li> <li>Examines the current token and determines the appropriate action     based on the token type.</li> </ul> </li> <li>Returns:<ul> <li>The parsed expression (a [VariableNode]{.title-ref}, numeric     value, function call, or parenthesized expression).</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_vector_constructor","title":"parse_vector_constructor","text":"<ul> <li>Parameters:<ul> <li>`type_name`: The type of the vector being constructed (e.g.,     \"int\", \"float\", \"fvector\").</li> </ul> </li> <li>Description:<ul> <li>The [parse_vector_constructor]{.title-ref} function handles the     parsing of vector constructors.</li> <li>Vector constructors are used to create vectors by specifying     their components within parentheses (e.g., [(1, 2,     3)]{.title-ref}).</li> <li>The function iterates through the tokens until it encounters the     closing parenthesis ([RPAREN]{.title-ref}).</li> <li>It parses each expression (component) separated by commas and     collects them in the [args]{.title-ref} list.</li> <li>Finally, it constructs a [VectorConstructorNode]{.title-ref}     with the specified type and the collected arguments.</li> </ul> </li> <li>Returns:<ul> <li>A [VectorConstructorNode]{.title-ref} representing the     constructed vector.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function_call_or_identifier","title":"parse_function_call_or_identifier","text":"<ul> <li>Parameters:<ul> <li>None (The [parse_function_call_or_identifier]{.title-ref}     function does not take any explicit parameters.)</li> </ul> </li> <li>Description:<ul> <li>The [parse_function_call_or_identifier]{.title-ref} function     handles the parsing of either a function call or an identifier     (variable name).</li> <li>It examines the current token:<ul> <li>If the token corresponds to an [IDENTIFIER]{.title-ref}, it     extracts the name and advances to the next token.</li> <li>If the next token is an [LPAREN]{.title-ref}, it indicates a     function call, and the function parses the arguments using     [self.parse_function_call(name)]{.title-ref}.</li> <li>If the next token is a [DOT]{.title-ref}, it indicates     member access (e.g., accessing a method or property of an     object) and parses it using     [self.parse_member_access(name)]{.title-ref}.</li> <li>Otherwise, it constructs a [VariableNode]{.title-ref} with     an empty type and the extracted name.</li> </ul> </li> </ul> </li> <li>Returns:<ul> <li>Either a function call node, a member access node, or a variable     node, depending on the context.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function_call","title":"parse_function_call","text":"<ul> <li>Parameters:<ul> <li>`name`: The name of the function being called.</li> </ul> </li> <li>Description:<ul> <li>The [parse_function_call]{.title-ref} function handles the     parsing of function calls in an expression.</li> <li>It starts by consuming the opening parenthesis token     ([LPAREN]{.title-ref}).</li> <li>While the current token is not the closing parenthesis token     ([RPAREN]{.title-ref}), it continues to parse expressions     (arguments) separated by commas.</li> <li>Each argument is obtained by calling     [self.parse_expression()]{.title-ref}.</li> <li>If a comma follows an argument, it consumes the comma token.</li> <li>Finally, it consumes the closing parenthesis token and     constructs a [FunctionCallNode]{.title-ref} with the specified     function name and arguments.</li> </ul> </li> <li>Returns:<ul> <li>A [FunctionCallNode]{.title-ref} representing the function call.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_member_access","title":"parse_member_access","text":"<ul> <li>Parameters:<ul> <li>`object`: The object (variable or expression) on which the     member access is performed.</li> </ul> </li> <li>Description:<ul> <li>The [parse_member_access]{.title-ref} function handles the     parsing of member access in an expression.</li> <li>It starts by consuming the dot token ([DOT]{.title-ref}).</li> <li>If the next token is not an [IDENTIFIER]{.title-ref}, it raises     a [SyntaxError]{.title-ref}.</li> <li>Otherwise, it extracts the member name and advances to the next     token.</li> <li>If there's another dot after this member access, it recursively     calls itself with the updated [MemberAccessNode]{.title-ref}.</li> <li>Otherwise, it constructs a [MemberAccessNode]{.title-ref} with     the specified object and member.</li> </ul> </li> <li>Returns:<ul> <li>A [MemberAccessNode]{.title-ref} representing the member access.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#directx-codegen","title":"DirectX Codegen","text":"<p>The HLSLCodeGen class within the CrossGL framework is pivotal in translating CrossGL shader abstract syntax trees (AST) into CrossGL code, which is essential for DirectX applications. This class systematically converts the AST (representing the logical structure of a shader)---&gt;into corresponding CrossGL code that can be executed.</p> <p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#generate","title":"generate","text":"<ul> <li>Description:<ul> <li>Generates shader code from the given Abstract Syntax Tree (AST).</li> <li>Handles the creation of both vertex and fragment shaders,     including custom functions and shader-specific I/O declarations.</li> </ul> </li> <li>Steps:<ol> <li>Process Structs:<ul> <li>Calls [process_structs]{.title-ref} to handle any structures     defined in the AST.</li> </ul> </li> <li>Initialize Shader Code:<ul> <li>Starts with the base shader declaration line: [shader main     {n]{.title-ref}.</li> </ul> </li> <li>Generate Custom Functions:<ul> <li>Iterates through the functions in the AST, excluding the     main vertex and fragment functions ([VSMain]{.title-ref} and     [PSMain]{.title-ref}).</li> <li>Appends the generated code for each custom function.</li> </ul> </li> <li>Generate Vertex Shader:<ul> <li>Adds a section comment for the vertex shader.</li> <li>Includes vertex shader I/O declarations by calling     [generate_io_declarations]{.title-ref} with     [\\\"vertex\\\"]{.title-ref}.</li> <li>Adds the main function for the vertex shader using     [generate_vertex_main]{.title-ref}, fetching the function     named [VSMain]{.title-ref}.</li> </ul> </li> <li>Generate Fragment Shader:<ul> <li>Adds a section comment for the fragment shader.</li> <li>Includes fragment shader I/O declarations by calling     [generate_io_declarations]{.title-ref} with     [\\\"fragment\\\"]{.title-ref}.</li> <li>Adds the main function for the fragment shader using     [generate_fragment_main]{.title-ref}, fetching the function     named [PSMain]{.title-ref}.</li> </ul> </li> <li>Finalize Shader Code:<ul> <li>Closes the shader block with [}n]{.title-ref}.</li> </ul> </li> </ol> </li> <li>Returns:<ul> <li>The complete shader code as a string.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#process_structs","title":"process_structs","text":"<ul> <li>Description:<ul> <li>Processes structure definitions from the Abstract Syntax Tree     (AST) and populates lists of vertex and fragment shader inputs     and outputs based on the members of the provided structures.</li> </ul> </li> <li>Parameters:<ul> <li>[ast]{.title-ref} ([ShaderNode]{.title-ref}): An instance of     [ShaderNode]{.title-ref} containing structure definitions and     functions for vertex and fragment shaders. This includes     optional vertex input ([vsinput_struct]{.title-ref}), vertex     output ([vsoutput_struct]{.title-ref}), fragment input     ([psinput_struct]{.title-ref}), and fragment output     ([psoutput_struct]{.title-ref}) structures.</li> </ul> </li> <li>Returns:<ul> <li>`None`: This method updates instance variables     ([self.vertex_inputs]{.title-ref},     [self.vertex_outputs]{.title-ref},     [self.fragment_inputs]{.title-ref}, and     [self.fragment_outputs]{.title-ref}) directly based on the     structure members in the provided [ast]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_io_declarations","title":"generate_io_declarations","text":"<ul> <li>Description:<ul> <li>Generates shader I/O declarations based on the specified shader     type (vertex or fragment). It creates declarations for input and     output variables in the shader code.</li> </ul> </li> <li>Parameters:<ul> <li>[shader_type]{.title-ref} ([str]{.title-ref}): Specifies the     type of shader for which to generate I/O declarations. It can be     [\\\"vertex\\\"]{.title-ref} or [\\\"fragment\\\"]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted I/O declarations for     the specified shader type. The string includes     [input]{.title-ref} and [output]{.title-ref} statements with     appropriate types and names, formatted according to the shader's     requirements. The string is stripped of any trailing whitespace.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_function","title":"generate_function","text":"<ul> <li>Description:<ul> <li>Generates the code for a function based on the provided     [FunctionNode]{.title-ref}. This includes defining the     function's return type, name, parameters, and body.</li> </ul> </li> <li>Parameters:<ul> <li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function     node containing the details of the function to be generated. It     includes the return type, function name, parameters, and body.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the     function. This includes the function signature and body,     properly indented and formatted.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_vertex_main","title":"generate_vertex_main","text":"<ul> <li>Description:<ul> <li>Generates the main function for the vertex shader, which is     typically the entry point of the shader. It formats and includes     the function body with appropriate indentation.</li> </ul> </li> <li>Parameters:<ul> <li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function     node representing the vertex shader's main function. It contains     the body of the function that will be used to generate the     shader code.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the vertex     shader's [main]{.title-ref} function, including proper     indentation and the function body.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_fragment_main","title":"generate_fragment_main","text":"<ul> <li>Description:<ul> <li>Generates the main function for the fragment shader, which is     typically the entry point of the shader. It formats and includes     the function body with appropriate indentation.</li> </ul> </li> <li>Parameters:<ul> <li>[func]{.title-ref} ([FunctionNode]{.title-ref}): The function     node representing the fragment shader's main function. It     contains the body of the function that will be used to generate     the shader code.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the fragment     shader's [main]{.title-ref} function, including proper     indentation and the function body.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_function_body","title":"generate_function_body","text":"<ul> <li>Description:<ul> <li>Generates the code for the body of a function by iterating     through statements. It formats each statement based on its type     and includes the appropriate indentation.</li> </ul> </li> <li>Parameters:<ul> <li>[body]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of     statements in the function body, where each statement is an     instance of [ASTNode]{.title-ref} or its derived classes.</li> <li>[indent]{.title-ref} ([int]{.title-ref}): The level of     indentation to apply to each line of code. Default is     [0]{.title-ref}.</li> <li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating     whether the function being generated is the [main]{.title-ref}     function. Default is [False]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the function     body, including the appropriate indentation and formatted     statements.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_for_loop","title":"generate_for_loop","text":"<ul> <li>Description:<ul> <li>Generates code for a [for]{.title-ref} loop based on the     provided [ForNode]{.title-ref}. This includes formatting the     initialization, condition, and update expressions, and properly     indenting the loop body.</li> </ul> </li> <li>Parameters:<ul> <li>[node]{.title-ref} ([ForNode]{.title-ref}): An instance of     [ForNode]{.title-ref} representing the [for]{.title-ref} loop,     containing [init]{.title-ref}, [condition]{.title-ref},     [update]{.title-ref}, and [body]{.title-ref}.</li> <li>[indent]{.title-ref} ([int]{.title-ref}): The level of     indentation to apply to each line of the loop code. It controls     how deep the code will be indented. Default is [0]{.title-ref}.</li> <li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating     whether the loop is inside the [main]{.title-ref} function.     Default is [False]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the     [for]{.title-ref} loop, including the initialization, condition,     update, and the body of the loop with proper indentation.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_if_statement","title":"generate_if_statement","text":"<ul> <li>Description:<ul> <li>Generates code for an [if]{.title-ref} statement, including     handling [else]{.title-ref} and [else if]{.title-ref} branches.     The code is properly indented according to the provided level.</li> </ul> </li> <li>Parameters:<ul> <li>[node]{.title-ref} ([IfNode]{.title-ref}): An instance of     [IfNode]{.title-ref} representing the [if]{.title-ref}     statement, including the condition, [if_body]{.title-ref}, and     [else_body]{.title-ref}.</li> <li>[indent]{.title-ref} ([int]{.title-ref}): The level of     indentation to apply to each line of the [if]{.title-ref}     statement code. Default is [0]{.title-ref}.</li> <li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating     whether the [if]{.title-ref} statement is inside the     [main]{.title-ref} function. Default is [False]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the     [if]{.title-ref} statement, including the condition, body, and     optional [else]{.title-ref} or [else if]{.title-ref} blocks with     proper indentation.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_assignment","title":"generate_assignment","text":"<ul> <li>Description:<ul> <li>Generates code for an assignment operation. Special handling is     included for assignments where the left-hand side is a member of     [output]{.title-ref} when in the [main]{.title-ref} function.</li> </ul> </li> <li>Parameters:<ul> <li>[node]{.title-ref} ([AssignmentNode]{.title-ref}): An instance     of [AssignmentNode]{.title-ref} representing the assignment     operation, including the left-hand side     ([node.left]{.title-ref}) and right-hand side     ([node.right]{.title-ref}) expressions.</li> <li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating     whether the code is being generated inside the     [main]{.title-ref} function. Default is [False]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the     assignment. Special handling for output variables if     [is_main]{.title-ref} is [True]{.title-ref}, translating     [position]{.title-ref} to [gl_Position]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_expression","title":"generate_expression","text":"<ul> <li>Description:<ul> <li>Generates code for various types of expressions. Handles     different node types such as variables, binary operations,     assignments, unary operations, function calls, member accesses,     ternary operations, and vector constructors.</li> </ul> </li> <li>Parameters:<ul> <li>[expr]{.title-ref} ([ExpressionNode]{.title-ref}): The     expression to generate code for, which can be a node of various     types (e.g., [VariableNode]{.title-ref},     [BinaryOpNode]{.title-ref}, etc.).</li> <li>[is_main]{.title-ref} ([bool]{.title-ref}): A flag indicating     whether the code is being generated inside the     [main]{.title-ref} function. Default is [False]{.title-ref}.</li> </ul> </li> <li>Returns:<ul> <li>`str`: A string containing the formatted code for the     expression, appropriately handling different node types.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#map_type","title":"map_type","text":"<ul> <li>Description:<ul> <li>Maps an HLSL type to its corresponding type in the shader     language used by the generator. Utilizes a dictionary     ([type_map]{.title-ref}) for type conversion.</li> </ul> </li> <li>Parameters:<ul> <li>[hlsl_type]{.title-ref} ([str]{.title-ref}): The HLSL type     string that needs to be mapped.</li> </ul> </li> <li>Returns:<ul> <li>`str`: The mapped type string based on the     [type_map]{.title-ref} dictionary. If the type is not found in     the dictionary, it returns the original [hlsl_type]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#metal","title":"Metal","text":""},{"location":"pages/graphica/api_reference/#metal-ast","title":"Metal AST","text":""},{"location":"pages/graphica/api_reference/#ternaryopnode_1","title":"TernaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a ternary conditional operation in the abstract     syntax tree (AST). It contains a condition, a true expression,     and a false expression.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The condition     to be evaluated.</li> <li>[true_expr]{.title-ref} ([ASTNode]{.title-ref}): The expression     to be evaluated and returned if the condition is true.</li> <li>[false_expr]{.title-ref} ([ASTNode]{.title-ref}): The expression     to be evaluated and returned if the condition is false.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [TernaryOpNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node with its condition, true expression, and false     expression.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#shadernode_1","title":"ShaderNode","text":"<ul> <li>Description:<ul> <li>Represents a shader node in the abstract syntax tree (AST) for a     shader. This node contains the functions defined in the shader.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[functions]{.title-ref} ([List[FunctionNode]]{.title-ref}): A     list of [FunctionNode]{.title-ref} instances representing the     functions defined in the shader.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ShaderNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node with its functions.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#structnode","title":"StructNode","text":"<ul> <li>Description:<ul> <li>Represents a struct definition in the abstract syntax tree (AST)     for a shader. This node contains the name of the struct and its     member variables.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[name]{.title-ref} ([str]{.title-ref}): The name of the struct.</li> <li>[members]{.title-ref} ([List[VariableNode]]{.title-ref}): A     list of [VariableNode]{.title-ref} instances representing the     members of the struct.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [StructNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node with its name and members.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#functionnode_1","title":"FunctionNode","text":"<ul> <li>Description:<ul> <li>Represents a function definition in the abstract syntax tree     (AST). This node includes details about the function's     qualifier, return type, name, parameters, body, and any     associated attributes.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[qualifier]{.title-ref} ([str]{.title-ref}): The qualifier of     the function (e.g., [public]{.title-ref},     [private]{.title-ref}).</li> <li>[return_type]{.title-ref} ([str]{.title-ref}): The return type     of the function.</li> <li>[name]{.title-ref} ([str]{.title-ref}): The name of the     function.</li> <li>[params]{.title-ref} ([List[VariableNode]]{.title-ref}): A     list of [VariableNode]{.title-ref} instances representing the     function's parameters.</li> <li>[body]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of     [ASTNode]{.title-ref} instances representing the body of the     function.</li> <li>[attributes]{.title-ref} ([List[str]]{.title-ref}, optional):     A list of string attributes associated with the function.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [FunctionNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its qualifier, return type, name,     parameters, body, and attributes.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#arrayaccessnode","title":"ArrayAccessNode","text":"<ul> <li>Description:<ul> <li>Represents an array access operation in the abstract syntax tree     (AST). This node contains details about the array being accessed     and the index used to access an element within the array.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[array]{.title-ref} ([ASTNode]{.title-ref}): The array being     accessed.</li> <li>[index]{.title-ref} ([ASTNode]{.title-ref}): The index used to     access an element in the array.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ArrayAccessNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its array and index.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#variablenode_1","title":"VariableNode","text":"<ul> <li>Description:<ul> <li>Represents a variable declaration in the abstract syntax tree     (AST). This node contains information about the variable's type,     its name, and any additional attributes associated with the     variable.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[vtype]{.title-ref} ([str]{.title-ref}): The type of the     variable (e.g., [int]{.title-ref}, [float]{.title-ref},     [vec3]{.title-ref}).</li> <li>[name]{.title-ref} ([str]{.title-ref}): The name of the     variable.</li> <li>[attributes]{.title-ref} ([list]{.title-ref}, optional):     Additional attributes or qualifiers associated with the     variable. Defaults to an empty list if not provided.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [VariableNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its type, name, and attributes.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#attributenode","title":"AttributeNode","text":"<ul> <li>Description:<ul> <li>Represents an attribute or decoration associated with a     function, variable, or other elements in the abstract syntax     tree (AST). This node includes the name of the attribute and any     associated arguments.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[name]{.title-ref} ([str]{.title-ref}): The name of the     attribute (e.g., [location]{.title-ref}, [binding]{.title-ref}).</li> <li>[args]{.title-ref} ([list]{.title-ref}, optional): A list of     arguments or parameters associated with the attribute. Defaults     to an empty list if not provided.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [AttributeNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its name and arguments.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#assignmentnode_1","title":"AssignmentNode","text":"<ul> <li>Description:<ul> <li>Represents an assignment operation in the abstract syntax tree     (AST). This node holds the left-hand side (LHS) variable or     expression, the right-hand side (RHS) value or expression, and     the operator used for assignment.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[left]{.title-ref} ([ASTNode]{.title-ref}): The variable or     expression on the left side of the assignment.</li> <li>[right]{.title-ref} ([ASTNode]{.title-ref}): The value or     expression to be assigned to the left side.</li> <li>[operator]{.title-ref} ([str]{.title-ref}, optional): The     assignment operator (e.g., [=]{.title-ref}, [+=]{.title-ref},     [-=]{.title-ref}, etc.). Defaults to [\\\"=\\\"]{.title-ref}.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [AssignmentNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its left side, operator, and right side.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#ifnode_1","title":"IfNode","text":"<ul> <li>Description:<ul> <li>Represents an [if]{.title-ref} statement in the abstract syntax     tree (AST). This node encapsulates the condition of the     [if]{.title-ref} statement and its associated [if]{.title-ref}     and [else]{.title-ref} bodies.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The condition     expression that determines whether the [if]{.title-ref} body or     [else]{.title-ref} body should be executed.</li> <li>[if_body]{.title-ref} ([list]{.title-ref} of     [ASTNode]{.title-ref}): The statements to be executed if the     condition evaluates to [True]{.title-ref}.</li> <li>[else_body]{.title-ref} ([list]{.title-ref} of     [ASTNode]{.title-ref}, optional): The statements to be executed     if the condition evaluates to [False]{.title-ref}. Defaults to     [None]{.title-ref}.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [IfNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its condition, [if]{.title-ref} body,     and [else]{.title-ref} body.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#fornode_1","title":"ForNode","text":"<ul> <li>Description:<ul> <li>Represents a [for]{.title-ref} loop in the abstract syntax tree     (AST). This node captures the initialization, loop condition,     update expression, and the body of the loop.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[init]{.title-ref} ([ASTNode]{.title-ref}): The initialization     statement for the [for]{.title-ref} loop, such as setting up a     loop variable.</li> <li>[condition]{.title-ref} ([ASTNode]{.title-ref}): The loop     condition that determines whether the loop should continue     running.</li> <li>[update]{.title-ref} ([ASTNode]{.title-ref}): The update     expression to be evaluated at the end of each loop iteration,     such as incrementing a loop variable.</li> <li>[body]{.title-ref} ([list]{.title-ref} of     [ASTNode]{.title-ref}): The statements to be executed on each     iteration of the loop.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ForNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including its initialization, condition, update,     and body.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#returnnode_1","title":"ReturnNode","text":"<ul> <li>Description:<ul> <li>Represents a [return]{.title-ref} statement in the abstract     syntax tree (AST). This node captures the value that is to be     returned from a function.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[value]{.title-ref} ([ASTNode]{.title-ref}): The expression or     value to be returned by the function.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ReturnNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the value being returned.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#functioncallnode_1","title":"FunctionCallNode","text":"<ul> <li>Description:<ul> <li>Represents a function call in the abstract syntax tree (AST).     This node contains information about the function being called     and the arguments passed to it.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[name]{.title-ref} ([str]{.title-ref}): The name of the function     being called.</li> <li>[args]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of     arguments passed to the function call. Each argument is an     [ASTNode]{.title-ref}.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [FunctionCallNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the function name and its arguments.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#binaryopnode_1","title":"BinaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a binary operation in the abstract syntax tree (AST).     This node is used for operations involving two operands and an     operator, such as addition, subtraction, multiplication, etc.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[left]{.title-ref} ([ASTNode]{.title-ref}): The left operand of     the binary operation.</li> <li>[op]{.title-ref} ([str]{.title-ref}): The operator used in the     operation (e.g., [+]{.title-ref}, [-]{.title-ref},     [*]{.title-ref}, [/]{.title-ref}).</li> <li>[right]{.title-ref} ([ASTNode]{.title-ref}): The right operand     of the binary operation.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [BinaryOpNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the left operand, operator, and right     operand.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#memberaccessnode_1","title":"MemberAccessNode","text":"<ul> <li>Description:<ul> <li>Represents access to a member of an object in the abstract     syntax tree (AST). This node is used to refer to a property or     method of an object.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[object]{.title-ref} ([ASTNode]{.title-ref}): The object or     variable whose member is being accessed.</li> <li>[member]{.title-ref} ([str]{.title-ref}): The name of the member     being accessed (e.g., a property or method).</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [MemberAccessNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the object and the member being     accessed.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#vectorconstructornode_1","title":"VectorConstructorNode","text":"<ul> <li>Description:<ul> <li>Represents a vector constructor in the abstract syntax tree     (AST). This node is used to construct vector types by specifying     the type and the components of the vector.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[type_name]{.title-ref} ([str]{.title-ref}): The name of the     vector type being constructed (e.g., [vec3]{.title-ref},     [vec4]{.title-ref}).</li> <li>[args]{.title-ref} ([List[ASTNode]]{.title-ref}): A list of     expressions representing the components of the vector.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [VectorConstructorNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the vector type and its components.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#unaryopnode_1","title":"UnaryOpNode","text":"<ul> <li>Description:<ul> <li>Represents a unary operation in the abstract syntax tree (AST).     This node is used to model operations that apply to a single     operand, such as negation or increment.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[op]{.title-ref} ([str]{.title-ref}): The operator for the unary     operation (e.g., [+]{.title-ref}, [-]{.title-ref},     [++]{.title-ref}, [--]{.title-ref}).</li> <li>[operand]{.title-ref} ([ASTNode]{.title-ref}): The operand on     which the unary operation is applied.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [UnaryOpNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the unary operator and its operand.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#texturesamplenode","title":"TextureSampleNode","text":"<ul> <li>Description:<ul> <li>Represents a texture sampling operation in the abstract syntax     tree (AST). This node is used to model operations where a     texture is sampled using specified coordinates and a sampler.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>[texture]{.title-ref} ([str]{.title-ref}): The name or reference     to the texture being sampled.</li> <li>[sampler]{.title-ref} ([str]{.title-ref}): The name or reference     to the sampler used for sampling the texture.</li> <li>[coordinates]{.title-ref} ([ASTNode]{.title-ref}): The     coordinates used to sample the texture, typically represented as     a vector.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [TextureSampleNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string representation of     the node, including the texture, sampler, and coordinates     used for sampling.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#threadgroupsyncnode","title":"ThreadgroupSyncNode","text":"<ul> <li>Description:<ul> <li>Represents a synchronization point for thread groups in the     abstract syntax tree (AST). This node is used to synchronize the     execution of threads within a thread group.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>No parameters are needed for this class.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ThreadgroupSyncNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A string indicating that     the node is a synchronization point for thread groups.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#constantbuffernode","title":"ConstantBufferNode","text":"<ul> <li>Description:<ul> <li>Represents a constant buffer in the abstract syntax tree (AST).     Constant buffers are used to group and manage constants that are     passed to shaders.</li> </ul> </li> <li>Constructor Parameters:<ul> <li>`name` ([str]{.title-ref}): The name of the constant     buffer.</li> <li>`members` ([list]{.title-ref} of     [VariableNode]{.title-ref}): A list of members (variables)     within the constant buffer.</li> </ul> </li> <li>Methods:<ul> <li>__repr__:<ul> <li>Description: Returns a string representation of the     [ConstantBufferNode]{.title-ref} instance.</li> <li>Returns: [str]{.title-ref} - A formatted string that     includes the name and members of the constant buffer.</li> </ul> </li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#metal-lexer","title":"Metal Lexer","text":"<p>[TOKENS]{.title-ref} and [KEYWORDS]{.title-ref} definitions provide a comprehensive set of token patterns for parsing a shader language, potentially for HLSL, GLSL, or a similar language. Here's a brief overview of what each part does:</p>"},{"location":"pages/graphica/api_reference/#tokens-list","title":"TOKENS List","text":"<p>The [TOKENS]{.title-ref} list defines regex patterns for different types of tokens. Each token has a name and a regex pattern to match it.</p> <ul> <li>Comment Tokens:<ul> <li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with     [//]{.title-ref}.</li> <li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed in     [/*]{.title-ref} and [*/]{.title-ref}.</li> </ul> </li> <li>Shader and Language Constructs:<ul> <li><code>STRUCT</code>, <code>CONSTANT</code>, <code>TEXTURE2D</code>, <code>SAMPLER</code>: Keywords for     specific constructs or types.</li> <li><code>VECTOR</code>, <code>FLOAT</code>, <code>HALF</code>, <code>INT</code>, <code>UINT</code>, <code>BOOL</code>, <code>VOID</code>: Data     types.</li> <li><code>QUESTION</code>, <code>IF</code>, <code>ELSE</code>, <code>FOR</code>, <code>RETURN</code>: Common control flow     and function keywords.</li> <li><code>VERTEX</code>, <code>FRAGMENT</code>: Shader stages.</li> <li><code>USING</code>, <code>NAMESPACE</code>, <code>METAL</code>, <code>DEVICE</code>, <code>THREADGROUP</code>,     <code>THREAD</code>: Specific to certain shading languages or extensions.</li> </ul> </li> <li>Syntax Elements:<ul> <li><code>IDENTIFIER</code>: Matches variable and function names.</li> <li><code>NUMBER</code>: Matches numeric literals.</li> <li><code>STRING</code>: Matches string literals.</li> <li><code>LBRACE</code>, <code>RBRACE</code>, <code>LPAREN</code>, <code>RPAREN</code>, <code>LBRACKET</code>, <code>RBRACKET</code>,     <code>SEMICOLON</code>, <code>COMMA</code>, <code>COLON</code>: Various syntax symbols.</li> <li><code>LESS_EQUAL</code>, <code>GREATER_EQUAL</code>, <code>LESS_THAN</code>, <code>GREATER_THAN</code>,     <code>EQUAL</code>, <code>NOT_EQUAL</code>: Comparison operators.</li> <li><code>PLUS_EQUALS</code>, <code>MINUS_EQUALS</code>, <code>MULTIPLY_EQUALS</code>,     <code>DIVIDE_EQUALS</code>: Compound assignment operators.</li> <li><code>PLUS</code>, <code>MINU`S`,</code>MULTIPLY<code>,</code>DIVIDE``: Arithmetic     operators.</li> <li><code>AND</code>, <code>OR</code>: Logical operators.</li> <li><code>DOT</code>: Member access operator.</li> <li><code>EQUALS</code>: Assignment operator.</li> <li><code>WHITESPACE</code>`: Matches spaces, tabs, and newlines.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#keywords-dictionary_1","title":"KEYWORDS Dictionary","text":"<p>The [KEYWORDS]{.title-ref} dictionary maps specific keywords to their corresponding token types. This helps in recognizing and categorizing keywords during parsing.</p> <ul> <li>Shader and Language Keywords:<ul> <li>Maps shader and language-specific keywords to their token type     names defined in [TOKENS]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#methods_6","title":"Methods","text":"<p>::: {#init__self-1}</p> <p>:::</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#tokenizeself","title":"tokenize(self)","text":"<p>| Description: | Tokenizes the input code into a sequence of tokens by matching against   predefined patterns.</p> <p>| Parameters: | - None</p> <p>| Returns: | - None</p> <p>| Raises: | - `SyntaxError`: If an illegal character is encountered in the input   code.</p>"},{"location":"pages/graphica/api_reference/#metal-parser","title":"Metal Parser","text":""},{"location":"pages/graphica/api_reference/#methods-1","title":"Methods","text":"<p>::: {#init__self-2}</p> <p>:::</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#eat_1","title":"eat","text":"<ul> <li>Description:<ul> <li>Consumes the current token if it matches the expected type.</li> <li>Advances to the next token and skips any comments following the     current token.</li> </ul> </li> <li>Parameters:<ul> <li>`token_type`: The type of token expected to be consumed.</li> </ul> </li> <li>Returns: None</li> <li>Raises:<ul> <li>`SyntaxError`: If the current token does not match the     expected token type.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#skip_commentsself","title":"skip_comments(self)","text":"<p>| Description: | Skips over single-line and multi-line comments in the token stream by   advancing past them.</p> <p>| Parameters: None</p> <p>| Returns: None</p> <p>| Raises: None</p>"},{"location":"pages/graphica/api_reference/#parseself","title":"parse(self)","text":"<p>| Description: | Initiates the parsing process by calling parse_shader to generate the   Abstract Syntax Tree (AST) for the shader code. Ensures that the   entire input has been consumed by checking for the end of file   ([EOF]{.title-ref}).</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The root node of the parsed Abstract Syntax Tree         (AST) representing the shader.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there is any remaining unparsed input after         the shader has been parsed.</p>"},{"location":"pages/graphica/api_reference/#parse_shaderself","title":"parse_shader(self)","text":"<p>| Description: | Parses the shader code by sequentially identifying and processing   various components such as preprocessor directives,   [using]{.title-ref} statements, structs, constant buffers, and   functions. The method iterates through the tokens until it reaches the   end of the file ([EOF]{.title-ref}), constructing a list of functions   and other shader components.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ShaderNode`: A node representing the parsed shader,         containing all the functions and components.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the shader contains unrecognized tokens that         cannot be skipped or parsed.</p>"},{"location":"pages/graphica/api_reference/#parse_preprocessor_directiveself","title":"parse_preprocessor_directive(self)","text":"<p>| Description: | Parses a preprocessor directive from the shader code. It handles   directives that include a string or are enclosed within angle brackets   ([\\&lt; &gt;]{.title-ref}). The method consumes tokens associated with the   directive until it reaches the end of the directive.</p> <p>| Parameters: None</p> <p>| Returns: None</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the preprocessor directive is not properly         closed with a [GREATER_THAN]{.title-ref} token.</p>"},{"location":"pages/graphica/api_reference/#parse_using_statementself","title":"parse_using_statement(self)","text":"<p>| Description: | Parses a [using]{.title-ref} statement specifically for the [namespace   metal;]{.title-ref} declaration in the shader code. This method   consumes the relevant tokens for [using]{.title-ref},   [namespace]{.title-ref}, [metal]{.title-ref}, and the terminating   semicolon ([;]{.title-ref}).</p> <p>| Parameters: None</p> <p>| Returns: None</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If any of the expected tokens         ([USING]{.title-ref}, [NAMESPACE]{.title-ref},         [METAL]{.title-ref}, or [SEMICOLON]{.title-ref}) are not found         in sequence.</p>"},{"location":"pages/graphica/api_reference/#parse_structself","title":"parse_struct(self)","text":"<p>| Description: | Parses a [struct]{.title-ref} declaration in the shader code. This   method reads the structure's name, its member variables, and any   associated attributes.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `StructNode`: A node representing the structure, including its         name and members.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If any of the expected tokens         ([STRUCT]{.title-ref}, [IDENTIFIER]{.title-ref},         [LBRACE]{.title-ref}, [RBRACE]{.title-ref},         [SEMICOLON]{.title-ref}) are not found in sequence.</p>"},{"location":"pages/graphica/api_reference/#parse_constant_bufferself","title":"parse_constant_buffer(self)","text":"<p>| Description: | Parses a [constant]{.title-ref} buffer declaration in the shader code.   This method reads the buffer's name and its member variables.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ConstantBufferNode`: A node representing the constant buffer,         including its name and members.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If any of the expected tokens         ([CONSTANT]{.title-ref}, [IDENTIFIER]{.title-ref},         [LBRACE]{.title-ref}, [RBRACE]{.title-ref},         [SEMICOLON]{.title-ref}) are not found in sequence.</p>"},{"location":"pages/graphica/api_reference/#parse_functionself","title":"parse_function(self)","text":"<p>| Description: | Parses a function declaration in the shader code, including function   qualifiers, return type, parameters, and body. Handles function   attributes before and after the parameters.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `FunctionNode`: A node representing the function, including         its qualifier, return type, name, parameters, body, and         attributes.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If any of the expected tokens         ([VERTEX]{.title-ref}, [FRAGMENT]{.title-ref},         [KERNEL]{.title-ref}, [IDENTIFIER]{.title-ref},         [LPAREN]{.title-ref}, [RPAREN]{.title-ref},         [LBRACE]{.title-ref}, [RBRACE]{.title-ref}, etc.) are not found         in sequence.</p>"},{"location":"pages/graphica/api_reference/#parse_parametersself","title":"parse_parameters(self)","text":"<p>| Description: | Parses the parameter list for a function, including handling   attributes, types, optional template parameters, and names. It   continues parsing until it encounters a closing parenthesis.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `List[VariableNode][: A list of `VariableNode]{.title-ref}         instances representing each parameter with its type, name, and         attributes.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: - If an unexpected token is encountered in the         parameter list. - If a token that is neither a comma nor a         closing parenthesis is found when expected.</p>"},{"location":"pages/graphica/api_reference/#parse_attributesself","title":"parse_attributes(self)","text":"<p>| Description: | Parses a sequence of attributes from the token stream. Attributes are   enclosed in [[[ ]]]{.title-ref}, and this method extracts the   attribute name and its arguments.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `List[AttributeNode][: A list of `AttributeNode]{.title-ref}         instances representing the parsed attributes, including their         names and arguments.</p> <p>| Raises: [None]{.title-ref}</p>"},{"location":"pages/graphica/api_reference/#parse_blockself","title":"parse_block(self)","text":"<p>| Description: | Parses a block of statements enclosed in curly braces   [{}]{.title-ref}. This method collects statements within the block   until it encounters the closing brace [}]{.title-ref}.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `List[ASTNode][: A list of statements parsed from the block,         where each statement is represented as an         `ASTNode]{.title-ref}.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the closing brace [RBRACE]{.title-ref} is         not found, indicating a mismatch or incomplete block.</p>"},{"location":"pages/graphica/api_reference/#parse_statementself","title":"parse_statement(self)","text":"<p>| Description: | Parses a statement based on the current token type. This method   determines the type of statement and delegates the parsing to the   appropriate handler method, such as variable declarations, conditional   statements, loops, or expressions.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed statement represented as an         [ASTNode]{.title-ref}. The specific type of         [ASTNode]{.title-ref} depends on the statement type, such as         [VariableDeclarationNode]{.title-ref}, [IfNode]{.title-ref},         [ForNode]{.title-ref}, [ReturnNode]{.title-ref}, or         [ExpressionStatementNode]{.title-ref}.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the current token does not match any known         statement types or if there is an issue parsing the statement.</p>"},{"location":"pages/graphica/api_reference/#parse_variable_declaration_or_assignmentself","title":"parse_variable_declaration_or_assignment(self)","text":"<p>| Description: | Parses a variable declaration or assignment statement. This method   handles different cases including variable declarations with or   without initialization, assignments, and compound assignments. It also   deals with member accesses and operations.</p> <p>| Parameters: | - None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed statement represented as an         [ASTNode]{.title-ref}.This could be a         [VariableNode]{.title-ref}, [AssignmentNode]{.title-ref},         [BinaryOpNode]{.title-ref}, or a general expression node,         depending on the syntax of the statement.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the variable declaration or         assignment does not match the expected format, or if there are         issues parsing the expression.</p>"},{"location":"pages/graphica/api_reference/#parse_if_statementself","title":"parse_if_statement(self)","text":"<p>| Description: | Parses an [if]{.title-ref} statement. This method handles the syntax   of an [if]{.title-ref} statement including the condition and both the   [if]{.title-ref} and optional [else]{.title-ref} blocks.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `IfNode`: An AST node representing the [if]{.title-ref}         statement.     -   This node contains:         -   The [condition]{.title-ref} as an expression.         -   The [if_body]{.title-ref} as a block of statements executed             if the condition is true.         -   The [else_body]{.title-ref} as a block of statements             executed if the condition is false (or [None]{.title-ref} if             there is no [else]{.title-ref} block).</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the [if]{.title-ref} statement         is incorrect or if there are issues parsing the expression or         blocks</p>"},{"location":"pages/graphica/api_reference/#parse_for_statementself","title":"parse_for_statement(self)","text":"<p>| Description: | Parses a [for]{.title-ref} loop statement. This method handles the   initialization, condition, and update expressions of the   [for]{.title-ref} loop, as well as the body of the loop.</p> <p>Parameters: None</p> <p>Returns:</p> <p>:   -   `ForNode`: An AST node representing the [for]{.title-ref} loop         statement.     -   This node contains:         -   `init`: The initialization expression or statement (e.g.,             variable declaration and assignment).         -   `condition`: The condition expression that controls the             loop's continuation.         -   `update`: The update expression executed after each             iteration of the loop.         -   `body`: The block of statements executed in each iteration             of the loop.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there are issues with the syntax of the         [for]{.title-ref} statement or problems parsing the expressions         or block.</p>"},{"location":"pages/graphica/api_reference/#parse_return_statementself","title":"parse_return_statement(self)","text":"<p>| Description: | Parses a [return]{.title-ref} statement. This method retrieves the   expression that is returned from a function and ensures proper syntax   with a terminating semicolon.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ReturnNode`: An AST node representing the         [return]{.title-ref} statement.This node contains: - `value`:         The expression to be returned by the function.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there are issues with the syntax of the         [return]{.title-ref} statement or problems parsing the         expression.</p>"},{"location":"pages/graphica/api_reference/#parse_expression_statementself","title":"parse_expression_statement(self)","text":"<p>| Description: | Parses an expression statement. This method handles any general   expressions followed by a semicolon, treating them as statements.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed expression, which can be any type of         expression node (e.g., [BinaryOpNode]{.title-ref},         [FunctionCallNode]{.title-ref}, etc.).</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there are issues with the syntax of the         expression or if the semicolon is missing.</p>"},{"location":"pages/graphica/api_reference/#parse_expressionself","title":"parse_expression(self)","text":"<p>| Description: | Parses an expression by delegating to the   [parse_assignment]{.title-ref} method. This method serves as the entry   point for parsing expressions, handling the overall expression parsing   process.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed assignment expression or any other         expression node resulting from the         [parse_assignment]{.title-ref} method.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there are issues with the syntax of the         assignment or any sub-expressions.</p>"},{"location":"pages/graphica/api_reference/#parse_assignmentself","title":"parse_assignment(self)","text":"<p>| Description: | Parses an assignment expression. This method first parses the   left-hand side of the assignment using   [parse_logical_or()]{.title-ref}. It then checks for assignment   operators ([EQUALS]{.title-ref}, [PLUS_EQUALS]{.title-ref},   [MINUS_EQUALS]{.title-ref}, [MULTIPLY_EQUALS]{.title-ref},   [DIVIDE_EQUALS]{.title-ref}) and parses the right-hand side   expression. Additionally, it handles ternary conditional expressions   if a [QUESTION]{.title-ref} token is encountered.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed assignment expression, which could be an         [AssignmentNode]{.title-ref} or a [TernaryOpNode]{.title-ref}         depending on the presence of conditional operators.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If there are issues with the syntax of the         assignment or ternary expressions.</p>"},{"location":"pages/graphica/api_reference/#parse_logical_orself","title":"parse_logical_or(self)","text":"<p>| Description: | Parses a logical OR expression. This method first parses the left-hand   side of the expression using [parse_logical_and()]{.title-ref}. It   then processes any subsequent logical OR operators, parsing the   right-hand side of each OR operation and combining the results into a   [BinaryOpNode]{.title-ref} representing the logical OR operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed logical OR expression, which is         represented as a [BinaryOpNode]{.title-ref} if there are         multiple OR operations, or a single expression if there is no OR         operation.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the logical OR expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_logical_andself","title":"parse_logical_and(self)","text":"<p>| Description: | Parses a logical AND expression. This method first parses the   left-hand side of the expression using [parse_equality()]{.title-ref}.   It then processes any subsequent logical AND operators, parsing the   right-hand side of each AND operation and combining the results into a   [BinaryOpNode]{.title-ref} representing the logical AND operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed logical AND expression, which is         represented as a [BinaryOpNode]{.title-ref} if there are         multiple AND operations, or a single expression if there is no         AND operation.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the logical AND expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_equalityself","title":"parse_equality(self)","text":"<p>| Description: | Parses an equality expression. This method starts by parsing the   left-hand side of the expression using   [parse_relational()]{.title-ref}. It then processes any subsequent   equality or inequality operators ([==]{.title-ref} or   [!=]{.title-ref}), parsing the right-hand side of each operation and   combining the results into a [BinaryOpNode]{.title-ref} representing   the equality or inequality operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed equality expression, represented as a         [BinaryOpNode]{.title-ref} if there are multiple equality         operations, or a single expression if there are no equality         operations.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the equality expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_relationalself","title":"parse_relational(self)","text":"<p>| Description: | Parses a relational expression. This method begins by parsing the   left-hand side of the relational expression using   [parse_additive()]{.title-ref}. It then processes any relational   operators ([\\&lt;]{.title-ref}, [&gt;]{.title-ref}, [\\&lt;=]{.title-ref},   [&gt;=]{.title-ref}), parsing the right-hand side of each operation and   combining the results into a [BinaryOpNode]{.title-ref} representing   the relational operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed relational expression, represented as a         [BinaryOpNode]{.title-ref} if there are multiple relational         operations, or a single expression if there are no relational         operations.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the relational expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_additiveself","title":"parse_additive(self)","text":"<p>| Description: | Parses an additive expression. This method starts by parsing the   left-hand side of the expression using   [parse_multiplicative()]{.title-ref}. It then processes any additive   operators ([+]{.title-ref}, [-]{.title-ref}), parsing the right-hand   side of each operation and combining the results into a   [BinaryOpNode]{.title-ref} representing the additive operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed additive expression, represented as a         [BinaryOpNode]{.title-ref} if there are multiple additive         operations, or a single expression if there are no additive         operations.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the additive expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_multiplicativeself","title":"parse_multiplicative(self)","text":"<p>| Description: | Parses a multiplicative expression. This method starts by parsing the   left-hand side of the expression using [parse_unary()]{.title-ref}. It   then processes any multiplicative operators ([*]{.title-ref},   [/]{.title-ref}), parsing the right-hand side of each operation and   combining the results into a [BinaryOpNode]{.title-ref} representing   the multiplicative operation.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed multiplicative expression, represented         as a [BinaryOpNode]{.title-ref} if there are multiple         multiplicative operations, or a single expression if there are         no multiplicative operations.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the multiplicative expression         is invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_unaryself","title":"parse_unary(self)","text":"<p>| Description: | Parses a unary expression. This method handles unary operators such as   [+]{.title-ref} and [-]{.title-ref}, applying these operators to the   result of a recursive call to [parse_unary()]{.title-ref}. If no unary   operator is present, it delegates to [parse_primary()]{.title-ref} to   handle the primary expression.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed unary expression, represented as a         [UnaryOpNode]{.title-ref} if a unary operator is present, or a         primary expression if no unary operator is found.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If the syntax of the unary expression is         invalid.</p>"},{"location":"pages/graphica/api_reference/#parse_primaryself","title":"parse_primary(self)","text":"<p>| Description: | Parses a primary expression, which includes literals, variables,   function calls, or expressions inside parentheses.</p> <p>| Parameters: None</p> <p>Returns:</p> <p>:   -   `ASTNode`: The parsed primary expression, such as a         [VariableNode]{.title-ref}, a constructor call, a literal value,         or an expression inside parentheses.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If an unexpected token is encountered in the         expression.</p>"},{"location":"pages/graphica/api_reference/#parse_vector_constructorself-type_name","title":"parse_vector_constructor(self, type_name)","text":"<p>| Description: | Parses a vector constructor expression. This includes the opening   parenthesis, a list of expressions separated by commas, and the   closing parenthesis.</p> <p>Parameters:</p> <p>:   -   [type_name]{.title-ref} (str): The type of the vector being         constructed (e.g., [vec2]{.title-ref}, [vec3]{.title-ref},         [vec4]{.title-ref}).</p> <p>Returns:</p> <p>:   -   `VectorConstructorNode`: A node representing the vector         constructor, which includes the vector type and its arguments.</p> <p>Raises:</p> <p>:   -   `SyntaxError`: If an unexpected token is encountered (though         this specific case is not directly handled in this method).</p>"},{"location":"pages/graphica/api_reference/#parse_function_call_or_identifierself","title":"parse_function_call_or_identifier(self)","text":"<p>| Description: | Parses either a function call or a member access based on the current   token. If the token indicates a function call, it processes that;   otherwise, it handles member access or just returns a variable node.</p> <p>Returns:</p> <ul> <li>Function Call: If [LPAREN]{.title-ref} is the next token after     the identifier.<ul> <li>`FunctionCallNode`: Represents a function call with its name     and arguments.</li> </ul> </li> <li>Member Access: If [DOT]{.title-ref} follows the identifier.<ul> <li>`MemberAccessNode`: Represents accessing a member of a     variable.</li> </ul> </li> <li>Variable Node: If no additional tokens are present.<ul> <li>`VariableNode`: Represents a simple variable.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function_callself-name","title":"parse_function_call(self, name)","text":"<p>| Description: | Parses a function call with the given function name and its arguments.   The arguments are collected until the closing parenthesis is   encountered.</p> <p>Returns:</p> <p>:   -   `FunctionCallNode`: Represents a function call with its name         and arguments.</p>"},{"location":"pages/graphica/api_reference/#parse_member_accessself-object","title":"parse_member_access(self, object)","text":"<p>| Description: | Parses member access expressions. It handles cases where members are   accessed with dot notation, including nested member accesses.</p> <p>Returns:</p> <p>:   -   `MemberAccessNode`: Represents the member access expression         with the object and the member. If there are nested member         accesses, the function will recursively parse them.</p>"},{"location":"pages/graphica/api_reference/#parse_texture_sampleself","title":"parse_texture_sample(self)","text":"<p>| Purpose: | Parses a texture sampling operation, which typically involves calling   a [sample]{.title-ref} method on a texture with specified parameters.</p> <p>Return: - Returns a [TextureSampleNode]{.title-ref} with the texture, sampler, and coordinates.</p>"},{"location":"pages/graphica/api_reference/#metal-codegen_1","title":"Metal Codegen","text":"<p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#generateself-ast","title":"generate(self, ast)","text":"<p>| Description: | Generates shader code from the abstract syntax tree (AST). This method   processes the structs, custom functions, vertex shader, and fragment   shader sections to produce the final shader code.</p> <p>Parameters:</p> <p>:   -   [ast]{.title-ref} (AST): The abstract syntax tree representing         the shader code, including functions and other relevant         structures.</p> <p>Returns:</p> <p>:   -   `str`: The generated shader code as a string, including vertex         and fragment shader sections.</p> <p>Raises:</p> <p>:   -   `ValueError`: If no vertex or fragment functions are found in         the AST when generating shader sections.</p>"},{"location":"pages/graphica/api_reference/#process_structsself-ast","title":"process_structs(self, ast)","text":"<p>| Description: | Processes struct definitions in the abstract syntax tree (AST) to   categorize and map vertex and fragment input/output variables. This   method updates the lists of vertex and fragment inputs and outputs   based on the struct definitions.</p> <p>Parameters:</p> <p>:   -   [ast]{.title-ref} (AST): The abstract syntax tree representing         the shader code, including function and struct definitions.</p> <p>Returns: [None]{.title-ref}</p> <p>Raises:</p> <p>:   -   `KeyError`: If a struct with an unexpected name is encountered         (though this specific case is not directly handled in this         method).</p>"},{"location":"pages/graphica/api_reference/#generate_io_declarationsself-shader_type","title":"generate_io_declarations(self, shader_type)","text":"<p>| Description: | Generates input and output declarations for vertex or fragment shaders   based on the shader type. This method formats the declarations   according to the shader type and the lists of vertex and fragment   inputs and outputs.</p> <p>Parameters:</p> <p>:   -   [shader_type]{.title-ref} (str): The type of shader for which to         generate declarations ([\\\"vertex\\\"]{.title-ref} or         [\\\"fragment\\\"]{.title-ref}).</p> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted input and output         declarations for the specified shader type.</p> <p>Raises:</p> <p>:   -   `ValueError`: If an invalid [shader_type]{.title-ref} is         provided (though this specific case is not directly handled in         this method).</p>"},{"location":"pages/graphica/api_reference/#generate_functionself-func","title":"generate_function(self, func)","text":"<p>| Description: | Generates the code for a function, including its signature and body.   It formats the function declaration and populates it with the   function's parameters and return type.</p> <p>Parameters:</p> <p>:   -   [func]{.title-ref} (FunctionNode): The function node         representing the function to generate code for, including its         return type, name, parameters, and body.</p> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted function declaration         and body.</p> <p>Raises:</p> <p>:   -   `TypeError`: If the [func]{.title-ref} parameter is not an         instance of [FunctionNode]{.title-ref} (though this specific         case is not directly handled in this method).</p>"},{"location":"pages/graphica/api_reference/#generate_main_functionself-func","title":"generate_main_function(self, func)","text":"<p>| Description: | Generates the [main]{.title-ref} function code, including its body. It   formats the [main]{.title-ref} function with appropriate indentation   and generates the function body.</p> <p>Parameters:</p> <p>:   -   [func]{.title-ref} (FunctionNode): The function node         representing the [main]{.title-ref} function to generate code         for, including its body.</p> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted [main]{.title-ref}         function with its body.</p> <p>Raises:</p> <p>:   -   `TypeError`: If the [func]{.title-ref} parameter is not an         instance of [FunctionNode]{.title-ref} (though this specific         case is not directly handled in this method).</p>"},{"location":"pages/graphica/api_reference/#generate_function_bodyself-body-indent0-is_mainfalse","title":"generate_function_body(self, body, indent=0, is_main=False)","text":"<p>| Description: | Generates the body of a function, including variable declarations,   assignments, return statements, and control flow statements. It   handles different types of statements and formats them with   appropriate indentation.</p> <p>Parameters:</p> <ul> <li>[body]{.title-ref} (list): A list of statements and expressions to     include in the function body.</li> <li>[indent]{.title-ref} (int, optional): The level of indentation for     formatting the code (default is 0).</li> <li>[is_main]{.title-ref} (bool, optional): A flag indicating if the     function is the [main]{.title-ref} function, affecting how certain     statements are handled (default is False).</li> </ul> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted code for the function         body.</p> <p>Raises:</p> <p>:   -   `TypeError`: If any item in the [body]{.title-ref} list is not         an instance of an expected node type (though this specific case         is not directly handled in this method).</p>"},{"location":"pages/graphica/api_reference/#generate_for_loopself-node-indent-is_main","title":"generate_for_loop(self, node, indent, is_main)","text":"<p>| Description: | Generates the code for a [for]{.title-ref} loop statement, including   its initialization, condition, update expression, and body. It handles   formatting and indentation for the loop structure.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (ForNode): The [ForNode]{.title-ref} instance     representing the [for]{.title-ref} loop, including initialization,     condition, update, and body.</li> <li>[indent]{.title-ref} (int): The level of indentation for formatting     the code.</li> <li>[is_main]{.title-ref} (bool): A flag indicating if the function is     the [main]{.title-ref} function, affecting how certain statements     are handled.</li> </ul> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted code for the         [for]{.title-ref} loop.</p> <p>Raises:</p> <p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of         [ForNode]{.title-ref}, though this specific case is not directly         handled in this method.</p>"},{"location":"pages/graphica/api_reference/#generate_if_statementself-node-indent-is_main","title":"generate_if_statement(self, node, indent, is_main)","text":"<p>| Description: | Generates the code for an [if]{.title-ref} statement, including the   condition, the [if]{.title-ref} body, and the optional   [else]{.title-ref} body. Handles formatting and indentation for the   [if]{.title-ref} structure.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (IfNode): The [IfNode]{.title-ref} instance     representing the [if]{.title-ref} statement, including its     condition, [if]{.title-ref} body, and optional [else]{.title-ref}     body.</li> <li>[indent]{.title-ref} (int): The level of indentation for formatting     the code.</li> <li>[is_main]{.title-ref} (bool): A flag indicating if the function is     the [main]{.title-ref} function, affecting how certain statements     are handled.</li> </ul> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted code for the         [if]{.title-ref} statement.</p> <p>Raises:</p> <p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of         [IfNode]{.title-ref}, though this specific case is not directly         handled in this method.</p>"},{"location":"pages/graphica/api_reference/#generate_assignmentself-node-is_main","title":"generate_assignment(self, node, is_main)","text":"<p>| Description: | Generates the code for an assignment statement, handling special cases   for assignments to output positions and general assignments. Formats   the assignment based on whether it is in the [main]{.title-ref}   function.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (AssignmentNode): The     [AssignmentNode]{.title-ref} instance representing the assignment,     including the left-hand side (LHS) and right-hand side (RHS)     expressions.</li> <li>[is_main]{.title-ref} (bool): A flag indicating if the function is     the [main]{.title-ref} function, which affects how certain     assignments are formatted.</li> </ul> <p>Returns:</p> <p>:   -   `str`: A string containing the formatted code for the         assignment statement.</p> <p>Raises:</p> <p>:   -   `TypeError`: If [node]{.title-ref} is not an instance of         [AssignmentNode]{.title-ref}, though this specific case is not         directly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#generate_expressionself-expr-is_mainfalse","title":"generate_expression(self, expr, is_main=False)","text":"<p>| Description: | Generates code for an expression, handling various types of AST nodes   including variables, assignments, binary operations, function calls,   member access, unary operations, ternary operations, and vector   constructors.</p> <p>Parameters:</p> <ul> <li>[expr]{.title-ref} (ASTNode): The AST node representing the     expression to be converted to code. This can be a     [VariableNode]{.title-ref}, [AssignmentNode]{.title-ref},     [BinaryOpNode]{.title-ref}, [FunctionCallNode]{.title-ref},     [MemberAccessNode]{.title-ref}, [UnaryOpNode]{.title-ref},     [TernaryOpNode]{.title-ref}, or [VectorConstructorNode]{.title-ref}.</li> <li>[is_main]{.title-ref} (bool, optional): A flag indicating if the     expression is within the [main]{.title-ref} function, affecting how     some expressions are formatted. Defaults to [False]{.title-ref}.</li> </ul> <p>Returns:</p> <p>:   -   `str`: A string containing the generated code for the         expression.</p> <p>Raises:</p> <p>:   -   `TypeError`: If [expr]{.title-ref} is not an instance of a         recognized AST node class or a string.</p>"},{"location":"pages/graphica/api_reference/#map_typeself-metal_type","title":"map_type(self, metal_type)","text":"<p>| Description: | Maps a type from the internal representation (e.g., Metal shading   language types) to the corresponding type in the target language.</p> <p>Parameters:</p> <p>:   -   [metal_type]{.title-ref} (str): The type in the internal         representation that needs to be mapped to the target language         type.</p> <p>Returns:</p> <p>:   -   `str`: The corresponding type in the target language based on         the [type_map]{.title-ref}. If [metal_type]{.title-ref} is not         found in [type_map]{.title-ref}, it returns the         [metal_type]{.title-ref} itself.</p> <p>Raises: [None]{.title-ref}</p>"},{"location":"pages/graphica/api_reference/#opengl","title":"OpenGL","text":""},{"location":"pages/graphica/api_reference/#opengl-ast","title":"OpenGL AST","text":""},{"location":"pages/graphica/api_reference/#uniformnode","title":"UniformNode","text":"<p>Represents a uniform variable in a shader program.</p> <ul> <li> <p>Description: This class represents a uniform variable used to     pass data from the application to the shader. It stores the type and     name of the uniform and provides methods to return its string     representation.</p> </li> <li> <p>Attributes:</p> <p>:   -   `vtype (str)[: The data type of the uniform variable (e.g.,         `float]{.title-ref}, [vec3]{.title-ref}).     -   `name (str)`: The name of the uniform variable.</p> </li> <li> <p>Returns:</p> <p>:   -   `UniformNode`: An object representing the uniform         variable, with methods to generate its shader code         representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [UniformNode]{.title-ref} instance, suitable for         debugging.     -   `__str__() -&gt; str`: Returns the uniform declaration         in the shader code as a string.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#constantnode","title":"ConstantNode","text":"<p>Represents a constant value used in shader code.</p> <ul> <li> <p>Description: This class encapsulates a constant value in shader     code, such as a number, boolean, or any fixed data type. It provides     methods to return its string representation.</p> </li> <li> <p>Attributes:</p> <p>:   -   `value (any)[: The constant value to be represented (e.g.,         `42]{.title-ref}, [3.14]{.title-ref}, [true]{.title-ref}).</p> </li> <li> <p>Returns:</p> <p>:   -   `ConstantNode`: An object representing the constant value,         with methods to generate its string representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [ConstantNode]{.title-ref} instance, suitable for         debugging.     -   `__str__() -&gt; str`: Returns the string representation         of the constant value.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#versiondirectivenode","title":"VersionDirectiveNode","text":"<p>Represents a GLSL version directive in shader code.</p> <ul> <li> <p>Description: This class encapsulates a GLSL version directive,     which specifies the GLSL version and profile being used in the     shader code.</p> </li> <li> <p>Attributes:</p> <p>:   -   `number (str)[: The version number of GLSL (e.g.,         `450]{.title-ref}).     -   `profile (str)[: The profile of GLSL (e.g.,         `core]{.title-ref}, [compatibility]{.title-ref}).</p> </li> <li> <p>Returns:</p> <p>:   -   `VersionDirectiveNode`: An object representing the GLSL         version directive, with methods to generate its string         representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [VersionDirectiveNode]{.title-ref} instance, suitable         for debugging.     -   `__str__() -&gt; str`: Returns the GLSL version         directive as a string.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#layoutnode","title":"LayoutNode","text":"<p>Represents a GLSL layout qualifier for shader variables.</p> <ul> <li> <p>Description: This class encapsulates a GLSL layout qualifier,     specifying the location and type of shader variables. It supports     variables in different sections of the shader code.</p> </li> <li> <p>Attributes:</p> <p>:   -   `location_number (int)[: The location number of the shader         variable (e.g., `0]{.title-ref}, [1]{.title-ref}).     -   `dtype (str)[: The data type of the shader variable (e.g.,         `vec4]{.title-ref}, [float]{.title-ref}).     -   `name (str)`: The name of the shader variable.</p> </li> <li> <p>Returns:</p> <p>:   -   `LayoutNode`: An object representing the GLSL layout         qualifier, with methods to generate its string         representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [LayoutNode]{.title-ref} instance, suitable for         debugging.     -   `__str__() -&gt; str`: Returns the GLSL layout qualifier         as a string.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#ternaryopnode_2","title":"TernaryOpNode","text":"<p>Represents a ternary conditional expression in shader code.</p> <ul> <li> <p>Description: This class encapsulates a ternary conditional     expression, which is used for conditional operations in shader code.     It stores the condition, true expression, and false expression.</p> </li> <li> <p>Attributes:</p> <p>:   -   `condition (ASTNode)[: The condition expression that         evaluates to either `true]{.title-ref} or         [false]{.title-ref}.     -   `true_expr (ASTNode)[: The expression to evaluate and         return if the condition is `true]{.title-ref}.     -   `false_expr (ASTNode)[: The expression to evaluate and         return if the condition is `false]{.title-ref}.</p> </li> <li> <p>Returns:</p> <p>:   -   `TernaryOpNode`: An object representing the ternary         operation, with methods to generate its string         representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [TernaryOpNode]{.title-ref} instance, including the         condition, true expression, and false expression.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#shadernode_2","title":"ShaderNode","text":"<p>Represents a shader program, encapsulating all its components.</p> <ul> <li> <p>Description: This class represents a complete shader program,     including the version, input and output variables, uniforms, and the     vertex and fragment shader sections.</p> </li> <li> <p>Attributes:</p> <p>:   -   [version (str)]{.title-ref}`: The version of the shader         language used.     -   `global_inputs (list of LayoutNode)`: A list of layout         nodes specifying global input variables.     -   `global_outputs (list of LayoutNode)`: A list of layout         nodes specifying global output variables.     -   `uniforms (list of UniformNode)`: A list of uniform         variables used in the shader.     -   `vertex_section (list of ASTNode)`: A list of AST nodes         representing the vertex shader section.     -   `fragment_section (list of ASTNode)`: A list of AST nodes         representing the fragment shader section.     -   `functions (list of FunctionNode)`: A list of function         nodes defined in the shader.</p> </li> <li> <p>Returns:</p> <p>:   -   `ShaderNode`: An object representing the entire shader         program, with methods to generate its string representation.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [ShaderNode]{.title-ref} instance, showing its         version, global inputs, global outputs, functions, vertex         section, and fragment section.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#vertexshadernode-class-1","title":"VERTEXShaderNode","text":"<p>Represents the vertex shader section of a shader program, including input and output variables, uniform variables, functions, and layout qualifiers.</p> <ul> <li> <p>Description: This class represents the vertex shader portion of     a shader program, encapsulating its inputs, outputs, uniforms, and     any associated functions or layout qualifiers.</p> </li> <li> <p>Attributes:</p> <p>:   -   `inputs (list of LayoutNode)`: A list of input variables         for the vertex shader.     -   `outputs (list of LayoutNode)`: A list of output variables         for the vertex shader.     -   `uniform (list of UniformNode)`: A list of uniform         variables used in the vertex shader.     -   `functions (list of FunctionNode)`: A list of functions         defined in the vertex shader.     -   `layout_qualifiers (list of LayoutNode, optional)`: A list         of layout qualifiers specifying additional layout         information.</p> </li> <li> <p>Returns:</p> <p>:   -   `VERTEXShaderNode`: An object representing the vertex         shader section, with attributes and methods to manipulate         its components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [VERTEXShaderNode]{.title-ref} instance, including         its inputs, outputs, uniform variables, functions, and         layout qualifiers.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#fragmentshadernode-class","title":"FRAGMENTShaderNode","text":"<p>Represents the fragment shader section of a shader program, including input and output variables, uniform variables, functions, and layout qualifiers.</p> <ul> <li> <p>Description: This class represents the fragment shader portion     of a shader program, encapsulating its inputs, outputs, uniforms,     and any associated functions or layout qualifiers.</p> </li> <li> <p>Attributes:</p> <p>:   -   `inputs (list of LayoutNode)`: A list of input variables         for the fragment shader.     -   `outputs (list of LayoutNode)`: A list of output variables         for the fragment shader.     -   `uniform (list of UniformNode)`: A list of uniform         variables used in the fragment shader.     -   `functions (list of FunctionNode)`: A list of functions         defined in the fragment shader.     -   `layout_qualifiers (list of LayoutNode, optional)`: A list         of layout qualifiers specifying additional layout         information.</p> </li> <li> <p>Returns:</p> <p>:   -   `FRAGMENTShaderNode`: An object representing the fragment         shader section, with attributes and methods to manipulate         its components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [FRAGMENTShaderNode]{.title-ref} instance, including         its inputs, outputs, uniform variables, functions, and         layout qualifiers.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#functionnode-class","title":"FunctionNode","text":"<p>Represents a function definition within a shader or programming language.</p> <ul> <li> <p>Description: This class encapsulates a function\\'s return type,     name, parameters, and body within a shader or programming language     context.</p> </li> <li> <p>Attributes:</p> <p>:   -   `return_type (str)[: The return type of the function (e.g.,         `void]{.title-ref}, [float]{.title-ref},         [vec4]{.title-ref}).     -   `name (str)`: The name of the function.     -   `params (list of VariableNode)[: A list of parameters for         the function, where each parameter is represented as a         `VariableNode]{.title-ref}.     -   `body (list of ASTNode)`: A list of statements or         expressions representing the function body.</p> </li> <li> <p>Returns:</p> <p>:   -   `FunctionNode`: An object representing the function, with         attributes and methods to manipulate its components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [FunctionNode]{.title-ref} instance, including its         return type, name, parameters, and body.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#variablenode-class","title":"VariableNode","text":"<p>Represents a variable within a shader or programming language.</p> <ul> <li> <p>Description: This class encapsulates the type of a variable and     its name within a shader or programming language context.</p> </li> <li> <p>Attributes:</p> <p>:   -   `vtype (str)[: The type of the variable (e.g.,         `int]{.title-ref}, [float]{.title-ref},         [vec3]{.title-ref}).     -   `name (str)`: The name of the variable.</p> </li> <li> <p>Returns:</p> <p>:   -   `VariableNode`: An object representing the variable, with         attributes and methods to manipulate its components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [VariableNode]{.title-ref} instance, including its         type and name.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#assignmentnode-class","title":"AssignmentNode","text":"<p>Represents an assignment operation within a shader or programming language.</p> <ul> <li> <p>Description: This class encapsulates an assignment operation,     including the variable name being assigned and the value assigned to     it.</p> </li> <li> <p>Attributes:</p> <p>:   -   `name (str)`: The name of the variable being assigned.     -   `value (any)`: The value assigned to the variable.</p> </li> <li> <p>Returns:</p> <p>:   -   `AssignmentNode`: An object representing the assignment         operation, with attributes and methods to manipulate its         components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [AssignmentNode]{.title-ref} instance, including the         variable name and the assigned value.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#ifnode-class","title":"IfNode","text":"<p>Represents an if-else conditional structure within a shader or programming language.</p> <ul> <li> <p>Description: This class encapsulates an if-else conditional     structure, including the condition, the body of the if statement,     optional else-if chains, and an optional else body.</p> </li> <li> <p>Attributes:</p> <p>:   -   `condition (ASTNode)`: The condition to evaluate.     -   `if_body (list of ASTNode)`: The body of the if statement.     -   `else_if_chain (list of tuple, optional)`: A list of         tuples, each containing a condition and a body for else-if         statements.     -   `else_body (list of ASTNode, optional)`: The body of the         else statement.</p> </li> <li> <p>Returns:</p> <p>:   -   `IfNode`: An object representing the if-else structure,         with attributes and methods to manipulate its components.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [IfNode]{.title-ref} instance, including its         condition, if body, else-if chain, and else body.</p> </li> <li> <p>Raises:</p> <p>:   -   `None`: This class does not raise exceptions.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#fornode-class-1","title":"ForNode Class","text":"<ul> <li> <p>Description: Represents a for-loop structure within a shader or     programming language. It includes the initialization, condition,     update, and the body of the loop.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [init]{.title-ref} (ASTNode): The initialization statement         of the for-loop.     -   [condition]{.title-ref} (ASTNode): The condition to evaluate         for each iteration.     -   [update]{.title-ref} (ASTNode): The update statement         executed after each iteration.     -   [body]{.title-ref} (list of ASTNode): The body of the         for-loop.</p> </li> <li> <p>Attributes:</p> <p>:   -   [init]{.title-ref} (ASTNode): The initialization statement.     -   [condition]{.title-ref} (ASTNode): The condition to         evaluate.     -   [update]{.title-ref} (ASTNode): The update statement.     -   [body]{.title-ref} (list of ASTNode): The body of the         for-loop.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [ForNode]{.title-ref} instance, including its         initialization, condition, update, and body.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#returnnode-class","title":"ReturnNode Class","text":"<ul> <li> <p>Description: Represents a return statement within a shader or     programming language. It includes the value to be returned.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [value]{.title-ref} (any): The value to be returned by the         return statement.</p> </li> <li> <p>Attributes:</p> <p>:   -   [value]{.title-ref} (any): The value to be returned.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [ReturnNode]{.title-ref} instance, including the         value to be returned.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#functioncallnode-class","title":"FunctionCallNode Class","text":"<ul> <li> <p>Description: Represents a function call within a shader or     programming language. It includes the function name and the     arguments passed to the function.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the function being         called.     -   [args]{.title-ref} (list of ASTNode): A list of arguments         passed to the function.</p> </li> <li> <p>Attributes:</p> <p>:   -   [name]{.title-ref} (str): The name of the function.     -   [args]{.title-ref} (list of ASTNode): The arguments passed         to the function.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [FunctionCallNode]{.title-ref} instance, including         the function name and arguments.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#binaryopnode-class","title":"BinaryOpNode Class","text":"<ul> <li> <p>Description: Represents a binary operation within a shader or     programming language. It includes the left operand, the operator,     and the right operand.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [left]{.title-ref} (ASTNode): The left operand of the binary         operation.     -   [op]{.title-ref} (str): The operator of the binary operation         (e.g., [+]{.title-ref}, [-]{.title-ref}, [*]{.title-ref},         [/]{.title-ref}).     -   [right]{.title-ref} (ASTNode): The right operand of the         binary operation.</p> </li> <li> <p>Attributes:</p> <p>:   -   [left]{.title-ref} (ASTNode): The left operand.     -   [op]{.title-ref} (str): The operator.     -   [right]{.title-ref} (ASTNode): The right operand.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [BinaryOpNode]{.title-ref} instance, including the         left operand, operator, and right operand.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#memberaccessnode-class","title":"MemberAccessNode Class","text":"<ul> <li> <p>Description: Represents member access within a shader or     programming language. It includes the object and the member being     accessed.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [object]{.title-ref} (ASTNode): The object whose member is         being accessed.     -   [member]{.title-ref} (str): The member being accessed.</p> </li> <li> <p>Attributes:</p> <p>:   -   [object]{.title-ref} (ASTNode): The object.     -   [member]{.title-ref} (str): The member being accessed.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [MemberAccessNode]{.title-ref} instance, including         the object and the member being accessed.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#unaryopnode-class","title":"UnaryOpNode Class","text":"<ul> <li> <p>Description: Represents a unary operation within a shader or     programming language. It includes the operator and the operand.</p> </li> <li> <p>Constructor Parameters:</p> <p>:   -   [op]{.title-ref} (str): The operator of the unary operation         (e.g., [-]{.title-ref}, [!]{.title-ref}, [\\~]{.title-ref}).     -   [operand]{.title-ref} (ASTNode): The operand of the unary         operation.</p> </li> <li> <p>Attributes:</p> <p>:   -   [op]{.title-ref} (str): The operator.     -   [operand]{.title-ref} (ASTNode): The operand.</p> </li> <li> <p>Methods:</p> <p>:   -   `__repr__() -&gt; str`: Returns a string representation         of the [UnaryOpNode]{.title-ref} instance, including the         operator and operand.     -   `__str__() -&gt; str`: Returns a string representation         of the unary operation in the format [(operator         operand)]{.title-ref}.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#opengl-lexer","title":"OpenGL Lexer","text":""},{"location":"pages/graphica/api_reference/#tokens-list_1","title":"TOKENS List","text":"<p>| Description: | Defines a list of tuples representing different types of tokens used   in a shader or programming language. Each tuple contains a token name   and its corresponding regular expression pattern.</p> <p>| Tokens:</p> <ul> <li><code>COMMENT_SINGLE</code>: Matches single-line comments starting with <code>//</code>.</li> <li><code>COMMENT_MULTI</code>: Matches multi-line comments enclosed by     <code>/* ... */</code>.</li> <li><code>ELSE_IF</code>: Matches <code>else if</code> statements.</li> <li><code>VERSION</code>: Matches version directives starting with <code>#version</code>.</li> <li><code>NUMBER</code>: Matches numeric literals (e.g., <code>123</code>, <code>123.45</code>).</li> <li><code>CORE</code>: Matches the keyword <code>core</code>.</li> <li><code>SHADER</code>: Matches the keyword <code>shader</code>.</li> <li><code>INPUT</code>: Matches the keyword <code>input</code>.</li> <li><code>OUTPUT</code>: Matches the keyword <code>output</code>.</li> <li><code>VOID</code>: Matches the keyword <code>void</code>.</li> <li><code>MAIN</code>: Matches the <code>main</code> function.</li> <li><code>UNIFORM</code>: Matches the keyword <code>uniform</code>.</li> <li><code>VECTOR</code>: Matches vector types (e.g., <code>vec2</code>, <code>vec3</code>, <code>vec4</code>).</li> <li><code>MATRIX</code>: Matches matrix types (e.g., <code>mat2</code>, <code>mat3</code>, <code>mat4</code>).</li> <li><code>BOOL</code>: Matches the keyword <code>bool</code>.</li> <li><code>FLOAT</code>: Matches the keyword <code>float</code>.</li> <li><code>INT</code>: Matches the keyword <code>int</code>.</li> <li><code>SAMPLER2D</code>: Matches the keyword <code>sampler2D</code>.</li> <li><code>PRE_INCREMENT</code>: Matches the pre-increment operator <code>++</code> when     followed by a word character.</li> <li><code>PRE_DECREMENT</code>: Matches the pre-decrement operator <code>--</code> when     followed by a word character.</li> <li><code>POST_INCREMENT</code>: Matches the post-increment operator <code>++</code> when     preceded by a word character.</li> <li><code>POST_DECREMENT</code>: Matches the post-decrement operator <code>--</code> when     preceded by a word character.</li> <li><code>IDENTIFIER</code>: Matches identifiers (e.g., variable names, function     names) using the pattern <code>[a-zA-Z_][a-zA-Z_0-9]*</code>.</li> <li><code>LBRACE</code>: Matches the left brace <code>{</code>.</li> <li><code>RBRACE</code>: Matches the right brace <code>}</code>.</li> <li><code>LPAREN</code>: Matches the left parenthesis <code>(</code>.</li> <li><code>RPAREN</code>: Matches the right parenthesis <code>)</code>.</li> <li><code>SEMICOLON</code>: Matches the semicolon <code>;</code>.</li> <li><code>COMMA</code>: Matches the comma <code>,</code>.</li> <li><code>ASSIGN_ADD</code>: Matches the addition assignment operator <code>+=</code>.</li> <li><code>ASSIGN_SUB</code>: Matches the subtraction assignment operator <code>-=</code>.</li> <li><code>ASSIGN_MUL</code>: Matches the multiplication assignment operator <code>*=</code>.</li> <li><code>ASSIGN_DIV</code>: Matches the division assignment operator <code>/=</code>.</li> <li><code>EQUAL</code>: Matches the equality operator <code>==</code>.</li> <li><code>NOT_EQUAL</code>: Matches the inequality operator <code>!=</code>.</li> <li><code>WHITESPACE</code>: Matches whitespace characters.</li> <li><code>IF</code>: Matches the keyword <code>if</code>.</li> <li><code>ELSE</code>: Matches the keyword <code>else</code>.</li> <li><code>FOR</code>: Matches the keyword <code>for</code>.</li> <li><code>RETURN</code>: Matches the keyword <code>return</code>.</li> <li><code>LESS_EQUAL</code>: Matches the less than or equal to operator <code>&lt;=</code>.</li> <li><code>GREATER_EQUAL</code>: Matches the greater than or equal to operator <code>&gt;=</code>.</li> <li><code>LESS_THAN</code>: Matches the less than operator <code>&lt;</code>.</li> <li><code>GREATER_THAN</code>: Matches the greater than operator <code>&gt;</code>.</li> <li><code>AND</code>: Matches the logical AND operator <code>&amp;&amp;</code>.</li> <li><code>OR</code>: Matches the logical OR operator <code>||</code>.</li> <li><code>NOT</code>: Matches the logical NOT operator <code>!</code>.</li> <li><code>PLUS</code>: Matches the addition operator <code>+</code>.</li> <li><code>MINUS</code>: Matches the subtraction operator <code>-</code>.</li> <li><code>MULTIPLY</code>: Matches the multiplication operator <code>*</code>.</li> <li><code>DIVIDE</code>: Matches the division operator <code>/</code>.</li> <li><code>DOT</code>: Matches the dot operator <code>.</code>.</li> <li><code>EQUALS</code>: Matches the assignment operator <code>=</code>.</li> <li><code>QUESTION</code>: Matches the ternary conditional operator <code>?</code>.</li> <li><code>COLON</code>: Matches the colon <code>:</code>.</li> <li><code>LAYOUT</code>: Matches the keyword <code>layout</code>.</li> <li><code>IN</code>: Matches the keyword <code>in</code>.</li> <li><code>OUT</code>: Matches the keyword <code>out</code>.</li> </ul>"},{"location":"pages/graphica/api_reference/#keywords-dictionary_2","title":"KEYWORDS Dictionary","text":"<p>| Description: | Defines a dictionary mapping specific keywords to their corresponding   token names.</p> <p>| Keywords:</p> <ul> <li><code>\"void\"</code>: <code>VOID</code></li> <li><code>\"main\"</code>: <code>MAIN</code></li> <li><code>\"vertex\"</code>: <code>VERTEX</code></li> <li><code>\"fragment\"</code>: <code>FRAGMENT</code></li> <li><code>\"else if\"</code>: <code>ELSE_IF</code></li> <li><code>\"if\"</code>: <code>IF</code></li> <li><code>\"else\"</code>: <code>ELSE</code></li> <li><code>\"for\"</code>: <code>FOR</code></li> <li><code>\"return\"</code>: <code>RETURN</code></li> <li><code>\"layout\"</code>: <code>LAYOUT</code></li> <li><code>\"in\"</code>: <code>IN</code></li> <li><code>\"out\"</code>: <code>OUT</code></li> </ul> <p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#tokenize-method","title":"Tokenize Method","text":"<p>| Description: | Tokenizes the input code by matching it against predefined token   patterns and appending the tokens to the [self.tokens]{.title-ref}   list. It handles identifiers, keywords, version directives, and   ignores whitespace. If an illegal character is encountered, it raises   a [SyntaxError]{.title-ref}.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code to be         tokenized.</p> <p>Attributes:</p> <p>:   -   [self.code]{.title-ref} (str): The code to be tokenized. -         [self.tokens]{.title-ref} (list of tuple): The list of tokens         generated from the code.</p> <p>| Method Details:</p> <ul> <li>tokenize(self):<ul> <li>Initializes the position [pos]{.title-ref} to 0.</li> <li>Iterates through the code, matching it against token patterns.</li> <li>Appends matched tokens to [self.tokens]{.title-ref}.</li> <li>Handles special cases for identifiers and keywords.</li> <li>Ignores whitespace tokens.</li> <li>Raises a [SyntaxError]{.title-ref} for illegal characters.</li> <li>Appends an [EOF]{.title-ref} token at the end.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#opengl-parser","title":"OpenGL Parser","text":"<p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#skip_comments-method","title":"skip_comments Method","text":"<p>Description:</p> <p>:   Skips over multi-line comments in the code by consuming tokens until     the end of the comment is reached.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`skip_comments(self)[: - Continues to consume tokens while the     current token type is ]{.title-ref}\\\"COMMENT_MULTI\\\"[. - Uses the     `eat]{.title-ref} method to consume the current token.</li> </ul>"},{"location":"pages/graphica/api_reference/#eat-method","title":"eat Method","text":"<p>Description:</p> <p>:   Consumes the current token if it matches the expected token type and     advances to the next token. If the token does not match, it raises a     [SyntaxError]{.title-ref}. It also skips comments after consuming a     token.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the tokens.     -   [token_type]{.title-ref} (str): The expected type of the current         token.</p> <p>Method Details:</p> <ul> <li> <p>`eat(self, token_type)[: - Checks if the current token type matches the expected `token_type]{.title-ref}.</p> <p>:   -   If it matches, increments the position [pos]{.title-ref} and         updates [current_token]{.title-ref} to the next token.     -   Calls [skip_comments()]{.title-ref} to skip any comments         after consuming a token.     -   If it does not match, raises a [SyntaxError]{.title-ref}         with a message indicating the expected and actual token         types.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse-method","title":"parse Method","text":"<p>Description:</p> <p>:   Parses the input code, handling comments, version directives, and     shader definitions. It returns the root node of the parsed shader.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li> <p>`parse(self)[: - Calls `skip_comments()]{.title-ref} to skip any comments at the beginning.</p> <p>:   -   Parses the version directive using         [parse_version_directive()]{.title-ref} and stores the         result in [version_node]{.title-ref}.     -   Parses the shader using         [parse_shader(version_node)]{.title-ref} and stores the         result in [shader_node]{.title-ref}.     -   Returns [shader_node]{.title-ref} as the root node of the         parsed shader.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_version_directive-method","title":"parse_version_directive Method","text":"<p>Description:</p> <p>:   Parses the version directive from the input tokens. It handles the     [VERSION]{.title-ref} token followed by a [NUMBER]{.title-ref} token     and optionally a [CORE]{.title-ref} token.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li> <p>`parse_version_directive(self)[: - Checks if the current token is `VERSION]{.title-ref}.</p> <p>:   -   If true, consumes the [VERSION]{.title-ref} token.     -   Checks if the next token is [NUMBER]{.title-ref}.     -   If true, stores the number and consumes the         [NUMBER]{.title-ref} token.     -   Optionally checks for a [CORE]{.title-ref} token and         consumes it if present.     -   Returns a [VersionDirectiveNode]{.title-ref} with the parsed         number and optional version identifier.     -   Raises a [SyntaxError]{.title-ref} if the expected tokens         are not found.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_layout-method","title":"parse_layout Method","text":"<p>Description:</p> <p>:   Parses the layout directive from the input tokens. It handles the     [LAYOUT]{.title-ref} token followed by a [location]{.title-ref}     identifier and its associated number, and then processes either an     [IN]{.title-ref} or [OUT]{.title-ref} token to determine the     input/output type.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.     -   `current_section`: The current section being parsed.</p> <p>Method Details:</p> <ul> <li> <p>`parse_layout(self, current_section)[: - Consumes the `LAYOUT]{.title-ref} and [LPAREN]{.title-ref} tokens.</p> <p>:   -   Checks for the [location]{.title-ref} identifier and         consumes the [IDENTIFIER]{.title-ref}, [EQUALS]{.title-ref},         and [NUMBER]{.title-ref} tokens.     -   Consumes the [RPAREN]{.title-ref} token and skips any         comments.     -   Checks for [IN]{.title-ref} or [OUT]{.title-ref} tokens to         determine the input/output type.     -   If [IN]{.title-ref}, consumes the [IN]{.title-ref} token,         parses the type, and consumes the [IDENTIFIER]{.title-ref}         and [SEMICOLON]{.title-ref} tokens.     -   If [OUT]{.title-ref}, consumes the [OUT]{.title-ref} token,         parses the type, and consumes the [IDENTIFIER]{.title-ref}         and [SEMICOLON]{.title-ref} tokens.     -   Returns a [LayoutNode]{.title-ref} with the parsed section,         location number, data type, name, and input/output type.     -   Raises a [SyntaxError]{.title-ref} if the expected tokens         are not found.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_shader-method","title":"parse_shader Method","text":"<p>Description:</p> <p>:   Parses the shader code, handling global inputs, outputs, uniforms,     and specific sections for vertex and fragment shaders.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.     -   `version_node`: The node representing the version directive.</p> <p>Method Details:</p> <ul> <li> <p>`parse_shader(self, version_node)[: - Initializes lists for global inputs, outputs, and uniforms. - Creates empty `VERTEXShaderNode]{.title-ref} and [FRAGMENTShaderNode]{.title-ref} instances.</p> <p>:   -   Sets [current_section]{.title-ref} to [None]{.title-ref}.</p> <pre><code>-\n\n    Iterates through tokens until [EOF]{.title-ref} is reached:\n\n    :   -   Handles single-line comments to determine the\n            current section ([VERTEX]{.title-ref} or\n            [FRAGMENT]{.title-ref}).\n        -   Parses layout directives and appends them to the\n            appropriate section.\n        -   Parses inputs and appends them to the appropriate\n            section or global list.\n        -   Parses outputs and appends them to the appropriate\n            section or global list.\n        -   Parses uniforms and appends them to the global list.\n        -   Parses version directives.\n        -   Parses functions and appends them to the appropriate\n            section.\n        -   Handles braces to parse shader sections and appends\n            content to the appropriate section.\n\n-   Raises [SyntaxError]{.title-ref} for unexpected tokens or\n    misplaced functions and braces.\n</code></pre> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_shader_section-method","title":"parse_shader_section Method","text":"<p>Description:</p> <p>:   Parses a section of the shader code, handling inputs, outputs,     uniforms, functions, and layout qualifiers within braces.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.     -   `current_section`: The current section being parsed.</p> <p>Method Details:</p> <ul> <li> <p>`parse_shader_section(self, current_section)[: - Initializes lists for inputs, outputs, uniforms, functions, and layout qualifiers. - Consumes the `LBRACE]{.title-ref} token.</p> <p>:   -   </p> <pre><code>    Iterates through tokens until [RBRACE]{.title-ref} or [EOF]{.title-ref} is reached:\n\n    :   -   Parses layout directives and appends them to\n            [layout_qualifiers]{.title-ref}.\n        -   Parses inputs and appends them to\n            [inputs]{.title-ref}.\n        -   Parses outputs and appends them to\n            [outputs]{.title-ref}.\n        -   Parses uniforms and appends them to\n            [uniforms]{.title-ref}.\n        -   Parses functions and appends them to\n            [functions]{.title-ref}.\n\n-   Returns a tuple of lists containing inputs, outputs,\n    uniforms, layout qualifiers, and functions when\n    [RBRACE]{.title-ref} is encountered.\n\n-   Raises a [SyntaxError]{.title-ref} for unexpected tokens or\n    end of input.\n</code></pre> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_inputs-method","title":"parse_inputs Method","text":"<p>Description:</p> <p>:   Parses the input variables from the tokens, handling the     [IN]{.title-ref} token followed by the variable type and name.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li> <p>`parse_inputs(self)[: - Initializes an empty list `inputs]{.title-ref}.</p> <p>:   -   </p> <pre><code>    Iterates through tokens while the current token is \\`IN\\`:\n\n    :   -   Consumes the [IN]{.title-ref} token.\n        -   Parses the variable type and stores it in\n            [vtype]{.title-ref}.\n        -   Stores the variable name from the current token.\n        -   Consumes the [IDENTIFIER]{.title-ref} and\n            [SEMICOLON]{.title-ref} tokens.\n        -   Appends a tuple [(vtype, name)]{.title-ref} to\n            [inputs]{.title-ref}.\n\n-   Returns the list [inputs]{.title-ref}.\n</code></pre> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_outputs-method","title":"parse_outputs Method","text":"<p>Description:</p> <p>:   Parses the output variables from the tokens, handling the     [OUT]{.title-ref} token followed by the variable type and name.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li> <p>`parse_outputs(self)[: - Initializes an empty list `outputs]{.title-ref}.</p> <p>:   -   </p> <pre><code>    Iterates through tokens while the current token is \\`OUT\\`:\n\n    :   -   Consumes the [OUT]{.title-ref} token.\n        -   Parses the variable type and stores it in\n            [vtype]{.title-ref}.\n        -   Stores the variable name from the current token.\n        -   Consumes the [IDENTIFIER]{.title-ref} and\n            [SEMICOLON]{.title-ref} tokens.\n        -   Appends a tuple [(vtype, name)]{.title-ref} to\n            [outputs]{.title-ref}.\n\n-   Returns the list [outputs]{.title-ref}.\n</code></pre> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_uniforms-method","title":"parse_uniforms Method","text":"<p>| Description: | Parses the uniform variables from the tokens, handling the   [UNIFORM]{.title-ref} token followed by the variable type and name.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_uniforms(self)`:<ul> <li>Initializes an empty list [uniforms]{.title-ref}.</li> <li>Iterates through tokens while the current token is `UNIFORM`:<ul> <li>Consumes the [UNIFORM]{.title-ref} token.</li> <li>Parses the variable type and stores it in     [vtype]{.title-ref}.</li> <li>Stores the variable name from the current token.</li> <li>Consumes the [IDENTIFIER]{.title-ref} and     [SEMICOLON]{.title-ref} tokens.</li> <li>Appends a [UniformNode]{.title-ref} with [vtype]{.title-ref}     and [name]{.title-ref} to [uniforms]{.title-ref}.</li> </ul> </li> <li>Returns the list [uniforms]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_variable-method","title":"parse_variable Method","text":"<p>| Description: | Parses a variable declaration or assignment from the tokens, handling   various forms of assignments and member access.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.     -   `type_name`: The type of the variable being parsed.</p> <p>| Method Details:</p> <ul> <li>`parse_variable(self, type_name)`:<ul> <li>Stores the variable name from the current token and consumes the     [IDENTIFIER]{.title-ref} token.</li> <li>Handles member access by consuming [DOT]{.title-ref} and     [IDENTIFIER]{.title-ref} tokens, appending to the variable name.</li> <li>If the next token is [SEMICOLON]{.title-ref}, consumes it and     returns a [VariableNode]{.title-ref}.</li> <li>If the next token is [EQUALS]{.title-ref}, consumes it, parses     the expression, and returns an [AssignmentNode]{.title-ref}.</li> <li>If the next token is a compound assignment operator     ([ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},     [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}), consumes     it, parses the expression, and returns a     [BinaryOpNode]{.title-ref}.</li> <li>Raises a [SyntaxError]{.title-ref} for unexpected tokens or     missing semicolons.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_assignment_or_function_call-method","title":"parse_assignment_or_function_call Method","text":"<p>| Description: | Parses an assignment or function call from the tokens, handling   various types of assignments, increments, decrements, and function   calls.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_assignment_or_function_call(self)`:<ul> <li>Initializes [type_name]{.title-ref} as an empty string.</li> <li>Checks if the current token is a type ([VECTOR]{.title-ref},     [FLOAT]{.title-ref}, [INT]{.title-ref}, [MATRIX]{.title-ref}):<ul> <li>If true, stores the type name and consumes the token.</li> </ul> </li> <li>If the current token is [IDENTIFIER]{.title-ref}, calls     [parse_variable]{.title-ref} with [type_name]{.title-ref}.<ul> <li>Stores the identifier name and consumes the     [IDENTIFIER]{.title-ref} token.</li> </ul> </li> <li>Checks for assignment operators ([EQUALS]{.title-ref},     [ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},     [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}):<ul> <li>If true, calls [parse_assignment]{.title-ref} with the name.</li> </ul> </li> <li>Checks for increment ([PRE_INCREMENT]{.title-ref},     [POST_INCREMENT]{.title-ref}) or decrement     ([PRE_DECREMENT]{.title-ref}, [POST_DECREMENT]{.title-ref})     operators:<ul> <li>If true, consumes the operator and returns an     [AssignmentNode]{.title-ref} with a     [UnaryOpNode]{.title-ref}.</li> </ul> </li> <li>Checks for a function call ([LPAREN]{.title-ref}):<ul> <li>If true, calls [parse_function_call]{.title-ref} with the     name.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} for unexpected tokens after     the identifier.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function-method","title":"parse_function Method","text":"<p>| Description: | Parses a function definition from the tokens, handling the return   type, function name, parameters, and body.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_function(self)`:<ul> <li>Parses the return type using [parse_type()]{.title-ref}.</li> <li>Checks if the current token is [MAIN]{.title-ref} or     `IDENTIFIER`:<ul> <li>If [MAIN]{.title-ref}, stores the function name and consumes     the [MAIN]{.title-ref} token.</li> <li>If [IDENTIFIER]{.title-ref}, stores the function name and     consumes the [IDENTIFIER]{.title-ref} token.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} if neither [MAIN]{.title-ref}     nor [IDENTIFIER]{.title-ref} is found.</li> <li>Consumes the [LPAREN]{.title-ref} token.</li> <li>Parses the parameters using [parse_parameters()]{.title-ref}.</li> <li>Consumes the [RPAREN]{.title-ref} token.</li> <li>Consumes the [LBRACE]{.title-ref} token.</li> <li>Parses the function body using [parse_body()]{.title-ref}.</li> <li>Consumes the [RBRACE]{.title-ref} token.</li> <li>Returns a [FunctionNode]{.title-ref} with the return type,     function name, parameters, and body.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_body-method","title":"parse_body Method","text":"<p>| Description: | Parses the body of a function, handling various statements such as   [if]{.title-ref}, [for]{.title-ref}, [return]{.title-ref}, and   assignments or function calls.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_body(self)`:<ul> <li>Initializes an empty list [body]{.title-ref}.</li> <li>Iterates through tokens until [RBRACE]{.title-ref} or     [EOF]{.title-ref} is encountered:<ul> <li>If the current token is [IF]{.title-ref}, parses an     [if]{.title-ref} statement and appends it to     [body]{.title-ref}.</li> <li>If the current token is [FOR]{.title-ref}, parses a     [for]{.title-ref} loop and appends it to [body]{.title-ref}.</li> <li>If the current token is [RETURN]{.title-ref}, parses a     [return]{.title-ref} statement and appends it to     [body]{.title-ref}.</li> <li>If the current token is a type or identifier     ([VECTOR]{.title-ref}, [IDENTIFIER]{.title-ref},     [FLOAT]{.title-ref}, [INT]{.title-ref}), parses an     assignment or function call and appends it to     [body]{.title-ref}.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} for unexpected tokens.</li> <li>Returns the list [body]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_parameters-method","title":"parse_parameters Method","text":"<p>| Description: | Parses the parameters of a function, handling multiple parameters   separated by commas.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_parameters(self)`:<ul> <li>Initializes an empty list [params]{.title-ref}.</li> <li>If the current token is not [RPAREN]{.title-ref}, parses the     first parameter and appends it to [params]{.title-ref}.</li> <li>Iterates through tokens while the current token is `COMMA`:<ul> <li>Consumes the [COMMA]{.title-ref} token.</li> <li>Parses the next parameter and appends it to     [params]{.title-ref}.</li> </ul> </li> <li>Returns the list [params]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_parameter-method","title":"parse_parameter Method","text":"<p>| Description: | Parses a single parameter, handling the parameter type and name.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_parameter(self)`:<ul> <li>Parses the parameter type using [parse_type()]{.title-ref}.</li> <li>Stores the parameter name from the current token.</li> <li>Consumes the [IDENTIFIER]{.title-ref} token.</li> <li>Returns a tuple [(param_type, param_name)]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_type-method","title":"parse_type Method","text":"<p>| Description: | Parses the type of a variable or function return type from the tokens.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_type(self)`:<ul> <li>Checks if the current token is `VOID`:<ul> <li>If true, consumes the [VOID]{.title-ref} token and returns     [\\\"void\\\"]{.title-ref}.</li> </ul> </li> <li>Checks if the current token is one of the predefined types     ([VECTOR]{.title-ref}, [FLOAT]{.title-ref}, [INT]{.title-ref},     [MATRIX]{.title-ref}, [BOOLEAN]{.title-ref},     [SAMPLER2D]{.title-ref}):<ul> <li>If true, stores the type name, consumes the token, and     returns the type name.</li> </ul> </li> <li>Checks if the current token is `IDENTIFIER`:<ul> <li>If true, stores the type name, consumes the     [IDENTIFIER]{.title-ref} token, and returns the type name.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} for unexpected type tokens.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_arguments-method","title":"parse_arguments Method","text":"<p>| Description: | Parses the arguments of a function call, handling multiple arguments   separated by commas.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_arguments(self)`:<ul> <li>Initializes an empty list [args]{.title-ref}.</li> <li>Iterates through tokens until [RPAREN]{.title-ref} is     encountered:<ul> <li>Parses an expression and appends it to [args]{.title-ref}.</li> <li>If the current token is [COMMA]{.title-ref}, consumes it.</li> </ul> </li> <li>Returns the list [args]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_update-method","title":"parse_update Method","text":"<p>| Description: | Parses an update statement, handling various forms of increments,   decrements, and assignments.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>| Method Details:</p> <ul> <li>`parse_update(self)`:<ul> <li>If the current token is `IDENTIFIER`:<ul> <li>Stores the identifier name and consumes the     [IDENTIFIER]{.title-ref} token.</li> <li>Checks for [POST_INCREMENT]{.title-ref} or     [POST_DECREMENT]{.title-ref} and returns a     [UnaryOpNode]{.title-ref}.</li> <li>Checks for assignment operators ([EQUALS]{.title-ref},     [ASSIGN_ADD]{.title-ref}, [ASSIGN_SUB]{.title-ref},     [ASSIGN_MUL]{.title-ref}, [ASSIGN_DIV]{.title-ref}):</li> <li>Consumes the operator, parses the expression, and returns an     [AssignmentNode]{.title-ref} or [BinaryOpNode]{.title-ref}.</li> </ul> </li> <li>If the current token is [PRE_INCREMENT]{.title-ref} or     `PRE_DECREMENT`:<ul> <li>Consumes the operator and the [IDENTIFIER]{.title-ref}     token, and returns a [UnaryOpNode]{.title-ref}.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} for unexpected tokens or     missing identifiers.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_assignment-method","title":"parse_assignment Method","text":"<p>| Description: | Parses an assignment statement, handling the variable name, assignment   operator, and expression.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_assignment(self)`:<ul> <li>Stores the variable name from the current token and consumes the     [IDENTIFIER]{.title-ref} token.</li> <li>Consumes the [EQUALS]{.title-ref} token.</li> <li>Parses the expression and stores it in [expr]{.title-ref}.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> <li>Returns an [AssignmentNode]{.title-ref} with the variable name     and expression.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function_call_or_identifier-method","title":"parse_function_call_or_identifier Method","text":"<p>| Description: | Parses a function call or an identifier, handling the function name   and its arguments or member access.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>Checks if the current token is `VECTOR`:<ul> <li>If true, stores the function name and consumes the     [VECTOR]{.title-ref} token.</li> <li>Otherwise, stores the function name and consumes the     [IDENTIFIER]{.title-ref} token.</li> </ul> </li> <li>If the next token is [LPAREN]{.title-ref}, calls     [parse_function_call]{.title-ref} with the function name.</li> <li>If the next token is [DOT]{.title-ref}, calls     [parse_member_access]{.title-ref} with the function name.</li> <li>Returns a [VariableNode]{.title-ref} with the function name if no     further tokens are found.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_additive-method","title":"parse_additive Method","text":"<p>| Description: | Parses an additive expression, handling addition and subtraction   operations.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_additive(self)`:<ul> <li>Parses the left-hand side of the expression using     [parse_multiplicative()]{.title-ref}.</li> <li>Iterates through tokens while the current token is     [PLUS]{.title-ref} or `MINUS`:<ul> <li>Stores the operator and consumes the token.</li> <li>Parses the right-hand side of the expression using     [parse_multiplicative()]{.title-ref}.</li> </ul> </li> <li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,     operator, and right-hand side.</li> <li>Returns the final [BinaryOpNode]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_primary-method","title":"parse_primary Method","text":"<p>| Description: | Parses a primary expression, handling various types of tokens such as   negation, identifiers, numbers, and parenthesized expressions.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_primary(self)`:<ul> <li>Checks if the current token is `MINUS`:<ul> <li>Consumes the [MINUS]{.title-ref} token.</li> <li>Recursively calls [parse_primary()]{.title-ref} to handle     the negation.</li> <li>Returns a [UnaryOpNode]{.title-ref} with the negation     operator and the parsed value.</li> </ul> </li> <li>Checks if the current token is an [IDENTIFIER]{.title-ref},     [VECTOR]{.title-ref}, or `FLOAT`:<ul> <li>Calls [parse_function_call_or_identifier()]{.title-ref} to     handle the token.</li> </ul> </li> <li>Checks if the current token is `NUMBER`:<ul> <li>Stores the token value.</li> <li>Consumes the [NUMBER]{.title-ref} token.</li> <li>Returns the stored value.</li> </ul> </li> <li>Checks if the current token is `LPAREN`:<ul> <li>Consumes the [LPAREN]{.title-ref} token.</li> <li>Calls [parse_expression()]{.title-ref} to parse the     expression inside the parentheses.</li> <li>Consumes the [RPAREN]{.title-ref} token.</li> <li>Returns the parsed expression.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} if the token is unexpected.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_multiplicative-method","title":"parse_multiplicative Method","text":"<p>| Description: | Parses a multiplicative expression, handling multiplication and   division operations.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_multiplicative(self)`:<ul> <li>Parses the left-hand side of the expression using     [parse_primary()]{.title-ref}.</li> <li>Iterates through tokens while the current token is     [MULTIPLY]{.title-ref} or `DIVIDE`:<ul> <li>Stores the operator and consumes the token.</li> <li>Parses the right-hand side of the expression using     [parse_primary()]{.title-ref}.</li> </ul> </li> <li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,     operator, and right-hand side.</li> <li>Returns the final [BinaryOpNode]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_expression-method","title":"parse_expression Method","text":"<p>| Description: | Parses a general expression, handling additive expressions, comparison   operators, logical operators, and ternary conditional expressions.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_expression(self)`:<ul> <li>Parses the left-hand side of the expression using     [parse_additive()]{.title-ref}.</li> <li>Iterates through tokens while the current token is a comparison     or logical operator ([LESS_THAN]{.title-ref},     [GREATER_THAN]{.title-ref}, [LESS_EQUAL]{.title-ref},     [GREATER_EQUAL]{.title-ref}, [EQUAL]{.title-ref},     [NOT_EQUAL]{.title-ref}, [AND]{.title-ref}, [OR]{.title-ref}):<ul> <li>Stores the operator and consumes the token.</li> <li>Parses the right-hand side of the expression using     [parse_additive()]{.title-ref}.</li> </ul> </li> <li>Creates a [BinaryOpNode]{.title-ref} with the left-hand side,     operator, and right-hand side.</li> <li>Checks if the current token is [QUESTION]{.title-ref} for a     ternary conditional expression:<ul> <li>Consumes the [QUESTION]{.title-ref} token.</li> <li>Parses the true expression using     [parse_expression()]{.title-ref}.</li> <li>Consumes the [COLON]{.title-ref} token.</li> <li>Parses the false expression using     [parse_expression()]{.title-ref}.</li> <li>Creates a [TernaryOpNode]{.title-ref} with the condition,     true expression, and false expression.</li> </ul> </li> <li>Returns the final expression node.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_return-method","title":"parse_return Method","text":"<p>| Description: | Parses a return statement, handling the return keyword and the   associated expression.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_return(self)`:<ul> <li>Consumes the [RETURN]{.title-ref} token.</li> <li>Parses the expression to be returned using     [parse_expression()]{.title-ref}.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> <li>Returns a [ReturnNode]{.title-ref} with the parsed expression.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_else_if_chain-method","title":"parse_else_if_chain Method","text":"<p>| Description: | Parses a chain of [else if]{.title-ref} and [else]{.title-ref}   statements, handling their conditions and bodies.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_else_if_chain(self)`:<ul> <li>Initializes an empty list [else_if_chain]{.title-ref} and sets     [else_body]{.title-ref} to [None]{.title-ref}.</li> <li>Iterates through tokens while the current token is     [ELSE_IF]{.title-ref} or `ELSE`:<ul> <li>If the current token is `ELSE_IF`:<ul> <li>Consumes the [ELSE_IF]{.title-ref} token.</li> <li>Consumes the [LPAREN]{.title-ref} token.</li> <li>Parses the [elif]{.title-ref} condition using     [parse_expression()]{.title-ref}.</li> <li>Consumes the [RPAREN]{.title-ref} token.</li> <li>Consumes the [LBRACE]{.title-ref} token.</li> <li>Parses the [elif]{.title-ref} body using     [parse_body()]{.title-ref}.</li> <li>Consumes the [RBRACE]{.title-ref} token.</li> <li>Appends the condition and body as a tuple to     [else_if_chain]{.title-ref}.</li> </ul> </li> <li>If the current token is `ELSE`:<ul> <li>Consumes the [ELSE]{.title-ref} token.</li> <li>Consumes the [LBRACE]{.title-ref} token.</li> <li>Parses the [else]{.title-ref} body using     [parse_body()]{.title-ref}.</li> <li>Consumes the [RBRACE]{.title-ref} token.</li> <li>Breaks the loop.</li> </ul> </li> </ul> </li> <li>Returns the [else_if_chain]{.title-ref} and     [else_body]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_if-method","title":"parse_if Method","text":"<p>| Description: | Parses an [if]{.title-ref} statement, handling the condition, body,   and any associated [else if]{.title-ref} and [else]{.title-ref}   statements.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_if(self)`:<ul> <li>Consumes the [IF]{.title-ref} token.</li> <li>Consumes the [LPAREN]{.title-ref} token.</li> <li>Parses the condition using [parse_expression()]{.title-ref}.</li> <li>Consumes the [RPAREN]{.title-ref} token.</li> <li>Consumes the [LBRACE]{.title-ref} token.</li> <li>Parses the body of the [if]{.title-ref} statement using     [parse_body()]{.title-ref}.</li> <li>Consumes the [RBRACE]{.title-ref} token.</li> <li>Parses any [else if]{.title-ref} and [else]{.title-ref}     statements using [parse_else_if_chain()]{.title-ref}.</li> <li>Returns an [IfNode]{.title-ref} with the condition, body, [else     if]{.title-ref} chain, and [else]{.title-ref} body.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_for-method","title":"parse_for Method","text":"<p>| Description: | Parses a [for]{.title-ref} loop, handling the initialization,   condition, update, and body of the loop.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_for(self)`:<ul> <li>Consumes the [FOR]{.title-ref} token.</li> <li>Consumes the [LPAREN]{.title-ref} token.</li> <li>Parses the initialization statement using     [parse_assignment()]{.title-ref}.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> <li>Parses the loop condition using     [parse_expression()]{.title-ref}.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> <li>Parses the loop update using [parse_expression()]{.title-ref}.</li> <li>Consumes the [RPAREN]{.title-ref} token.</li> <li>Consumes the [LBRACE]{.title-ref} token.</li> <li>Parses the loop body using [parse_body()]{.title-ref}.</li> <li>Consumes the [RBRACE]{.title-ref} token.</li> <li>Returns a [ForNode]{.title-ref} with the initialization,     condition, update, and body.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_body-method_1","title":"parse_body Method","text":"<p>| Description: | Parses the body of a function or a block of statements, handling   different types of statements such as assignments, expressions,   returns, and control flow.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_body(self)`:<ul> <li>Initializes an empty list [body]{.title-ref}.</li> <li>Iterates through tokens while the current token is not     [RBRACE]{.title-ref} or `EOF`:<ul> <li>Calls [parse_statement()]{.title-ref} to parse each     statement.</li> <li>Appends each parsed statement to the [body]{.title-ref}.</li> </ul> </li> <li>Returns the list [body]{.title-ref}.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#parse_statement-method","title":"parse_statement Method","text":"<p>| Description: | Parses a single statement, handling assignments, expressions, returns,   [if]{.title-ref} statements, [for]{.title-ref} loops, and   [break]{.title-ref} statements.</p> <p>Parameters:</p> <p>:   -   `self`: The instance of the class containing the code and         tokens.</p> <p>Method Details:</p> <ul> <li>`parse_statement(self)`:<ul> <li>Checks if the current token is [IDENTIFIER]{.title-ref} and the     next token is `EQUALS`:<ul> <li>Calls [parse_assignment()]{.title-ref} to handle the     assignment.</li> </ul> </li> <li>Checks if the current token is `RETURN`:<ul> <li>Calls [parse_return()]{.title-ref} to handle the return     statement.</li> </ul> </li> <li>Checks if the current token is `IF`:<ul> <li>Calls [parse_if()]{.title-ref} to handle the     [if]{.title-ref} statement.</li> </ul> </li> <li>Checks if the current token is `FOR`:<ul> <li>Calls [parse_for()]{.title-ref} to handle the     [for]{.title-ref} loop.</li> </ul> </li> <li>Checks if the current token is `BREAK`:<ul> <li>Consumes the [BREAK]{.title-ref} token.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> </ul> </li> <li>Checks if the current token is an expression:<ul> <li>Calls [parse_expression()]{.title-ref} to handle the     expression.</li> <li>Consumes the [SEMICOLON]{.title-ref} token.</li> </ul> </li> <li>Raises a [SyntaxError]{.title-ref} if the token is unexpected.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#opengl-codegen_1","title":"OpenGL Codegen","text":"<p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#generate-method","title":"generate Method","text":"<p>Description: Generates shader code from the abstract syntax tree (AST).</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>[ast (ASTNode)]{.title-ref} -- The abstract syntax tree representing     the shader code.</li> </ul> <p>Returns: - [str]{.title-ref} -- The generated shader code as a string, or an empty string if the [ast]{.title-ref} is not a [ShaderNode]{.title-ref}.</p> <p>Method Details:</p> <ul> <li> <p>`generate(self, ast)[: - Checks if the `ast]{.title-ref} is an instance of [ShaderNode]{.title-ref}.</p> <p>:   -   Sets [self.current_shader]{.title-ref} to the         [ast]{.title-ref}.     -   Calls [generate_shader(ast)]{.title-ref} to generate the         shader code.     -   Returns an empty string if the [ast]{.title-ref} is not a         [ShaderNode]{.title-ref}.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_shader-method","title":"generate_shader Method","text":"<p>Description: Generates the shader code for both vertex and fragment sections from the given node.</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>[node (ShaderNode)]{.title-ref} -- The node representing the shader     structure.</li> </ul> <p>Returns: - [str]{.title-ref} -- The generated shader code for the vertex and fragment sections.</p> <p>Method Details:</p> <ul> <li> <p>`generate_shader(self, node)[: - Sets up the shader by initializing `shader_inputs]{.title-ref}, [shader_outputs]{.title-ref}, and [uniforms]{.title-ref} from the node.</p> <p>:   -   Initializes the shader code with [shader main         {]{.title-ref}.</p> <pre><code>-\n\n    Generates the vertex shader section:\n\n    :   -   Sets [self.vertex_item]{.title-ref} to\n            [node.vertex_section]{.title-ref}.\n        -   If [vertex_item]{.title-ref} exists:\n        -   Adds the vertex section to the code.\n        -   Generates layout qualifiers using\n            [generate_layouts()]{.title-ref}.\n        -   Adds inputs and outputs for the shader and vertex\n            item.\n        -   Generates uniforms using\n            [generate_uniforms()]{.title-ref}.\n        -   Generates functions using\n            [generate_functions()]{.title-ref}.\n        -   Raises a [ValueError]{.title-ref} if no vertex\n            shader section is present.\n\n-\n\n    Generates the fragment shader section if present:\n\n    :   -   Sets [self.fragment_item]{.title-ref} to\n            [node.fragment_section]{.title-ref}.\n        -   If [fragment_item]{.title-ref} exists and has layout\n            qualifiers or functions:\n        -   Adds the fragment section to the code.\n        -   Generates layout qualifiers using\n            [generate_layouts()]{.title-ref}.\n        -   Adds inputs and outputs for the fragment item.\n        -   Generates uniforms using\n            [generate_uniforms()]{.title-ref}.\n        -   Generates functions using\n            [generate_functions()]{.title-ref}.\n        -   Raises a [ValueError]{.title-ref} if no fragment\n            shader section is present.\n\n-   Closes the shader code with [}]{.title-ref}.\n\n-   Returns the generated shader code.\n</code></pre> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_uniforms-method","title":"generate_uniforms Method","text":"<p>Description: Generates the uniform declarations for the shader.</p> <p>Parameters: - `self`: The instance of the class containing the code and tokens.</p> <p>Returns: - [str]{.title-ref} -- The generated uniform declarations.</p> <p>Method Details:</p> <ul> <li> <p>`generate_uniforms(self)[: - Initializes an empty list `uniform_lines]{.title-ref}.</p> <p>:   -   Iterates through each uniform in `self.uniforms`:     -   Appends the uniform declaration to         [uniform_lines]{.title-ref}.     -   Joins the list into a single string with newline characters         and returns it.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_layouts-method","title":"generate_layouts Method","text":"<p>Description: Generates the layout qualifiers for the shader, handling both input and output types.</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>[layouts (list of LayoutNode)]{.title-ref} -- A list of layout     objects, each containing [io_type]{.title-ref}, [dtype]{.title-ref},     and [name]{.title-ref}.</li> </ul> <p>Returns: - [str]{.title-ref} -- The generated layout qualifiers.</p> <p>Method Details:</p> <ul> <li>`generate_layouts(self, layouts)`:<ul> <li>Initializes an empty string [code]{.title-ref}.</li> <li>Iterates through each layout in `layouts`:</li> <li>Checks if the layout's [io_type]{.title-ref} is `input`:</li> <li>Appends the input layout declaration to [code]{.title-ref}.</li> <li>Checks if the layout's [io_type]{.title-ref} is `output`:</li> <li>Appends the output layout declaration to [code]{.title-ref}.</li> <li>Returns the generated code string.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_functions-method","title":"generate_functions Method","text":"<p>Description: Generates the function definitions for the shader, handling both vertex and fragment shader types.</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>[functions (list[FunctionNode])]{.title-ref} -- A list of function     nodes, each representing a function in the shader.</li> <li>[shader_type (str)]{.title-ref} -- The type of shader     ([vertex]{.title-ref} or [fragment]{.title-ref}).</li> </ul> <p>Returns: - [str]{.title-ref} -- The generated function definitions.</p> <p>Method Details:</p> <ul> <li> <p>`generate_functions(self, functions, shader_type)[: - Initializes an empty string `code]{.title-ref}.</p> <p>:   -   Checks if [shader_type]{.title-ref} is either         [vertex]{.title-ref} or [fragment]{.title-ref}.     -   Iterates through each [function_node]{.title-ref} in         `functions`:         -   Generates the parameter list by mapping each parameter's             type and name.         -   Generates the function header with the return type,             function name, and parameters.         -   Generates the function body by iterating through each             statement in [function_node.body]{.title-ref} and             calling [generate_statement()]{.title-ref}.         -   Closes the function definition.     -   Returns the generated code string.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_statement-method","title":"generate_statement Method","text":"<p>Description: Generates the code for a given statement, handling various types of statements such as variable declarations, assignments, control flow statements, and expressions.</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>`stmt`: The statement node to be generated.</li> <li>`shader_type`: The type of shader ([vertex]{.title-ref} or     [fragment]{.title-ref}).</li> <li>`indent`: The indentation level for the generated code (default is     0).</li> </ul> <p>Method Details:</p> <ul> <li> <p>`generate_statement(self, stmt, shader_type, indent=0)[: - Initializes the indentation string `indent_str]{.title-ref} based on the [indent]{.title-ref} level.</p> <p>:   -   Checks the type of [stmt]{.title-ref} and generates the         corresponding code:     -   If [stmt]{.title-ref} is a `VariableNode`:     -   Returns the variable declaration with the mapped type and         name.     -   If [stmt]{.title-ref} is an `AssignmentNode`:     -   Returns the assignment statement generated by         [generate_assignment()]{.title-ref}.     -   If [stmt]{.title-ref} is an `IfNode`:     -   Returns the [if]{.title-ref} statement generated by         [generate_if()]{.title-ref}.     -   If [stmt]{.title-ref} is a `ForNode`:     -   Returns the [for]{.title-ref} loop generated by         [generate_for()]{.title-ref}.     -   If [stmt]{.title-ref} is a `ReturnNode`:     -   Returns the return statement with the generated expression.     -   Otherwise:     -   Returns the generated expression.     -   Each generated statement is properly indented based on the         [indent]{.title-ref} level.</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#generate_assignment-method","title":"generate_assignment Method","text":"<p>Description: Generates the code for an assignment statement, handling the left-hand side (LHS) and right-hand side (RHS) expressions.</p> <p>Parameters:</p> <ul> <li>`self`: The instance of the class containing the code and tokens.</li> <li>`node`: The assignment node containing the LHS and RHS     expressions.</li> <li>`shader_type`: The type of shader ([vertex]{.title-ref} or     [fragment]{.title-ref}).</li> </ul> <p>Method Details:</p> <ul> <li>`generate_assignment(self, node, shader_type)`:<ul> <li>Generates the LHS expression using     [generate_expression(node.name, shader_type)]{.title-ref}.</li> <li>Generates the RHS expression using     [generate_expression(node.value, shader_type)]{.title-ref}.</li> <li>Returns the assignment statement in the format [lhs =     rhs]{.title-ref}.</li> </ul> </li> </ul> <p>---</p>"},{"location":"pages/graphica/api_reference/#generate_if-method","title":"generate_if Method","text":"<p>Description: Generates code for an [if]{.title-ref} statement, including optional [else if]{.title-ref} and [else]{.title-ref} blocks, formatted with the specified indentation.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (IfNode): An [IfNode]{.title-ref} instance     representing the [if]{.title-ref} statement and its associated     conditions and blocks.</li> <li>[shader_type]{.title-ref} (str): Specifies the type of shader being     generated (e.g., [\\\"vertex\\\"]{.title-ref} or     [\\\"fragment\\\"]{.title-ref}), affecting how certain constructs are     handled.</li> <li>[indent]{.title-ref} (int): The current level of indentation to     apply in the generated code.</li> </ul> <p>Returns: - `str`: A string containing the generated code for the [if]{.title-ref} statement, properly formatted with indentation.</p> <p>Method Details: - Constructs the [if]{.title-ref} statement with its condition and corresponding body. - Handles chained [else if]{.title-ref} conditions and their bodies. - Includes an optional [else]{.title-ref} block if provided. - Ensures that code blocks are correctly indented based on the [indent]{.title-ref} parameter.</p> <p>---</p>"},{"location":"pages/graphica/api_reference/#generate_else_if-method","title":"generate_else_if Method","text":"<p>Description: Generates code for an [else if]{.title-ref} block within an [if]{.title-ref} statement, formatted with the specified indentation.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (IfNode): An [IfNode]{.title-ref} instance     representing the [else if]{.title-ref} condition and its associated     body.</li> <li>[shader_type]{.title-ref} (str): Specifies the type of shader being     generated (e.g., [\\\"vertex\\\"]{.title-ref} or     [\\\"fragment\\\"]{.title-ref}), influencing the handling of specific     constructs.</li> <li>[indent]{.title-ref} (int): The level of indentation to apply in the     generated code.</li> </ul> <p>Returns: - `str`: A string containing the generated code for the [else if]{.title-ref} block, properly formatted with indentation.</p> <p>Method Details: - Constructs the [else if]{.title-ref} block with its condition and corresponding body. - Ensures that the code within the [else if]{.title-ref} block is correctly indented based on the [indent]{.title-ref} parameter.</p> <p>---</p>"},{"location":"pages/graphica/api_reference/#generate_for-method","title":"generate_for Method","text":"<p>Description: Generates code for a [for]{.title-ref} loop construct, including initialization, condition, update, and body, formatted with the specified indentation.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (ForNode): An instance of [ForNode]{.title-ref}     representing the [for]{.title-ref} loop's components such as     initialization, condition, update, and body.</li> <li>[shader_type]{.title-ref} (str): Specifies the type of shader being     generated (e.g., [\\\"vertex\\\"]{.title-ref} or     [\\\"fragment\\\"]{.title-ref}), affecting the syntax and semantics of     the loop.</li> <li>[indent]{.title-ref} (int): The level of indentation to apply to the     generated code.</li> </ul> <p>Returns: - `str`: A string containing the generated code for the [for]{.title-ref} loop, properly formatted with indentation.</p> <p>Method Details: - Initialization (`init`): Generates the initialization statement for the [for]{.title-ref} loop, stripping trailing semicolons. - Condition (`condition`): Generates the loop's condition expression. - Update (`update`): Generates the update statement for the [for]{.title-ref} loop, stripping trailing semicolons. - Body: Generates the code for the body of the [for]{.title-ref} loop, applying additional indentation.</p> <p>Example:</p> <pre><code>for (int i = 0; i &lt; 10; i++) {\n    // Loop body\n}\n</code></pre> <p>---</p>"},{"location":"pages/graphica/api_reference/#generate_update-method","title":"generate_update Method","text":"<p>Description: Generates the code for the update part of a [for]{.title-ref} loop, handling various types of expressions such as assignments, unary operations, and binary operations.</p> <p>Parameters:</p> <ul> <li>[node]{.title-ref} (ASTNode): An instance of     [AssignmentNode]{.title-ref}, [UnaryOpNode]{.title-ref}, or     [BinaryOpNode]{.title-ref} representing the update expression in the     [for]{.title-ref} loop.</li> <li>[shader_type]{.title-ref} (str): Specifies the type of shader being     generated (e.g., [\\\"vertex\\\"]{.title-ref} or     [\\\"fragment\\\"]{.title-ref}), which can affect how the update     expression is formatted.</li> </ul> <p>Returns: - `str`: A string containing the generated code for the update expression.</p> <p>Method Details:</p> <ul> <li>AssignmentNode: Handles both simple assignments and     increments/decrements.<ul> <li>If the value is a [UnaryOpNode]{.title-ref}, it generates     increment or decrement operations.</li> <li>Otherwise, it generates a standard assignment.</li> </ul> </li> <li>UnaryOpNode: Generates pre-increment, post-increment,     pre-decrement, post-decrement, or unary operations based on the     operation type.</li> <li>BinaryOpNode: Handles binary operations and maps them to     appropriate operators using [map_operator]{.title-ref}.</li> <li>Error Handling: Raises a [ValueError]{.title-ref} for     unsupported node types.</li> </ul> <p>---</p>"},{"location":"pages/graphica/api_reference/#generate_expression-method","title":"generate_expression Method","text":"<p>Description: Generates code for various types of expressions used in shader programming. This includes translating simple strings, handling variables, binary and unary operations, function calls, ternary operations, and member accesses.</p> <p>Parameters:</p> <ul> <li>[expr]{.title-ref} (ASTNode): An instance of a specific type of     expression node, such as [VariableNode]{.title-ref},     [BinaryOpNode]{.title-ref}, etc.</li> <li>[shader_type]{.title-ref} (str): Indicates the type of shader (e.g.,     [\\\"vertex\\\"]{.title-ref} or [\\\"fragment\\\"]{.title-ref}), which might     influence how the expressions are formatted.</li> </ul> <p>Returns: - `str`: A string containing the generated code for the expression.</p> <p>Method Details:</p> <ol> <li>str: Uses [translate_expression]{.title-ref} to handle basic     string translation or identifiers.</li> <li>VariableNode: Generates a variable declaration or usage based on     its type and name.</li> <li>BinaryOpNode: Generates binary operations by recursively     generating code for left and right operands and mapping the     operator.</li> <li>FunctionCallNode: Generates function calls, including the     function name and arguments.</li> <li>UnaryOpNode: Handles unary operations, including pre-increment     and pre-decrement.</li> <li>TernaryOpNode: Generates ternary conditional expressions.</li> <li>MemberAccessNode: Handles member accesses (e.g.,     object.property).</li> <li>Default Case: Converts any other node types to their string     representations.</li> </ol> <p>---</p>"},{"location":"pages/graphica/api_reference/#translate_expression-method","title":"translate_expression Method","text":"<p>Description: Translates a given expression (identifier) into its corresponding name based on the shader type. It checks if the expression matches any of the inputs or outputs for the current shader item and returns the appropriate name.</p> <p>Parameters:</p> <ul> <li>[expr]{.title-ref} (str): The identifier or expression to be     translated.</li> <li>[shader_type]{.title-ref} (str): The type of shader     ([\\\"vertex\\\"]{.title-ref} or [\\\"fragment\\\"]{.title-ref}) which     determines which item lists to check.</li> </ul> <p>Returns: - `str`: The translated name if a match is found, otherwise the original expression.</p> <p>Method Details:</p> <ol> <li>Vertex Shader Type:<ul> <li>If [shader_type]{.title-ref} is [\\\"vertex\\\"]{.title-ref} and     [self.vertex_item]{.title-ref} is not [None]{.title-ref}, it     checks the inputs and outputs of [self.vertex_item]{.title-ref}.</li> <li>If [expr]{.title-ref} matches any input or output names, it     returns the matched name.</li> <li>If no match is found, it returns the original expression.</li> </ul> </li> <li>Fragment Shader Type:<ul> <li>If [shader_type]{.title-ref} is [\\\"fragment\\\"]{.title-ref} and     [self.fragment_item]{.title-ref} is not [None]{.title-ref}, it     checks the inputs and outputs of     [self.fragment_item]{.title-ref}.</li> <li>If [expr]{.title-ref} matches any input or output names, it     returns the matched name.</li> <li>If no match is found, it returns the original expression.</li> </ul> </li> <li>Default Return:<ul> <li>If the shader type is not recognized or no match is found, the     method returns the expression as is.</li> </ul> </li> </ol> <p>---</p>"},{"location":"pages/graphica/api_reference/#map_type-method","title":"map_type Method","text":"<p>Description: Translates internal type representations into their corresponding shader types using a predefined mapping.</p> <p>Parameters: - [vtype]{.title-ref} (str): The internal type representation to be mapped.</p> <p>Returns: - `str`: The corresponding shader type based on the mapping, or the original type if no mapping is found.</p> <p>Method Details:</p> <ol> <li> <p>Type Mapping:</p> <ul> <li>The method uses a dictionary called [type_map]{.title-ref} to     define the mappings:</li> </ul> <p><code>cpp vec3 maps to vec3 vec4 maps to vec4 float maps to float int maps to int bool maps to bool</code></p> <ul> <li>The [type_map]{.title-ref} dictionary includes common GLSL     types.</li> </ul> </li> <li> <p>Lookup:</p> <ul> <li>The method attempts to find the [vtype]{.title-ref} in the     [type_map]{.title-ref} dictionary.</li> <li>If [vtype]{.title-ref} is found, it returns the corresponding     shader type.</li> <li>If [vtype]{.title-ref} is not found in the dictionary, it     returns the original [vtype]{.title-ref}.</li> </ul> </li> </ol> <p>---</p>"},{"location":"pages/graphica/api_reference/#map_operator-method","title":"map_operator Method","text":"<p>Description: Maps internal operator representations to their corresponding shader language operators using a predefined mapping.</p> <p>Parameters: - [op]{.title-ref} (str): The internal operator representation to be mapped.</p> <p>Returns: - `str`: The corresponding shader operator based on the mapping, or the original operator if no mapping is found.</p> <p>Method Details:</p> <ol> <li> <p>Operator Mapping:</p> <ul> <li>The method uses a dictionary called [operator_map]{.title-ref}     to define the mappings:</li> </ul> <p><code>cpp + maps to + - maps to - * maps to * / maps to / == maps to == != maps to !=</code></p> <ul> <li>The [operator_map]{.title-ref} dictionary includes common GLSL     operators.</li> </ul> </li> <li> <p>Lookup:</p> <ul> <li>The method attempts to find the [op]{.title-ref} in the     [operator_map]{.title-ref} dictionary.</li> <li>If [op]{.title-ref} is found, it returns the corresponding     shader operator.</li> <li>If [op]{.title-ref} is not found in the dictionary, it returns     the original operator.</li> </ul> </li> </ol> <p>---</p> <p>This format should provide a clear and organized documentation for each method, making it easier for users to understand and use the methods effectively.</p>"},{"location":"pages/graphica/api_reference/#mojo","title":"Mojo","text":""},{"location":"pages/graphica/api_reference/#mojo-ast","title":"Mojo AST","text":""},{"location":"pages/graphica/api_reference/#ternaryopnode-class-2","title":"TernaryOpNode Class","text":"<p>| Description: | Represents a ternary conditional operation in an abstract syntax tree   (AST). This node type models the conditional expression and its two   possible outcomes, facilitating the generation of conditional code in   shader programming.</p> <p>Constructor Parameters:</p> <p>:   -   [condition]{.title-ref} (MojoASTNode): The condition expression         that determines which of the two outcomes to choose.     -   [true_expr]{.title-ref} (MojoASTNode): The expression to be         evaluated and returned if the condition is true.     -   [false_expr]{.title-ref} (MojoASTNode): The expression to be         evaluated and returned if the condition is false.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`TernaryOpNode]{.title-ref} instance, useful for debugging\n    :   and logging.\n        -   **Returns**: A string in the format:\n\n        ``` python\n        ```\n\n        \\\"TernaryOpNode(condition={self.condition},\n        true_expr={self.true_expr}, false_expr={self.false_expr})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#shadernode-class-2","title":"ShaderNode Class","text":"<p>| Description: | Represents a shader program in an abstract syntax tree (AST),   containing a collection of functions that define the shader's behavior   and structure.</p> <p>Constructor Parameters:</p> <p>:   -   [functions]{.title-ref} (list of MojoASTNode): A list of         function nodes ([MojoASTNode]{.title-ref}) that are part of the         shader. These functions define the various operations and logic         within the shader.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ShaderNode]{.title-ref} instance, useful for debugging\n    :   and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [ShaderNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"ShaderNode(functions={self.functions})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#structnode-class","title":"StructNode Class","text":"<p>| Description: | Represents a structure definition in an abstract syntax tree (AST). It   encapsulates the name of the structure and its members, which define   the structure's layout and data types.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the structure.     -   [members]{.title-ref} (list of Tuple[str, str]): A list of         tuples where each tuple represents a member of the structure.         Each tuple contains the member's name and its data type.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`StructNode]{.title-ref} instance, which is useful for\n    :   debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [StructNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"StructNode(name={self.name}, members={self.members})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#functionnode-class-2","title":"FunctionNode Class","text":"<p>| Description: | Represents a function definition in an abstract syntax tree (AST). It   includes the function's attributes, return type, name, parameters,   body, and any additional attributes.</p> <p>Constructor Parameters:</p> <p>:   -   [qualifier]{.title-ref} (str): Specifies any qualifiers for the         function, such as [static]{.title-ref}, [inline]{.title-ref}, or         [extern]{.title-ref}.     -   [return_type]{.title-ref} (str): The data type that the function         returns.     -   [name]{.title-ref} (str): The name of the function.     -   [params]{.title-ref} (list of Tuple[str, str]): A list of         tuples where each tuple represents a parameter of the function.         Each tuple contains the parameter's type and name.     -   [body]{.title-ref} (list of ASTNode): A list of statements         representing the body of the function.     -   [attributes]{.title-ref} (list of str, optional): A list of         additional attributes or modifiers for the function, such as         [const]{.title-ref}, [volatile]{.title-ref}, etc. Defaults to an         empty list if not provided.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`FunctionNode]{.title-ref} instance, which is useful for\n    :   debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [FunctionNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"FunctionNode(qualifier={self.qualifier},\n        return_type={self.return_type}, name={self.name},\n        params={self.params}, body={self.body},\n        attributes={self.attributes})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#variabledeclarationnode-class","title":"VariableDeclarationNode Class","text":"<p>| Description: | Represents a variable declaration in an abstract syntax tree (AST). It   includes the variable's type, name, and optionally an initial value.</p> <p>Constructor Parameters:</p> <p>:   -   [var_type]{.title-ref} (str): The data type of the variable         (e.g., [int]{.title-ref}, [float]{.title-ref},         [vec3]{.title-ref}).     -   [name]{.title-ref} (str): The name of the variable.     -   [initial_value]{.title-ref} (Optional[str]): The initial value         assigned to the variable. Defaults to [None]{.title-ref} if not         provided.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`VariableDeclarationNode]{.title-ref} instance, which is useful for debugging and logging.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [VariableDeclarationNode]{.title-ref} in the format:\n\n        ``` python\n        \"VariableDeclarationNode(var_type={self.var_type}, name={self.name}, initial_value={self.initial_value})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#arrayaccessnode-class","title":"ArrayAccessNode Class","text":"<p>| Description: | Represents an array access operation in an abstract syntax tree (AST).   It includes the array being accessed and the index used for accessing   an element.</p> <p>Constructor Parameters:</p> <p>:   -   [array]{.title-ref} (MojoASTNode): The array from which an         element is accessed.     -   [index]{.title-ref} (MojoASTNode): The index used to access an         element of the array.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ArrayAccessNode]{.title-ref} instance, which is useful\n    :   for debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [ArrayAccessNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"ArrayAccessNode(array={self.array}, index={self.index})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#variablenode-class-2","title":"VariableNode Class","text":"<p>| Description: | Represents a variable declaration or reference in an abstract syntax   tree (AST). It includes the variable's type, name, and optional   attributes.</p> <p>Constructor Parameters:</p> <p>:   -   [vtype]{.title-ref} (str): The type of the variable (e.g.,         [\\\"int\\\"]{.title-ref}, [\\\"float\\\"]{.title-ref}).     -   [name]{.title-ref} (str): The name of the variable.     -   [attributes]{.title-ref} (list, optional): A list of attributes         associated with the variable. Defaults to an empty list if not         provided.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`VariableNode]{.title-ref} instance, which is useful for\n    :   debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [VariableNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"VariableNode(vtype=\\'{self.vtype}\\', name=\\'{self.name}\\',\n        attributes={self.attributes})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#attributenode-class","title":"AttributeNode Class","text":"<p>| Description: | Represents an attribute associated with a variable, function, or other   elements in an abstract syntax tree (AST). Attributes are often used   to specify metadata or additional properties.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the attribute (e.g.,         [\\\"location\\\"]{.title-ref}, [\\\"binding\\\"]{.title-ref}).     -   [args]{.title-ref} (list, optional): A list of arguments for the         attribute. Defaults to an empty list if not provided.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`AttributeNode]{.title-ref} instance, which is useful for\n    :   debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [AttributeNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"AttributeNode(name=\\'{self.name}\\', args={self.args})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#assignmentnode-class-2","title":"AssignmentNode Class","text":"<p>| Description: | Represents an assignment operation in the abstract syntax tree (AST).   This node is used to model the assignment of a value to a variable,   potentially with a specific operator.</p> <p>Constructor Parameters:</p> <p>:   -   [left]{.title-ref} (MojoASTNode): The left-hand side of the         assignment, typically a variable or an array element.     -   [right]{.title-ref} (MojoASTNode): The right-hand side of the         assignment, representing the value to be assigned.     -   [operator]{.title-ref} (str, optional): The assignment operator.         Defaults to [\\\"=\\\"]{.title-ref}. Other operators like         [\\\"+=\\\"]{.title-ref}, [\\\"-=\\\"]{.title-ref}, etc., can be used.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`AssignmentNode]{.title-ref} instance, which is useful for\n    :   debugging and logging.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [AssignmentNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"AssignmentNode(left={self.left},\n        operator=\\'{self.operator}\\', right={self.right})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#ifnode-class-2","title":"IfNode Class","text":"<p>| Description: | Represents an [if]{.title-ref} statement in the abstract syntax tree   (AST). This node is used to model conditional logic with an optional   [else]{.title-ref} block.</p> <p>Constructor Parameters:</p> <p>:   -   [condition]{.title-ref} (MojoASTNode): The condition to be         evaluated for the [if]{.title-ref} statement. This typically         involves a boolean expression.     -   [if_body]{.title-ref} (list of MojoASTNode): The body of the         [if]{.title-ref} block, containing statements to be executed if         the condition evaluates to [True]{.title-ref}.     -   [else_body]{.title-ref} (list of MojoASTNode, optional): The         body of the [else]{.title-ref} block, containing statements to         be executed if the condition evaluates to [False]{.title-ref}.         Defaults to [None]{.title-ref} if no [else]{.title-ref} block is         present.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`IfNode]{.title-ref} instance, including the condition,\n    :   [if_body]{.title-ref}, and [else_body]{.title-ref}.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [IfNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"IfNode(condition={self.condition}, if_body={self.if_body},\n        else_body={self.else_body})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#fornode-class-2","title":"ForNode Class","text":"<p>| Description: | Represents a [for]{.title-ref} loop in the abstract syntax tree (AST).   This node models the structure of a [for]{.title-ref} loop, including   initialization, condition, update, and body.</p> <p>Constructor Parameters:</p> <p>:   -   [init]{.title-ref} (MojoASTNode): The initialization statement         of the [for]{.title-ref} loop, which is executed once before the         loop starts.     -   [condition]{.title-ref} (MojoASTNode): The loop condition that         is evaluated before each iteration. The loop continues to         execute as long as this condition is [True]{.title-ref}.     -   [update]{.title-ref} (MojoASTNode): The update statement         executed after each iteration of the loop.     -   [body]{.title-ref} (list of MojoASTNode): The body of the         [for]{.title-ref} loop, containing the statements to be executed         in each iteration.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ForNode]{.title-ref} instance, including the\n    :   initialization, condition, update, and body.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [ForNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"ForNode(init={self.init}, condition={self.condition},\n        update={self.update}, body={self.body})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#whilenode-class","title":"WhileNode Class","text":"<p>| Description: | Represents a [while]{.title-ref} loop in the abstract syntax tree   (AST). This node models the structure of a [while]{.title-ref} loop,   including its condition and body.</p> <p>Constructor Parameters:</p> <p>:   -   [condition]{.title-ref} (MojoASTNode): The condition that is         evaluated before each iteration. The loop continues to execute         as long as this condition is [True]{.title-ref}.     -   [body]{.title-ref} (list of MojoASTNode): The body of the         [while]{.title-ref} loop, containing the statements to be         executed in each iteration.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`WhileNode]{.title-ref} instance, including the condition\n    :   and body.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [WhileNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"WhileNode(condition={self.condition}, body={self.body})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#returnnode-class-2","title":"ReturnNode Class","text":"<p>| Description: | Represents a [return]{.title-ref} statement in the abstract syntax   tree (AST). This node captures the value to be returned from a   function or method.</p> <p>Constructor Parameters:</p> <p>:   -   [value]{.title-ref} (MojoASTNode or None): The value to be         returned. If [None]{.title-ref}, it represents a return         statement with no value.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ReturnNode]{.title-ref} instance, including the return\n    :   value.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [ReturnNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"ReturnNode(value={self.value})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#functioncallnode-class-2","title":"FunctionCallNode Class","text":"<p>| Description: | Represents a function or method call in the abstract syntax tree   (AST). This node captures the name of the function being called and   the arguments passed to it.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the function or method         being called.     -   [args]{.title-ref} (list of MojoASTNode): The arguments passed         to the function. Each argument is represented as an AST node.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`FunctionCallNode]{.title-ref} instance, including the\n    :   function name and its arguments.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [FunctionCallNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"FunctionCallNode(name={self.name}, args={self.args})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#binaryopnode-class-2","title":"BinaryOpNode Class","text":"<p>| Description: | Represents a binary operation in the abstract syntax tree (AST). This   node captures two operands and the operator used to combine them.</p> <p>Constructor Parameters:</p> <p>:   -   [left]{.title-ref} (MojoASTNode): The left operand of the binary         operation.     -   [op]{.title-ref} (str): The operator used in the binary         operation (e.g., \\\"+\\\", \\\"-\\\", \\\"*\\\", \\\"/\\\").     -   [right]{.title-ref} (MojoASTNode): The right operand of the         binary operation.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`BinaryOpNode]{.title-ref} instance, including the left\n    :   operand, the operator, and the right operand.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [BinaryOpNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"BinaryOpNode(left={self.left}, operator={self.op},\n        right={self.right})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#unaryopnode-class-2","title":"UnaryOpNode Class","text":"<p>| Description: | Represents a unary operation in the abstract syntax tree (AST). This   node captures the operator and its single operand.</p> <p>Constructor Parameters:</p> <p>:   -   [op]{.title-ref} (str): The operator used in the unary operation         (e.g., \\\"+\\\", \\\"-\\\", \\\"++\\\", \\\"--\\\").     -   [operand]{.title-ref} (MojoASTNode): The operand for the unary         operation.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`UnaryOpNode]{.title-ref} instance, including the operator\n    :   and the operand.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [UnaryOpNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"UnaryOpNode(operator={self.op}, operand={self.operand})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#memberaccessnode-class-2","title":"MemberAccessNode Class","text":"<p>| Description: | Represents an access operation on a member of an object in the   abstract syntax tree (AST). This node captures the object and the   specific member being accessed.</p> <p>Constructor Parameters:</p> <p>:   -   [object]{.title-ref} (MojoASTNode): The object or variable whose         member is being accessed.     -   [member]{.title-ref} (str): The name of the member being         accessed.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`MemberAccessNode]{.title-ref} instance, including the\n    :   object and the member.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [MemberAccessNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"MemberAccessNode(object={self.object},\n        member={self.member})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#vectorconstructornode-class","title":"VectorConstructorNode Class","text":"<p>| Description: | Represents a vector constructor operation in the abstract syntax tree   (AST). This node is used to create vectors from a set of arguments   with a specified type.</p> <p>Constructor Parameters:</p> <p>:   -   [type_name]{.title-ref} (str): The name of the vector type         (e.g., [\\\"vec2\\\"]{.title-ref}, [\\\"vec3\\\"]{.title-ref},         [\\\"vec4\\\"]{.title-ref}).     -   [args]{.title-ref} (List[MojoASTNode]): A list of arguments         used to initialize the vector.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`VectorConstructorNode]{.title-ref} instance, including\n    :   the vector type and its initialization arguments.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [VectorConstructorNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"VectorConstructorNode(type_name={self.type_name},\n        args={self.args})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#texturesamplenode-class","title":"TextureSampleNode Class","text":"<p>| Description: | Represents a texture sampling operation in the abstract syntax tree   (AST). This node is used to sample a texture using a specified sampler   and texture coordinates.</p> <p>Constructor Parameters:</p> <p>:   -   [texture]{.title-ref} (MojoASTNode): The texture to be sampled.     -   [sampler]{.title-ref} (MojoASTNode): The sampler used to sample         the texture.     -   [coordinates]{.title-ref} (MojoASTNode): The coordinates at         which the texture is sampled.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`TextureSampleNode]{.title-ref} instance, including the\n    :   texture, sampler, and coordinates used for sampling.\n        -   **Returns**: \\`str\\`: A string representation of the\n            [TextureSampleNode]{.title-ref} in the format:\n\n        ``` python\n        ```\n\n        \\\"TextureSampleNode(texture={self.texture},\n        sampler={self.sampler}, coordinates={self.coordinates})\\\"\n</code></pre>"},{"location":"pages/graphica/api_reference/#threadgroupsyncnode-class","title":"ThreadgroupSyncNode Class","text":"<p>| Description: | Represents a synchronization point for thread groups in a compute   shader or parallel execution environment. This node ensures that all   threads in the group reach the synchronization point before   continuing.</p> <p>Constructor Parameters:</p> <p>:   -   None</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ThreadgroupSyncNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [ThreadgroupSyncNode]{.title-ref} in the format:\n\n        ``` python\n        \"ThreadgroupSyncNode()\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#constantbuffernode-class","title":"ConstantBufferNode Class","text":"<p>| Description: | Represents a constant buffer in a shader program, which is used to   store uniform data that remains constant across multiple shader   invocations.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the constant buffer.     -   [members]{.title-ref} (list of [VariableNode]{.title-ref}): A         list of variables that are members of the constant buffer.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ConstantBufferNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [ConstantBufferNode]{.title-ref} in the format:\n\n        ``` python\n        \"ConstantBufferNode(name={self.name}, members={self.members})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#importnode-class","title":"ImportNode Class","text":"<p>| Description: | Represents an import statement in a shader program, used to include   external modules or libraries with an optional alias.</p> <p>Constructor Parameters:</p> <p>:   -   [module_name]{.title-ref} (str): The name of the module to be         imported.     -   [alias]{.title-ref} (str, optional): An alias for the module,         allowing it to be referenced with a different name in the         shader.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ImportNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [ImportNode]{.title-ref} in the format:\n\n        ``` python\n        \"ImportNode(module_name='{self.module_name}', alias='{self.alias}')\"\n\n        if an alias is provided, otherwise\n\n        \"ImportNode(module_name='{self.module_name}')\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#classnode-class","title":"ClassNode Class","text":"<p>| Description: | Represents a class definition in the shader program, including its   name, base classes, and members.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the class.     -   [base_classes]{.title-ref} (list of str): A list of base class         names that this class inherits from.     -   [members]{.title-ref} (list of [MojoASTNode]{.title-ref}): A         list of member variables and methods that belong to the class.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`ClassNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [ClassNode]{.title-ref} in the format:\n\n        ``` python\n        \"ClassNode(name={self.name}, base_classes={self.base_classes}, members={self.members})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#decoratornode-class","title":"DecoratorNode Class","text":"<p>| Description: | Represents a decorator applied to functions or classes in the shader   program, including the decorator's name and any optional arguments.</p> <p>Constructor Parameters:</p> <p>:   -   [name]{.title-ref} (str): The name of the decorator.     -   [args]{.title-ref} (list of [MojoASTNode]{.title-ref},         optional): A list of arguments for the decorator. Defaults to an         empty list if not provided.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`DecoratorNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [DecoratorNode]{.title-ref} in the format:\n\n        ``` python\n        \"DecoratorNode(name={self.name}, args={self.args})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#switchcasenode-class","title":"SwitchCaseNode Class","text":"<p>| Description: | Represents a case in a switch statement, including the condition for   the case and the block of code to execute if the condition is met.</p> <p>Constructor Parameters:</p> <p>:   -   [condition]{.title-ref} (MojoASTNode): The condition that         determines if this case should be executed.     -   [body]{.title-ref} (list of [MojoASTNode]{.title-ref}): The         block of code to execute if the condition is met.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`SwitchCaseNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [SwitchCaseNode]{.title-ref} in the format:\n\n        ``` python\n        \"SwitchCaseNode(condition={self.condition}, body={self.body})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#switchnode-class","title":"SwitchNode Class","text":"<p>| Description: | Represents a switch statement, including the expression to evaluate   and the list of cases to handle different values of the expression.</p> <p>Constructor Parameters:</p> <p>:   -   [expression]{.title-ref} (MojoASTNode): The expression being         evaluated in the switch statement.     -   [cases]{.title-ref} (list of [SwitchCaseNode]{.title-ref}): A         list of [SwitchCaseNode]{.title-ref} instances, each         representing a case in the switch statement.</p> <p>Methods:</p> <p>:   -   </p> <pre><code>    \\`\\_\\_repr\\_\\_()[: - \\*\\*Description\\*\\*: Returns a string representation of the \\`SwitchNode]{.title-ref} instance.\n\n    :   -   **Returns**: \\`str\\`: A string representation of the\n            [SwitchNode]{.title-ref} in the format:\n\n        ``` python\n        \"SwitchNode(expression={self.expression}, cases={self.cases})\"\n        ```\n</code></pre>"},{"location":"pages/graphica/api_reference/#mojo-lexer","title":"Mojo Lexer","text":""},{"location":"pages/graphica/api_reference/#token-definitions-and-keywords-for-mojo","title":"Token Definitions and Keywords for Mojo","text":""},{"location":"pages/graphica/api_reference/#token-definitions_1","title":"Token Definitions","text":"<ul> <li> <p>| <code>COMMENT_SINGLE</code>: <code>#.*</code>     | Represents a single-line comment starting with <code>#</code>.</p> </li> <li> <p>| <code>COMMENT_MULTI</code>: <code>\"\"\"[\\s\\S]*?\"\"\"</code>     | Represents a multi-line comment enclosed in triple double quotes       (<code>\"\"\"</code>).</p> </li> <li> <p>| <code>STRUCT</code>: <code>\\bstruct\\b</code>     | Represents the <code>struct</code> keyword for defining structures.</p> </li> <li> <p>| <code>LET</code>: <code>\\blet\\b</code>     | Represents the <code>let</code> keyword for variable declaration.</p> </li> <li> <p>| <code>VAR</code>: <code>\\bvar\\b</code>     | Represents the <code>var</code> keyword for variable declaration.</p> </li> <li> <p>| <code>FN</code>: <code>\\bfn\\b</code>     | Represents the <code>fn</code> keyword for function definition.</p> </li> <li> <p>| <code>RETURN</code>: <code>\\breturn\\b</code>     | Represents the <code>return</code> keyword for returning values from       functions.</p> </li> <li> <p>| <code>IF</code>: <code>\\bif\\b</code>     | Represents the <code>if</code> keyword for conditional statements.</p> </li> <li> <p>| <code>ELSE</code>: <code>\\belse\\b</code>     | Represents the <code>else</code> keyword for conditional statements.</p> </li> <li> <p>| <code>FOR</code>: <code>\\bfor\\b</code>     | Represents the <code>for</code> keyword for loop statements.</p> </li> <li> <p>| <code>WHILE</code>: <code>\\bwhile\\b</code>     | Represents the <code>while</code> keyword for loop statements.</p> </li> <li> <p>| <code>IMPORT</code>: <code>\\bimport\\b</code>     | Represents the <code>import</code> keyword for importing modules.</p> </li> <li> <p>| <code>DEF</code>: <code>\\bdef\\b</code>     | Represents the <code>def</code> keyword for function definition.</p> </li> <li> <p>| <code>INT</code>: <code>\\bInt\\b</code>     | Represents the <code>Int</code> type keyword.</p> </li> <li> <p>| <code>FLOAT</code>: <code>\\bFloat\\b</code>     | Represents the <code>Float</code> type keyword.</p> </li> <li> <p>| <code>BOOL</code>: <code>\\bBool\\b</code>     | Represents the <code>Bool</code> type keyword.</p> </li> <li> <p>| <code>STRING</code>: <code>\\bString\\b</code>     | Represents the <code>String</code> type keyword.</p> </li> <li> <p>| <code>IDENTIFIER</code>: <code>[a-zA-Z_][a-zA-Z0-9_]*</code>     | Represents an identifier consisting of letters, digits, and       underscores.</p> </li> <li> <p>| <code>NUMBER</code>: <code>\\d+(\\.\\d+)?</code>     | Represents a number, which can be an integer or a floating-point       number.</p> </li> <li> <p>| <code>LBRACE</code>: <code>\\{</code>     | Represents the left brace <code>{</code>.</p> </li> <li> <p>| <code>RBRACE</code>: <code>\\}</code>     | Represents the right brace <code>}</code>.</p> </li> <li> <p>| <code>LPAREN</code>: <code>\\(</code>     | Represents the left parenthesis <code>(</code>.</p> </li> <li> <p>| <code>RPAREN</code>: <code>\\)</code>     | Represents the right parenthesis <code>)</code>.</p> </li> <li> <p>| <code>LBRACKET</code>: <code>\\[</code>     | Represents the left bracket <code>[</code>.</p> </li> <li> <p>| <code>RBRACKET</code>: <code>\\]</code>     | Represents the right bracket <code>]</code>.</p> </li> <li> <p>| <code>SEMICOLON</code>: <code>;</code>     | Represents the semicolon <code>;</code>.</p> </li> <li> <p>| <code>STRING_LITERAL</code>: <code>\"[^\"]*\"</code>     | Represents a string literal enclosed in double quotes.</p> </li> <li> <p>| <code>COMMA</code>: <code>,</code>     | Represents the comma <code>,</code>.</p> </li> <li> <p>| <code>COLON</code>: <code>:</code>     | Represents the colon <code>:</code>.</p> </li> <li> <p>| <code>LESS_EQUAL</code>: <code>&lt;=</code>     | Represents the less-than-or-equal-to operator.</p> </li> <li> <p>| <code>GREATER_EQUAL</code>: <code>&gt;=</code>     | Represents the greater-than-or-equal-to operator.</p> </li> <li> <p>| <code>LESS_THAN</code>: <code>&lt;</code>     | Represents the less-than operator.</p> </li> <li> <p>| <code>GREATER_THAN</code>: <code>&gt;</code>     | Represents the greater-than operator.</p> </li> <li> <p>| <code>EQUAL</code>: <code>==</code>     | Represents the equality operator.</p> </li> <li> <p>| <code>NOT_EQUAL</code>: <code>!=</code>     | Represents the inequality operator.</p> </li> <li> <p>| <code>PLUS_EQUALS</code>: <code>+=</code>     | Represents the addition assignment operator.</p> </li> <li> <p>| <code>MINUS_EQUALS</code>: <code>-=</code>     | Represents the subtraction assignment operator.</p> </li> <li> <p>| <code>MULTIPLY_EQUALS</code>: <code>*=</code>     | Represents the multiplication assignment operator.</p> </li> <li> <p>| <code>DIVIDE_EQUALS</code>: <code>/=</code>     | Represents the division assignment operator.</p> </li> <li> <p>| <code>PLUS</code>: <code>+</code>     | Represents the addition operator.</p> </li> <li> <p>| <code>MINUS</code>: <code>-</code>     | Represents the subtraction operator.</p> </li> <li> <p>| <code>MULTIPLY</code>: <code>*</code>     | Represents the multiplication operator.</p> </li> <li> <p>| <code>DIVIDE</code>: <code>/</code>     | Represents the division operator.</p> </li> <li> <p>| <code>AND</code>: <code>&amp;&amp;</code>     | Represents the logical AND operator.</p> </li> <li> <p>| <code>OR</code> : <code>\\|\\|</code>     | Represents the logical OR operator.</p> </li> <li> <p>| <code>DOT</code>: <code>\\.</code>     | Represents the dot <code>.</code> for member access.</p> </li> <li> <p>| <code>EQUALS</code>: <code>=</code>     | Represents the assignment operator.</p> </li> <li> <p>| <code>WHITESPACE</code>: <code>\\s+</code>     | Represents whitespace characters (spaces, tabs, newlines).</p> </li> </ul>"},{"location":"pages/graphica/api_reference/#keywords_1","title":"Keywords","text":"<ul> <li><code>struct</code>: <code>STRUCT</code></li> <li><code>let</code>: <code>LET</code></li> <li><code>var</code>: <code>VAR</code></li> <li><code>fn</code>: <code>FN</code></li> <li><code>return</code>: <code>RETURN</code></li> <li><code>if</code>: <code>IF</code></li> <li><code>else</code>: <code>ELSE</code></li> <li><code>for</code>: <code>FOR</code></li> <li><code>while</code>: <code>WHILE</code></li> <li><code>import</code>: <code>IMPORT</code></li> <li><code>def</code>: <code>DEF</code></li> <li><code>Int</code>: <code>INT</code></li> <li><code>Float</code>: <code>FLOAT</code></li> <li><code>Bool</code>: <code>BOOL</code></li> <li><code>String</code>: <code>STRING</code></li> </ul> <p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#tokenize-method_1","title":"Tokenize Method","text":"<p>| Description: | Tokenizes the input code into a list of tokens based on predefined   patterns. It processes each segment of the code to match against the   token patterns and converts identifiers to keywords if applicable.</p> <p>| Parameters: | - None</p> <p>| Returns: | - None</p> <p>| Method Details:</p> <ul> <li>Initializes the token position to zero and iterates through the     code.</li> <li>For each position, attempts to match the code segment with     predefined regex patterns.</li> <li>If a match is found, determines the token type:<ul> <li>Converts [IDENTIFIER]{.title-ref} tokens to keywords if they     match predefined keywords.</li> <li>Skips tokens of types [WHITESPACE]{.title-ref},     [COMMENT_SINGLE]{.title-ref}, and [COMMENT_MULTI]{.title-ref}.</li> <li>Appends other tokens to the [tokens]{.title-ref} list.</li> </ul> </li> <li>Moves the position index forward by the length of the matched text.</li> <li>Raises a [SyntaxError]{.title-ref} if an illegal character is     encountered.</li> <li>Appends an [EOF]{.title-ref} (end-of-file) token at the end of the     code.</li> </ul>"},{"location":"pages/graphica/api_reference/#mojo-parser","title":"Mojo Parser","text":"<p>Methods</p> <p>Initializes the code generator.</p>"},{"location":"pages/graphica/api_reference/#eat_2","title":"eat","text":"<ul> <li>Description:<ul> <li>Consumes the current token if it matches the expected type.</li> <li>Advances to the next token and skips any comments following the     current token.</li> </ul> </li> <li>Parameters:<ul> <li>`token_type`: The type of token expected to be consumed.</li> </ul> </li> <li>Returns:<ul> <li>None</li> </ul> </li> <li>Raises:<ul> <li>`SyntaxError`: If the current token does not match the     expected token type.</li> </ul> </li> </ul>"},{"location":"pages/graphica/api_reference/#skip_commentsself_1","title":"skip_comments(self)","text":"<p>| Description: | Skips over single-line and multi-line comments in the token stream by   advancing past them.</p> <p>| Parameters: | - None</p> <p>| Returns: | - None</p> <p>| Raises: | - None</p>"},{"location":"pages/graphica/api_reference/#parse-method_1","title":"parse Method","text":"<p>| Description: | Parses the entire code to generate an abstract syntax tree (AST)   representation. It starts by parsing the module and ensures the end of   the file is reached.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `module`: The parsed module, which is an AST representation of the   code.</p> <p>| Method Details: | - Calls [parse_module]{.title-ref} to parse the module's structure   from the code. - Calls eat to ensure that the end-of-file (EOF) token   is present and correctly positioned. - Returns the parsed module.</p>"},{"location":"pages/graphica/api_reference/#parse_module-method","title":"parse_module Method","text":"<p>| Description: | Parses the module to extract statements and constructs an abstract   syntax tree (AST). It handles different types of statements, including   imports, structures, classes, constant buffers, functions, variable   declarations or assignments, and decorators.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ShaderNode`: An instance of [ShaderNode]{.title-ref} containing   the list of parsed statements.</p> <p>| Method Details:</p> <ul> <li>Iterates through tokens until the end-of-file (EOF) token is     encountered.</li> <li>Handles each type of statement based on the current token type:<ul> <li>IMPORT: Calls [parse_import_statement]{.title-ref} to parse     import statements.</li> <li>STRUCT: Calls [parse_struct]{.title-ref} to parse structure     definitions.</li> <li>CLASS: Calls [parse_class]{.title-ref} to parse class     definitions.</li> <li>CONSTANT: Calls [parse_constant_buffer]{.title-ref} to parse     constant buffer declarations.</li> <li>FN: Calls [parse_function]{.title-ref} to parse function     definitions.</li> <li>LET, VAR: Calls     [parse_variable_declaration_or_assignment]{.title-ref} to parse     variable declarations or assignments.</li> <li>DECORATOR: Calls [parse_decorator]{.title-ref} to parse     decorator statements.</li> </ul> </li> <li>Uses [eat]{.title-ref} to consume and process the current token.</li> <li>Returns a [ShaderNode]{.title-ref} instance containing all parsed     statements.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_import_statement-method","title":"parse_import_statement Method","text":"<p>| Description: | Parses an import statement from the source code and constructs an   [ImportNode]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ImportNode`: An instance with the module name and optional alias.</p> <p>| Method Details:</p> <ul> <li>Consumes the [\\\"IMPORT\\\"]{.title-ref} token.</li> <li>Extracts the module name from the [\\\"IDENTIFIER\\\"]{.title-ref}     token.</li> <li>Optionally handles the [\\\"AS\\\"]{.title-ref} keyword to set an alias.</li> <li>Consumes the [\\\"SEMICOLON\\\"]{.title-ref} token if present.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_struct-method","title":"parse_struct Method","text":"<p>| Description: | Parses a [struct]{.title-ref} definition from the source code and   constructs a [StructNode]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `StructNode`: An instance with the struct's name and its members.</p> <p>| Method Details:</p> <ul> <li>Consumes the [\\\"STRUCT\\\"]{.title-ref} token.</li> <li>Extracts the struct name from the [\\\"IDENTIFIER\\\"]{.title-ref}     token.</li> <li>Consumes the [\\\"COLON\\\"]{.title-ref} token.</li> <li>Iterates over subsequent tokens to parse member variables, handling     optional type declarations and attributes.</li> <li>Stops parsing members upon encountering [\\\"EOF\\\"]{.title-ref},     [\\\"FN\\\"]{.title-ref}, [\\\"STRUCT\\\"]{.title-ref}, or     [\\\"CLASS\\\"]{.title-ref} tokens.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_class-method","title":"parse_class Method","text":"<p>| Description: | Parses a [class]{.title-ref} definition from the source code and   constructs a [ClassNode]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ClassNode`: An instance representing the class with its name,   base classes, and members.</p> <p>| Method Details:</p> <ul> <li>Consumes the [\\\"CLASS\\\"]{.title-ref} token.</li> <li>Extracts the class name from the [\\\"IDENTIFIER\\\"]{.title-ref} token.</li> <li>Parses optional base classes enclosed in parentheses.</li> <li>Consumes the [\\\"LBRACE\\\"]{.title-ref} token.</li> <li>Iterates over tokens to parse class members, including functions,     variable declarations, or nested classes.</li> <li>Stops parsing members upon encountering the [\\\"RBRACE\\\"]{.title-ref}     token.</li> <li>Constructs and returns a [ClassNode]{.title-ref} with the parsed     name, base classes, and members.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_constant_buffer-method","title":"parse_constant_buffer Method","text":"<p>| Description: | Parses a constant buffer definition from the source code and   constructs a [ConstantBufferNode]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ConstantBufferNode`: An instance representing the constant buffer   with its name and members.</p> <p>| Method Details:</p> <ul> <li>Consumes the [\\\"CONSTANT\\\"]{.title-ref} token.</li> <li>Extracts the constant buffer name from the     [\\\"IDENTIFIER\\\"]{.title-ref} token.</li> <li>Consumes the [\\\"LBRACE\\\"]{.title-ref} token.</li> <li>Iterates over tokens to parse the members of the constant buffer,     extracting the variable type and name, and consuming the     [\\\"SEMICOLON\\\"]{.title-ref} token.</li> <li>Stops parsing members upon encountering the [\\\"RBRACE\\\"]{.title-ref}     token.</li> <li>Constructs and returns a [ConstantBufferNode]{.title-ref} with the     parsed name and members.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_function-method_1","title":"parse_function Method","text":"<p>| Description: | Parses a function definition from the source code and constructs a   [FunctionNode]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `FunctionNode`: An instance representing the parsed function,   including its attributes, return type, name, parameters, body, and   additional attributes.</p> <p>| Method Details:</p> <ul> <li>Parses function attributes using     [self.parse_attributes()]{.title-ref}.</li> <li>Checks for and consumes the [\\\"FN\\\"]{.title-ref} token, setting the     function's qualifier if present.</li> <li>Extracts the function name from the [\\\"IDENTIFIER\\\"]{.title-ref}     token.</li> <li>Consumes the [\\\"LPAREN\\\"]{.title-ref} token and parses function     parameters using [self.parse_parameters()]{.title-ref}.</li> <li>Consumes the [\\\"RPAREN\\\"]{.title-ref} token.</li> <li>Checks for and consumes the [\\\"MINUS\\\"]{.title-ref} and     [\\\"GREATER_THAN\\\"]{.title-ref} tokens to parse the return type if     specified.</li> <li>Parses additional attributes after the return type.</li> <li>Parses the function body using [self.parse_block()]{.title-ref}.</li> <li>Constructs and returns a [FunctionNode]{.title-ref} with the parsed     information.</li> </ul>"},{"location":"pages/graphica/api_reference/#parse_parameters-method_1","title":"parse_parameters Method","text":"<p>| Description: | Parses the parameter list for a function definition from the source   code, handling type annotations and attributes.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `List[VariableNode][: A list of `VariableNode]{.title-ref}   instances representing the parameters, including their types, names,   and attributes.</p> <p>| Method Details:</p> <ul> <li>Initializes an empty list [params]{.title-ref} to store parsed     parameters.</li> <li>Iterates through tokens until it encounters a [RPAREN]{.title-ref}     token (end of parameter list).</li> <li>Attributes: Calls [self.parse_attributes()]{.title-ref} to parse     any attributes associated with the parameter.</li> <li>Type Handling: Checks if the current token is a valid type     ([FLOAT]{.title-ref}, [INT]{.title-ref}, [UINT]{.title-ref},     [BOOL]{.title-ref}, [IDENTIFIER]{.title-ref}):<ul> <li>Extracts the type and handles optional type annotations     indicated by a [COLON]{.title-ref} token.</li> <li>Retrieves the parameter name from the [IDENTIFIER]{.title-ref}     token if present.</li> <li>Parses and appends attributes specific to the parameter.</li> <li>Creates and adds a [VariableNode]{.title-ref} to the     [params]{.title-ref} list.</li> </ul> </li> <li>Comma Handling: Ensures commas are correctly placed and raises     an error for trailing commas.</li> <li>Error Handling: Raises [SyntaxError]{.title-ref} for unexpected     tokens or incorrect syntax in the parameter list.</li> </ul> <p>| Errors Raised: | - [SyntaxError]{.title-ref} for unexpected tokens, trailing commas, or   incorrect syntax in the parameter list.</p>"},{"location":"pages/graphica/api_reference/#parse_attributes-method","title":"parse_attributes Method","text":"<p>| Description: | Parses a sequence of attribute tokens from the source code, extracting   their names and arguments.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `List[AttributeNode][: A list of `AttributeNode]{.title-ref}   instances representing the parsed attributes.</p> <p>| Method Details:</p> <ul> <li>Initializes an empty list [attributes]{.title-ref} to store parsed     attributes.</li> <li>Continuously checks if the current token is of type     [ATTRIBUTE]{.title-ref}.</li> <li>Attribute Content: Strips the surrounding [[[]{.title-ref} and     []]]{.title-ref} from the attribute content to extract the core     information.</li> <li>Parsing Attributes: Splits the content by [(]{.title-ref} to     separate the attribute name from its arguments:<ul> <li>Name Extraction: The part before [(]{.title-ref} is the     attribute name.</li> <li>Arguments Extraction: The part inside the parentheses is     split by commas to get a list of arguments.</li> </ul> </li> <li>Creating AttributeNode: Creates an [AttributeNode]{.title-ref}     instance with the name and arguments, and appends it to the     [attributes]{.title-ref} list.</li> <li>Consuming Token: Calls [self.eat(\\\"ATTRIBUTE\\\")]{.title-ref} to     advance to the next token.</li> </ul> <p>| Errors Raised: | - No specific errors are raised by this method. It assumes attributes   are well-formed according to the defined token patterns.</p>"},{"location":"pages/graphica/api_reference/#parse_block-method","title":"parse_block Method","text":"<p>| Description: | Parses a block of statements, which can start with either a colon or   an opening brace, and continues until it encounters a closing brace or   the end of the file.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `List[StatementNode][: A list of `StatementNode]{.title-ref}   instances representing the parsed statements within the block.</p> <p>| Method Details:</p> <ol> <li>Block Start:<ul> <li>Colon (`:`) or Brace (`{`):<ul> <li>If the current token is [COLON]{.title-ref}, it is consumed     to denote the start of the block.</li> <li>If the current token is [LBRACE]{.title-ref}, it is consumed     to denote the start of the block.</li> <li>Raises a [SyntaxError]{.title-ref} if neither     [COLON]{.title-ref} nor [LBRACE]{.title-ref} is found.</li> </ul> </li> </ul> </li> <li>Parsing Statements:<ul> <li>Initializes an empty list [statements]{.title-ref} to store the     parsed statements.</li> <li>Continues to parse statements until encountering     [RBRACE]{.title-ref} or [EOF]{.title-ref}.</li> </ul> </li> <li>Block End:<ul> <li>`Closing Brace (`}`):` If a closing brace is     encountered, it is consumed to denote the end of the block.</li> </ul> </li> <li>Return Statements:<ul> <li>Returns the list of parsed statements.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Raised if the block does not start with a   [COLON]{.title-ref} or [LBRACE]{.title-ref}, or if unexpected tokens   are found while parsing statements.</p>"},{"location":"pages/graphica/api_reference/#parse_statement-method_1","title":"parse_statement Method","text":"<p>| Description: | Parses a single statement from the input code. The type of statement   to be parsed is determined based on the current token.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `StatementNode`: The parsed statement, which can be one of several   types including variable declarations, function definitions, control   flow statements, or expressions.</p> <p>| Method Details: | 1. Variable Declarations or Assignments: - Token Types:   [FLOAT]{.title-ref}, [INT]{.title-ref}, [UINT]{.title-ref},   [BOOL]{.title-ref}, [IDENTIFIER]{.title-ref}, [LET]{.title-ref},   [VAR]{.title-ref} - Calls   [parse_variable_declaration_or_assignment]{.title-ref} to handle   variable-related statements.</p> <ol> <li>Function Definitions:<ul> <li>`Token Type:` [FN]{.title-ref}</li> <li>Calls [parse_function]{.title-ref} to handle function     definitions.</li> </ul> </li> <li>Control Flow Statements:<ul> <li>`If Statements:` Token type [IF]{.title-ref}<ul> <li>Calls [parse_if_statement]{.title-ref} to handle     [if]{.title-ref} statements.</li> </ul> </li> <li>For Loops: Token type [FOR]{.title-ref}<ul> <li>Calls [parse_for_statement]{.title-ref} to handle     [for]{.title-ref} loops.</li> </ul> </li> <li>While Loops: Token type [WHILE]{.title-ref}<ul> <li>Calls [parse_while_statement]{.title-ref} to handle     [while]{.title-ref} loops.</li> </ul> </li> <li>Switch Statements: Token type [SWITCH]{.title-ref}<ul> <li>Calls [parse_switch_statement]{.title-ref} to handle     [switch]{.title-ref} statements.</li> </ul> </li> </ul> </li> <li>Return Statements:<ul> <li>Token Type: [RETURN]{.title-ref}</li> <li>Calls [parse_return_statement]{.title-ref} to handle return     statements.</li> </ul> </li> <li>Structures:<ul> <li>Token Type: [STRUCT]{.title-ref}</li> <li>Calls parse_struct to handle [struct]{.title-ref} definitions.</li> </ul> </li> <li>Expression Statements:<ul> <li>`Fallback:` If none of the above tokens are matched, it     defaults to [parse_expression_statement]{.title-ref} to handle     any remaining expressions.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but could be   raised by the called methods if there are issues with the statements   being parsed.</p>"},{"location":"pages/graphica/api_reference/#parse_variable_declaration_or_assignment-method","title":"parse_variable_declaration_or_assignment Method","text":"<p>| Description: | Parses either a variable declaration or an assignment statement based   on the current token.</p> <p>| Parameters: | - None</p> <p>| Returns: | - [VariableDeclarationNode]{.title-ref} or `AssignmentNode`: Returns   a node representing either a variable declaration with an optional   initial value or an assignment statement.</p> <p>| Method Details:</p> <ol> <li>Variable Declaration:<ul> <li>Token Types: [LET]{.title-ref}, [VAR]{.title-ref}</li> <li>Process:<ul> <li>Type: Determines the variable type from the token     ([LET]{.title-ref} or [VAR]{.title-ref}).</li> <li>Name: Extracts the variable name from the next     [IDENTIFIER]{.title-ref} token.</li> <li>Type Annotation (Optional): If a [COLON]{.title-ref} is     present, it indicates a type annotation, which is processed     but not used further.</li> <li>Initial Value (Optional): If an [EQUALS]{.title-ref}     token is present, it indicates the start of an initial value     expression. The expression is parsed and assigned to the     variable.</li> <li>Semicolon (Optional): Consumes the     [SEMICOLON]{.title-ref} if it is present, marking the end of     the statement.</li> </ul> </li> </ul> </li> <li>Assignment:<ul> <li>`Fallback:` If the current token does not indicate a     variable declaration, it defaults to     [parse_assignment]{.title-ref} to handle assignment statements.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but may be   raised by [parse_expression]{.title-ref} or   [parse_assignment]{.title-ref} if there are issues with the provided   expressions or assignments.</p>"},{"location":"pages/graphica/api_reference/#parse_if_statement-method","title":"parse_if_statement Method","text":"<p>| Description: | Parses an [if]{.title-ref} statement, including its optional   [else]{.title-ref} block.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `IfNode`: Returns a node representing the parsed [if]{.title-ref}   statement, including its condition, [if]{.title-ref} body, and   optional [else]{.title-ref} body.</p> <p>| Method Details:</p> <ol> <li>Start Parsing:<ul> <li>Token Type: [IF]{.title-ref}<ul> <li>Process: Consumes the [IF]{.title-ref} token to identify     the start of the [if]{.title-ref} statement.</li> </ul> </li> <li>Left Parenthesis: [LPAREN]{.title-ref}<ul> <li>Process: Consumes the [LPAREN]{.title-ref} token to     start the condition expression.</li> </ul> </li> <li>Condition Expression:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse     the condition of the [if]{.title-ref} statement.</li> </ul> </li> <li>Right Parenthesis: [RPAREN]{.title-ref}<ul> <li>Process: Consumes the [RPAREN]{.title-ref} token to     close the condition expression.</li> </ul> </li> <li>If Block:<ul> <li>Method: Calls [parse_block]{.title-ref} to parse the     block of statements that execute if the condition is true.</li> </ul> </li> </ul> </li> <li>Optional Else Block:<ul> <li>Token Type: [ELSE]{.title-ref}<ul> <li>`Process:` If the next token is [ELSE]{.title-ref}, it     is consumed and the [else]{.title-ref} block is parsed using     [parse_block]{.title-ref}.</li> </ul> </li> </ul> </li> <li>Return Statement:<ul> <li>Returns: An [IfNode]{.title-ref} object with the condition,     [if]{.title-ref} body, and optionally the [else]{.title-ref}     body.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but may be   triggered by [parse_expression]{.title-ref} or   [parse_block]{.title-ref} if there are issues with the syntax.</p>"},{"location":"pages/graphica/api_reference/#parse_for_statement-method","title":"parse_for_statement Method","text":"<p>| Description: | Parses a [for]{.title-ref} loop statement, including initialization,   condition, update, and loop body.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ForNode`: Returns a node representing the parsed   [for]{.title-ref} loop statement, including its initialization,   condition, update expression, and body.</p> <p>| Method Details:</p> <ol> <li>Start Parsing:<ul> <li>Token Type: [FOR]{.title-ref}<ul> <li>Process: Consumes the [FOR]{.title-ref} token to     identify the start of the [for]{.title-ref} loop statement.</li> </ul> </li> <li>Left Parenthesis: [LPAREN]{.title-ref}<ul> <li>Process: Consumes the [LPAREN]{.title-ref} token to     start parsing the [for]{.title-ref} loop components.</li> </ul> </li> </ul> </li> <li>Initialization:<ul> <li>Method: Calls     [parse_variable_declaration_or_assignment]{.title-ref} to parse     the initialization expression of the loop (e.g., variable     declarations or assignments).</li> <li>Token Type: [SEMICOLON]{.title-ref}<ul> <li>Process: Consumes the [SEMICOLON]{.title-ref} token to     separate initialization from the loop condition.</li> </ul> </li> </ul> </li> <li>Condition:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse the     loop condition.</li> <li>Token Type: [SEMICOLON]{.title-ref}<ul> <li>Process: Consumes the [SEMICOLON]{.title-ref} token to     separate the condition from the update expression.</li> </ul> </li> </ul> </li> <li>Update:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse the     update expression (e.g., increment or decrement).</li> <li>Token Type: [RPAREN]{.title-ref}<ul> <li>Process: Consumes the [RPAREN]{.title-ref} token to     close the [for]{.title-ref} loop header.</li> </ul> </li> </ul> </li> <li>Body:<ul> <li>Method: Calls [parse_block]{.title-ref} to parse the block     of statements that execute during each iteration of the loop.</li> </ul> </li> <li>Return Statement:<ul> <li>Returns: A [ForNode]{.title-ref} object with initialization,     condition, update expression, and body.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but may be   triggered by [parse_variable_declaration_or_assignment]{.title-ref},   [parse_expression]{.title-ref}, or [parse_block]{.title-ref} if there   are issues with the syntax.</p>"},{"location":"pages/graphica/api_reference/#parse_while_statement-method","title":"parse_while_statement Method","text":"<p>| Description: | Parses a [while]{.title-ref} loop statement, including its condition   and loop body.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `WhileNode`: Returns a node representing the parsed   [while]{.title-ref} loop statement, including its condition and body.</p> <p>Method Details:</p> <ol> <li>Start Parsing:<ul> <li>Token Type: [WHILE]{.title-ref}<ul> <li>Process: Consumes the [WHILE]{.title-ref} token to     identify the start of the [while]{.title-ref} loop     statement.</li> </ul> </li> <li>Left Parenthesis: [LPAREN]{.title-ref}<ul> <li>Process: Consumes the [LPAREN]{.title-ref} token to     start parsing the loop condition.</li> </ul> </li> </ul> </li> <li>Condition:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse the     loop condition (the expression that controls the loop's     execution).</li> <li>Token Type: [RPAREN]{.title-ref}<ul> <li>Process: Consumes the [RPAREN]{.title-ref} token to     close the condition.</li> </ul> </li> </ul> </li> <li>Body:<ul> <li>Method: Calls [parse_block]{.title-ref} to parse the block     of statements that execute as long as the condition is true.</li> </ul> </li> <li>Return Statement:<ul> <li>Returns: A [WhileNode]{.title-ref} object with the condition     and body of the [while]{.title-ref} loop.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but may be   triggered by [parse_expression]{.title-ref} or   [parse_block]{.title-ref} if there are syntax issues.</p>"},{"location":"pages/graphica/api_reference/#parse_switch_statementtitle-ref-method","title":"[parse_switch_statement]{.title-ref} Method","text":"<p>| Description: | Parses a [switch]{.title-ref} statement, including its expression and   cases.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `SwitchNode`: Returns a node representing the parsed   [switch]{.title-ref} statement, including its expression and cases.</p> <p>| Method Details:</p> <ol> <li>Start Parsing:<ul> <li>Token Type: [SWITCH]{.title-ref}<ul> <li>Process: Consumes the [SWITCH]{.title-ref} token to     identify the start of the [switch]{.title-ref} statement.</li> </ul> </li> <li>Left Parenthesis: [LPAREN]{.title-ref}<ul> <li>Process: Consumes the [LPAREN]{.title-ref} token to     begin parsing the [switch]{.title-ref} expression.</li> </ul> </li> </ul> </li> <li>Expression:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse the     expression that the [switch]{.title-ref} statement evaluates.</li> <li>Token Type: [RPAREN]{.title-ref}<ul> <li>Process: Consumes the [RPAREN]{.title-ref} token to     close the expression.</li> </ul> </li> </ul> </li> <li>Block:<ul> <li>Left Brace: [LBRACE]{.title-ref}<ul> <li>Process: Consumes the [LBRACE]{.title-ref} token to     start parsing the block of cases.</li> </ul> </li> </ul> </li> <li>Cases:<ul> <li>Method: Calls [parse_switch_case]{.title-ref} to parse each     case within the [switch]{.title-ref} block.</li> <li>Loop: Continues to parse cases until encountering a     [RBRACE]{.title-ref} token.</li> </ul> </li> <li>End of Block:<ul> <li>Right Brace: [RBRACE]{.title-ref}<ul> <li>Process: Consumes the [RBRACE]{.title-ref} token to     close the [switch]{.title-ref} block.</li> </ul> </li> </ul> </li> <li>Return Statement:<ul> <li>Returns: A [SwitchNode]{.title-ref} object with the     [switch]{.title-ref} expression and a list of cases.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: Not directly raised in this method but may be   triggered by [parse_expression]{.title-ref} or   [parse_switch_case]{.title-ref} if there are syntax issues.</p>"},{"location":"pages/graphica/api_reference/#parse_switch_case-method","title":"parse_switch_case Method","text":"<p>| Description: | Parses a [case]{.title-ref} or [default]{.title-ref} branch within a   [switch]{.title-ref} statement.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `SwitchCaseNode`: Returns a node representing the parsed   [case]{.title-ref} or [default]{.title-ref} branch, including its   condition (if applicable) and block of statements.</p> <p>| Method Details:</p> <ol> <li>Case Branch:<ul> <li>Token Type: [CASE]{.title-ref}<ul> <li>Process: Consumes the [CASE]{.title-ref} token to start     parsing a [case]{.title-ref} branch.</li> </ul> </li> <li>Expression:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse     the condition for the [case]{.title-ref}.</li> </ul> </li> <li>Colon: [COLON]{.title-ref}<ul> <li>Process: Consumes the [COLON]{.title-ref} token to     separate the condition from the block of statements.</li> </ul> </li> <li>Block:<ul> <li>Method: Calls [parse_block]{.title-ref} to parse the     statements that follow the [case]{.title-ref} condition.</li> </ul> </li> </ul> </li> <li>Default Branch:<ul> <li>Token Type: [DEFAULT]{.title-ref}<ul> <li>Process: Consumes the [DEFAULT]{.title-ref} token to     start parsing the default branch.</li> </ul> </li> <li>Colon: [COLON]{.title-ref}<ul> <li>Process: Consumes the [COLON]{.title-ref} token to     separate the [default]{.title-ref} from the block of     statements.</li> </ul> </li> <li>Block:<ul> <li>Method: Calls [parse_block]{.title-ref} to parse the     statements that follow the [default]{.title-ref} keyword.</li> </ul> </li> </ul> </li> <li>Error Handling:<ul> <li>SyntaxError: Raises an error if the token does not match     [CASE]{.title-ref} or [DEFAULT]{.title-ref}.</li> </ul> </li> </ol> <p>| Errors Raised: | - `SyntaxError`: If the token is not [CASE]{.title-ref} or   [DEFAULT]{.title-ref}.</p>"},{"location":"pages/graphica/api_reference/#parse_return_statementtitle-ref-method","title":"[parse_return_statement]{.title-ref} Method","text":"<p>| Description: | Parses a [return]{.title-ref} statement within a function, which   specifies the value to be returned.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ReturnNode`: Returns a node representing the [return]{.title-ref}   statement, including the value to be returned.</p> <p>| Method Details: | 1. Return Keyword: - Token Type: [RETURN]{.title-ref} -   Process: Consumes the [RETURN]{.title-ref} token to start parsing   the return statement.</p> <ol> <li>Expression:<ul> <li>Method: Calls [parse_expression]{.title-ref} to parse the     value or expression to be returned.</li> </ul> </li> <li>Semicolon:<ul> <li>Token Type: [SEMICOLON]{.title-ref} (optional)<ul> <li>Process: Consumes the [SEMICOLON]{.title-ref} token if     present to terminate the return statement.</li> </ul> </li> </ul> </li> </ol>"},{"location":"pages/graphica/api_reference/#parse_expression_statement-method","title":"parse_expression_statement Method","text":"<p>| Description: | Parses an expression statement, which consists of a single expression   followed by a semicolon.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `ExpressionNode`: Returns the parsed expression node.</p> <p>| Method Details: | 1. Expression: - Method: Calls [parse_expression]{.title-ref}   to parse the expression part of the statement.</p> <ol> <li>Semicolon:<ul> <li>Token Type: [SEMICOLON]{.title-ref}<ul> <li>Process: Consumes the [SEMICOLON]{.title-ref} token to     complete the statement.</li> </ul> </li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: If the [SEMICOLON]{.title-ref} token is not present   after the expression.</p>"},{"location":"pages/graphica/api_reference/#parse_expression-method_1","title":"parse_expression Method","text":"<p>| Description: | Parses an expression, which can be an assignment or other types of   expressions depending on the implementation of   [parse_assignment]{.title-ref}.</p> <p>| Parameters: | - None</p> <p>| Returns: | - [AssignmentNode]{.title-ref} or other expression node types: Returns   the result of parsing an assignment or expression.</p> <p>| Method Details: | 1. Delegation: - Method: Calls [parse_assignment]{.title-ref}   to handle the parsing of assignments and potentially other   expressions.</p> <p>| Errors Raised: | - SyntaxError: Depending on the implementation of   [parse_assignment]{.title-ref}, it may raise errors related to invalid   syntax or tokens.</p>"},{"location":"pages/graphica/api_reference/#parse_assignment-method_1","title":"parse_assignment Method","text":"<p>| Description: | Parses an assignment expression, including assignments with compound   operators and ternary conditional expressions.</p> <p>| Parameters: | - None</p> <p>| Returns: | - [AssignmentNode]{.title-ref} or `TernaryOpNode`: Returns an   [AssignmentNode]{.title-ref} if an assignment is parsed, or a   [TernaryOpNode]{.title-ref} if a ternary operation is detected.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Starts by parsing the left-hand   side of the assignment using [parse_logical_or]{.title-ref}.</p> <ol> <li>Assignment Operators Handling:<ul> <li>Condition: Checks for assignment operators     ([EQUALS]{.title-ref}, [PLUS_EQUALS]{.title-ref},     [MINUS_EQUALS]{.title-ref}, [MULTIPLY_EQUALS]{.title-ref},     [DIVIDE_EQUALS]{.title-ref}).</li> <li>Action: If an assignment operator is found, it captures the     operator and parses the right-hand side recursively.</li> <li>Return: Returns an [AssignmentNode]{.title-ref} that     encapsulates the left-hand side, right-hand side, and operator.</li> </ul> </li> <li>Ternary Conditional Expressions Handling:<ul> <li>Condition: If a ternary operator ([QUESTION]{.title-ref}) is     found after the initial left-hand side parsing.</li> <li>Action: Parses the true and false branches of the ternary     expression.</li> <li>Return: Returns a [TernaryOpNode]{.title-ref} if a ternary     operation is detected.</li> </ul> </li> <li>Fallback:<ul> <li>Return: Returns the parsed left-hand side if no assignment     or ternary operation is found.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors during parsing if unexpected   tokens are encountered.</p>"},{"location":"pages/graphica/api_reference/#parse_logical_or-method","title":"parse_logical_or Method","text":"<p>| Description: | Parses logical OR expressions, handling multiple chained OR   operations.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the logical OR expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the OR expression using [parse_logical_and]{.title-ref}.</p> <ol> <li>Chained OR Handling:<ul> <li>Condition: Checks if the current token is an     [OR]{.title-ref} operator.</li> <li>Action: If an [OR]{.title-ref} operator is found, it     captures the operator, then parses the right-hand side of the OR     expression using [parse_logical_and]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the     [OR]{.title-ref} operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Repeats the process to handle additional chained OR     operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the logical OR expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_logical_and-method","title":"parse_logical_and Method","text":"<p>| Description: | Parses logical AND expressions, handling multiple chained AND   operations.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the logical AND expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the AND expression using [parse_equality]{.title-ref}.</p> <ol> <li>Chained AND Handling:<ul> <li>Condition: Checks if the current token is an     [AND]{.title-ref} operator.</li> <li>Action: If an [AND]{.title-ref} operator is found, it     captures the operator, then parses the right-hand side of the     AND expression using [parse_equality]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the     [AND]{.title-ref} operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Repeats the process to handle additional chained AND     operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the logical AND expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_equality-method","title":"parse_equality Method","text":"<p>| Description: | Parses equality expressions, handling both equality ([==]{.title-ref})   and inequality ([!=]{.title-ref}) operations.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the equality or inequality expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the equality expression using [parse_relational]{.title-ref}.</p> <ol> <li>Chained Equality Handling:<ul> <li>Condition: Checks if the current token represents an     equality ([==]{.title-ref}) or inequality ([!=]{.title-ref})     operator.</li> <li>Action: If such an operator is found, it captures the     operator, then parses the right-hand side of the equality     expression using [parse_relational]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the equality or     inequality operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Continues to handle additional chained equality or     inequality operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the equality or inequality expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_relational-method","title":"parse_relational Method","text":"<p>| Description: | Parses relational expressions, handling operations such as less than   ([\\&lt;]{.title-ref}), greater than ([&gt;]{.title-ref}), less than or   equal to ([\\&lt;=]{.title-ref}), and greater than or equal to   ([&gt;=]{.title-ref}).</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the relational expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the relational expression using [parse_additive]{.title-ref}.</p> <ol> <li>Chained Relational Handling:<ul> <li>Condition: Checks if the current token represents a     relational operator ([\\&lt;]{.title-ref}, [&gt;]{.title-ref},     [\\&lt;=]{.title-ref}, [&gt;=]{.title-ref}).</li> <li>Action: If such an operator is found, it captures the     operator, then parses the right-hand side of the relational     expression using [parse_additive]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the relational     operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Continues to handle additional chained relational     operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the relational expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_additive-method_1","title":"parse_additive Method","text":"<p>| Description: | Parses additive expressions, handling addition ([+]{.title-ref}) and   subtraction ([-]{.title-ref}) operations.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the additive expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the additive expression using   [parse_multiplicative]{.title-ref}.</p> <ol> <li>Chained Additive Handling:<ul> <li>Condition: Checks if the current token represents an     additive operator ([+]{.title-ref}, [-]{.title-ref}).</li> <li>Action: If such an operator is found, it captures the     operator, then parses the right-hand side of the additive     expression using [parse_multiplicative]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the additive     operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Continues to handle additional chained additive     operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the additive expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_multiplicative-method_1","title":"parse_multiplicative Method","text":"<p>| Description: | Parses multiplicative expressions, handling multiplication   ([*]{.title-ref}) and division ([/]{.title-ref}) operations.</p> <p>| Parameters: | - None</p> <p>| Returns: | - `BinaryOpNode`: Returns a [BinaryOpNode]{.title-ref} representing   the multiplicative expression.</p> <p>| Method Details: | 1. Initial Parsing: - Method: Begins by parsing the left-hand   side of the multiplicative expression using [parse_unary]{.title-ref}.</p> <ol> <li>Chained Multiplicative Handling:<ul> <li>Condition: Checks if the current token represents a     multiplicative operator ([*]{.title-ref}, [/]{.title-ref}).</li> <li>Action: If such an operator is found, it captures the     operator, then parses the right-hand side of the multiplicative     expression using [parse_unary]{.title-ref}.</li> <li>Update: Updates the [left]{.title-ref} operand to a     [BinaryOpNode]{.title-ref} that combines the current     [left]{.title-ref} and [right]{.title-ref} with the     multiplicative operator.</li> </ul> </li> <li>Loop:<ul> <li>Action: Continues to handle additional chained     multiplicative operators, if present.</li> </ul> </li> <li>Return:<ul> <li>Return: Returns the final [BinaryOpNode]{.title-ref}     representing the multiplicative expression.</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_unary-method","title":"parse_unary Method","text":"<p>| Description: | Parses unary operations, such as unary plus ([+]{.title-ref}) and   unary minus ([-]{.title-ref}), and delegates to   [parse_primary]{.title-ref} for other expressions.</p> <p>| Parameters: | - None</p> <p>| Returns: | - [UnaryOpNode]{.title-ref} or result of `parse_primary`: Returns a   [UnaryOpNode]{.title-ref} for unary operations or the result of   [parse_primary]{.title-ref} for other expressions.</p> <p>| Method Details: | 1. Unary Operation Handling: - Condition: Checks if the   current token represents a unary operator ([+]{.title-ref},   [-]{.title-ref}). - Action: If a unary operator is found, it   captures the operator and recursively parses the operand using   [parse_unary]{.title-ref}. - Return: Creates and returns a   [UnaryOpNode]{.title-ref} with the captured operator and the parsed   operand.</p> <ol> <li>Primary Expression Handling:<ul> <li>Condition: If no unary operator is present, delegates to     [parse_primary]{.title-ref} to handle the expression.</li> <li>Return: Returns the result of [parse_primary]{.title-ref},     which handles basic expressions (e.g., literals, variables).</li> </ul> </li> </ol> <p>| Errors Raised: | - SyntaxError: May raise errors if unexpected tokens are   encountered, although not explicitly handled in this method.</p>"},{"location":"pages/graphica/api_reference/#parse_primary-method_1","title":"parse_primary Method","text":"<p>| Description: | Parses primary expressions, which include literals, variables, type   annotations, and function calls.</p> <p>| Parameters: | - None</p> <p>| Returns: | - A [VariableNode]{.title-ref}, a literal value, or a parsed function   call or identifier.</p> <p>Method Details:</p> <ol> <li>Literals and Variables:<ul> <li>Condition: Checks if the current token is a literal type     ([INT]{.title-ref}, [FLOAT]{.title-ref}, [BOOL]{.title-ref},     [STRING]{.title-ref}) or [NUMBER]{.title-ref}.<ul> <li>Action:<ul> <li>For literal types, if followed by an     [IDENTIFIER]{.title-ref}, it creates a     [VariableNode]{.title-ref} with optional type     annotation.</li> <li>For [NUMBER]{.title-ref}, it returns the literal value.</li> </ul> </li> <li>Return: Constructs and returns a     [VariableNode]{.title-ref} or literal value.</li> </ul> </li> </ul> </li> <li>Parentheses Handling:<ul> <li>Condition: Checks if the current token is an opening     parenthesis ([LPAREN]{.title-ref}).<ul> <li>Action: If so, it parses the enclosed expression and     expects a closing parenthesis ([RPAREN]{.title-ref}).</li> <li>Return: Returns the parsed expression enclosed by     parentheses.</li> </ul> </li> </ul> </li> <li>Function Calls or Identifiers:<ul> <li>Condition: Handles cases where the current token indicates a     function call or an identifier.<ul> <li>Action: Calls     [parse_function_call_or_identifier]{.title-ref} to parse     further.</li> <li>Return: Result of     [parse_function_call_or_identifier]{.title-ref}.</li> </ul> </li> </ul> </li> <li>Top-Level Keywords:<ul> <li>Condition: If the current token is a top-level keyword     ([FN]{.title-ref}, [STRUCT]{.title-ref}, [CLASS]{.title-ref},     [LET]{.title-ref}, [VAR]{.title-ref}).<ul> <li>Action: Raises a [SyntaxError]{.title-ref} since such     keywords should not appear in expressions.</li> </ul> </li> </ul> </li> <li>Unexpected Tokens:<ul> <li>Condition: Handles any unexpected token.<ul> <li>Action: Raises a [SyntaxError]{.title-ref} for     unexpected tokens in the expression context.</li> </ul> </li> </ul> </li> </ol> <p>Errors Raised: - SyntaxError: Raised for unexpected tokens or top-level keywords encountered in the expression context.</p>"},{"location":"pages/graphica/api_reference/#parse_vector_constructor-method","title":"parse_vector_constructor Method","text":"<p>| Description: | Parses a vector constructor expression from the current token stream.   This typically involves handling a list of expressions enclosed in   parentheses, representing the components of a vector.</p> <p>| Parameters: | - `type_name:` A string representing the type of the vector   (e.g., [vec2]{.title-ref}, [vec3]{.title-ref}).</p> <p>| Returns: | - A [VectorConstructorNode]{.title-ref} instance with the vector type   and its components.</p> <p>Method Details:</p> <ol> <li>Opening Parenthesis:<ul> <li>Condition: Checks if the current token is an opening     parenthesis ([LPAREN]{.title-ref}).</li> <li>Action: Eats the [LPAREN]{.title-ref} token.</li> </ul> </li> <li>Parsing Arguments:<ul> <li>Action: Initializes an empty list [args]{.title-ref} to     store the components of the vector.</li> <li>Loop: While the current token is not a closing parenthesis     ([RPAREN]{.title-ref}):<ul> <li>Action: Parses an expression and appends it to     [args]{.title-ref}.</li> <li>Condition: If a comma ([COMMA]{.title-ref}) follows an     expression, eats the comma.</li> </ul> </li> </ul> </li> <li>Closing Parenthesis:<ul> <li>Condition: Checks if the current token is a closing     parenthesis ([RPAREN]{.title-ref}).</li> <li>Action: Eats the [RPAREN]{.title-ref} token.</li> </ul> </li> <li>Return Statement:<ul> <li>Return: Constructs and returns a     [VectorConstructorNode]{.title-ref} with [type_name]{.title-ref}     and the parsed [args]{.title-ref}.</li> </ul> </li> </ol> <p>Errors Raised: - None: The method assumes correct syntax for vector constructors and handles it accordingly. However, additional error handling may be required if the input is not as expected.</p> <p>parse_function_call Method</p> <ul> <li>Description:<ul> <li>Parses function call expressions from the current token stream.     This involves handling function arguments enclosed in     parentheses.</li> </ul> </li> <li>Parameters:<ul> <li>`name`: The name of the function being called.</li> </ul> </li> <li>Returns:<ul> <li>A [FunctionCallNode]{.title-ref} instance representing the     function call with its arguments.</li> </ul> </li> <li>Method Details:<ol> <li>Opening Parenthesis:<ul> <li>Condition: Checks if the current token is an opening     parenthesis ([LPAREN]{.title-ref}).</li> <li>Action: Eats the [LPAREN]{.title-ref} token.</li> </ul> </li> <li>Parsing Arguments:<ul> <li>Initializes an empty list [args]{.title-ref} to store the     function arguments.</li> <li>While the current token is not a closing parenthesis     ([RPAREN]{.title-ref}):<ul> <li>Parses an expression and appends it to     [args]{.title-ref}.</li> <li>If a comma ([COMMA]{.title-ref}) follows an expression,     eats the comma.</li> </ul> </li> </ul> </li> <li>Closing Parenthesis:<ul> <li>Condition: Checks if the current token is a closing     parenthesis ([RPAREN]{.title-ref}).</li> <li>Action: Eats the [RPAREN]{.title-ref} token.</li> </ul> </li> <li>Return Statement:<ul> <li>Constructs and returns a [FunctionCallNode]{.title-ref} with     the specified [name]{.title-ref} and the parsed     [args]{.title-ref}.</li> </ul> </li> </ol> </li> <li>Errors Raised:<ul> <li>None: The method assumes correct syntax for function calls and     handles it accordingly. Additional error handling may be     required if the input is not as expected.</li> </ul> </li> </ul> <p>parse_member_access Method</p> <ul> <li>Description:<ul> <li>Parses member access expressions from the current token stream.     This involves handling dot notation for accessing object members     (e.g., [object.member]{.title-ref}).</li> </ul> </li> <li>Parameters:<ul> <li>`object`: The object from which the member is accessed.</li> </ul> </li> <li>Returns:<ul> <li>A [MemberAccessNode]{.title-ref} instance representing the     accessed member.</li> </ul> </li> <li>Method Details:<ol> <li>Dot Token:<ul> <li>Condition: Checks if the current token is a dot     ([DOT]{.title-ref}).</li> <li>`Action:` Eats the dot token.</li> </ul> </li> <li>Member Identifier:<ul> <li>Condition: Ensures that the next token is an identifier     ([IDENTIFIER]{.title-ref}).</li> <li>`Action:` Retrieves the member name from the current     token.</li> <li>`Action:` Eats the identifier token.</li> </ul> </li> <li>Function Call Check:<ul> <li>Condition: If the next token is an opening parenthesis     ([LPAREN]{.title-ref}), it indicates a function call.</li> <li>`Action:` Calls the [parse_function_call]{.title-ref}     method with the member name.</li> </ul> </li> <li>Nested Member Access Check:<ul> <li>Condition: If the next token is another dot     ([DOT]{.title-ref}), it indicates nested member access.</li> <li>`Action:` Recursively calls the     [parse_member_access]{.title-ref} method with the updated     [MemberAccessNode]{.title-ref}.</li> </ul> </li> <li>Return Statement:<ul> <li>Constructs and returns a [MemberAccessNode]{.title-ref} with     the specified [object]{.title-ref} and the parsed     [member]{.title-ref}.</li> </ul> </li> </ol> </li> <li>Errors Raised:<ul> <li>None: The method assumes correct syntax for member access and     handles it accordingly. Additional error handling may be     required if the input is not as expected.</li> </ul> </li> </ul> <p>parse_decorator Method</p> <ul> <li>Description:<ul> <li>Parses decorator expressions from the current token stream.     Decorators are typically used in Python to modify or enhance     functions or classes.</li> </ul> </li> <li>Returns:<ul> <li>A [DecoratorNode]{.title-ref} instance representing the     decorator with its name and arguments (if any).</li> </ul> </li> <li>Method Details:<ol> <li>Decorator Token:<ul> <li>Condition: Checks if the current token is a decorator     ([DECORATOR]{.title-ref}).</li> <li>`Action:` Eats the decorator token.</li> </ul> </li> <li>Decorator Name:<ul> <li>Retrieves the decorator name from the current token.</li> </ul> </li> <li>Parsing Arguments (if present):<ul> <li>If the next token is an opening parenthesis     ([LPAREN]{.title-ref}), it indicates decorator arguments.</li> <li>Initializes an empty list [args]{.title-ref} to store the     decorator arguments.</li> <li>While the current token is not a closing parenthesis     ([RPAREN]{.title-ref}):<ul> <li>Parses an expression and appends it to     [args]{.title-ref}.</li> <li>If a comma ([COMMA]{.title-ref}) follows an expression,     eats the comma.</li> </ul> </li> <li>Eats the closing parenthesis ([RPAREN]{.title-ref}).</li> </ul> </li> <li>Return Statement:<ul> <li>Constructs and returns a [DecoratorNode]{.title-ref} with     the specified [name]{.title-ref} and the parsed     [args]{.title-ref}.</li> </ul> </li> </ol> </li> <li>Errors Raised:<ul> <li>None: The method assumes correct syntax for decorators and     handles it accordingly. Additional error handling may be     required if the input is not as expected.</li> </ul> </li> </ul>"},{"location":"pages/graphica/design/","title":"Design","text":"<p>Here we present how the CrossGL ecosystem works!</p> <p></p>"},{"location":"pages/graphica/graphica/","title":"CrossGL Translator \ud83c\udf1f","text":"<p>The <code>Translator</code> is a cornerstone of our platform, expertly bridging the gap between CrossGL shader code and leading graphics APIs like DirectX, Metal, and Vulkan. Whether you're a seasoned developer or just starting out, this tool empowers you to effortlessly translate and deploy shaders across multiple platforms, expanding the versatility and impact of your graphics projects.</p>"},{"location":"pages/graphica/graphica/#getting-started","title":"Getting Started","text":"<p>To begin using CrossGL, you\\'ll need to install its translation library. This is easily done using pip.</p>"},{"location":"pages/graphica/graphica/#installation","title":"Installation","text":"<p>Run the following command to install CrossGL\\'s translation library:</p> <pre><code>pip install crosstl\n</code></pre> <p>Once installed, you\\'re ready to start translating shaders with CrossGL!</p> <ul> <li>Introduction to CrossGL Translator:<ul> <li>A tool that translates CrossGL shader code into different     graphics API languages like DirectX, Metal, and Vulkan.</li> <li>Designed to streamline shader development across multiple     platforms.</li> </ul> </li> <li>Core Features:<ul> <li>Streamlined Shader Conversion: Translates shaders directly into     crosstl languages or IR, bypassing unnecessary steps.</li> <li>Consistent Multi-Platform Support: Unified AST supporting     multiple graphics APIs.</li> <li>Tailored Code Optimization: Optimized code for each target     backend ensuring peak performance.</li> </ul> </li> </ul>"},{"location":"pages/graphica/graphica/#key-features","title":"Key Features\ud83d\udca1","text":"<ul> <li>Streamlined Shader Conversion: Our system translates shaders     directly into crosstl languages or intermediate representations     (IR), bypassing unnecessary steps. This approach simplifies the     process for developers, ensuring efficiency and ease of use.</li> <li>Consistent Multi-Platform Support: With a unified Abstract     Syntax Tree (AST), our platform supports various graphics APIs,     enabling developers to write shaders once and deploy them across     multiple platforms seamlessly.</li> <li>Tailored Code Optimization: The code generated by our system is     highly optimized for each target backend, ensuring that shaders     perform at their best. Whether you're focusing on speed or resource     efficiency, our platform delivers code that's finely tuned for     optimal performance.</li> </ul>"},{"location":"pages/graphica/graphica/#quick-guide-to-translator-structure","title":"Quick Guide to Translator Structure","text":"<p><code>Translator</code> is designed to translate CrossGL shader code into different graphics API languages (e.g., HLSL, Metal, OpenGL). The process involves several key steps, from lexing the input code to generating the final output. Below is a quick guide to the structure and workflow of <code>Translator</code>:</p> <ol> <li> <p>Lexical Analysis (Lexer)</p> <p>Purpose:</p> <ul> <li>Breaks down the input CrossGL shader code into a series of     tokens (lexical units).</li> </ul> <p>Process:</p> <ul> <li>The lexer reads the shader code and identifies keywords,     operators, identifiers, literals, etc.</li> </ul> <p>Example tokens: SHADER, INPUT, OUTPUT, VOID, MAIN, IDENTIFIER, NUMBER, etc.</p> <p>Output:</p> <ul> <li>A list of tokens that represent the structure of the shader     code.</li> </ul> </li> <li> <p>Syntax Analysis (Parser)</p> <p>Purpose:</p> <ul> <li>Analyzes the sequence of tokens and builds a syntactic structure     known as the Abstract Syntax Tree (AST).</li> </ul> <p>Process:</p> <ul> <li>The parser checks the token sequence for grammatical correctness     based on the defined grammar of CrossGL.</li> <li>Constructs the AST nodes such as [ShaderNode]{.title-ref},     [FunctionNode]{.title-ref}, [VariableNode]{.title-ref}, etc.</li> </ul> <p>Output:</p> <ul> <li>An AST that represents the hierarchical structure of the shader     code.</li> </ul> </li> <li> <p>Abstract Syntax Tree (AST) Construction</p> <p>Purpose:</p> <ul> <li>Represents the logical structure of the shader code in a tree     format.</li> </ul> <p>Process:</p> <ul> <li>AST nodes are created during parsing, each representing a     syntactical element of the shader (e.g., functions, variables,     operations).</li> <li>Nodes include details about data types, operations, and     relationships between different code elements.</li> </ul> <p>Output:</p> <ul> <li>A complete AST that can be further analyzed or transformed.</li> </ul> </li> <li> <p>Optimization (AST Optimization)</p> <p>Purpose:</p> <ul> <li>Refines and optimizes the AST for better performance and     efficiency.</li> </ul> <p>Process:</p> <ul> <li>Performs optimizations such as constant folding, dead code     elimination, and loop unrolling.</li> <li>Simplifies expressions and optimizes data structures within the     AST.</li> </ul> <p>Output:</p> <ul> <li>An optimized AST ready for code generation.</li> </ul> </li> <li> <p>Code Generation (CodeGen)</p> <p>Purpose:</p> <ul> <li>Translates the optimized AST into the target platform-specific     shader code (HLSL, Metal, OpenGL, etc.).</li> </ul> <p>Process:</p> <ul> <li>The code generation module traverses the AST and converts it     into the corresponding language's syntax.</li> <li>Handles the conversion of functions, variables, and other shader     constructs into the target language.</li> </ul> <p>Output:</p> <ul> <li>Platform-specific shader code that is ready for use in the     target graphics API.</li> </ul> </li> </ol>"},{"location":"pages/graphica/graphica/#workflow-summary","title":"Workflow Summary","text":"<ol> <li>Lexical Analysis: Input shader code is tokenized.</li> <li>Syntax Analysis: Tokens are parsed into an AST.</li> <li>AST Construction: The logical structure of the shader is     represented.</li> <li>Optimization: The AST is refined for performance.</li> <li>Code Generation: Optimized AST is converted into the target shader     language.</li> </ol> <p>This structured approach ensures that the shader code is accurately translated and optimized for different platforms, maintaining both performance and compatibility.</p>"},{"location":"pages/graphica/graphica/#how-it-works","title":"How It Works \ud83d\udee0\ufe0f","text":"<p>The Translator processes CrossGL shader code through several key stages, ensuring a smooth and efficient transformation :</p> <p>| 1.Parsing \ud83c\udf32 : | The first stage in the CrossGL shader pipeline is the Parsing phase,   where the shader code is meticulously analyzed and broken down into   its constituent parts. This process begins with a lexical analysis,   where the code is tokenized into manageable pieces such as keywords,   identifiers, operators, and literals. These tokens are then passed   through a syntactical analysis to construct the Abstract Syntax Tree   (AST). The AST is a hierarchical, tree-like structure that represents   the logical flow and structure of the shader code. Each node in the   AST corresponds to a construct in the shader, such as variable   declarations, function definitions, and control flow statements. By   converting the code into an AST, CrossGL allows for a clear and   organized representation of the shader's logic, making it easier to   perform further transformations, optimizations, and analyses. This   structured representation serves as the foundation for all subsequent   stages in the shader compilation process.</p> <p>| 2.Intermediate Representation \ud83d\udd17 : | After the AST is generated, the next step is to transform it into an   Intermediate Representation (IR). The IR acts as an abstraction layer   between the high-level CrossGL shader code and the low-level machine   code that will eventually run on the hardware. This representation is   designed to be both flexible and portable, allowing it to adapt to the   specific needs of various graphics APIs like DirectX, Metal, or   Vulkan. The IR retains the logical structure and intent of the   original code while abstracting away platform-specific details, making   it easier to perform optimizations and transformations that are   crucial for efficient execution. Additionally, the IR enables the   CrossGL system to apply uniform optimizations across different   platforms, ensuring that the shader code remains performant regardless   of the target environment. The IR serves as a critical stepping stone,   bridging the gap between the high-level constructs in the shader code   and the low-level instructions required by the graphics hardware.</p> <p>| 3.Code Generation \u2699\ufe0f : | With the IR in place, the process moves on to the Code Generation   stage. Here, the IR is translated into the target backend code   specific to the chosen graphics API, whether it's DirectX for Windows,   Metal for macOS, or Vulkan for cross-platform compatibility. This   stage involves mapping the abstract constructs in the IR to the   concrete syntax and semantics of the target API. The translation   process is designed to preserve the original intent and functionality   of the CrossGL shader code while ensuring that it adheres to the   conventions and requirements of the target platform. During this   phase, the code generator also handles the integration of   platform-specific features and optimizations, such as memory   management, thread synchronization, and resource binding. The result   is a backend-specific shader code that is ready to be compiled and   executed on the target hardware, ensuring that the shader behaves   consistently across different environments.</p> <p>| 4.Optimization \u26a1 : | Once the target backend code is generated, the Optimization phase   begins. This stage is crucial for enhancing the performance of the   shader, ensuring that it runs efficiently on the intended platform.   Various optimization passes are applied to the code, each tailored to   address specific aspects of shader execution. These optimizations may   include reducing the number of instructions, minimizing resource usage   (such as registers and memory), and improving data locality to enhance   execution speed. Additionally, platform-specific optimizations are   applied to take full advantage of the hardware capabilities, such as   parallel processing on GPUs, efficient use of shader cores, and   minimizing latency in data access. The goal of this stage is to   produce a highly optimized shader that not only functions correctly   but also delivers the best possible performance on the target   platform.</p> <p>| 5.Final Output \ud83c\udfaf : | After all the processing and optimization stages are complete, the   Final Output is produced. This is the fully optimized shader code,   ready for integration into your graphics application. Whether the   shader is destined for a game engine, a rendering pipeline, or a   specialized graphics tool, the final output is designed to meet the   highest standards of performance, compatibility, and reliability. The   shader is now in a format that can be directly compiled and executed   by the target platform, ensuring smooth deployment and execution. This   final stage marks the culmination of the CrossGL shader pipeline,   where all the intricate processes of parsing, intermediate   representation, code generation, and optimization come together to   produce a shader that is not only functional but also optimized for   peak performance across different platforms.</p>"},{"location":"pages/graphica/graphica/#cross-platform-bridging-from-platform-specific-to-crossgl-and-back","title":"Cross-Platform Bridging \ud83c\udf09: From Platform-Specific to CrossGL and Back","text":"<p>CrossGL is a versatile tool that goes beyond simple translation from a universal language to platform-specific shaders. It's bidirectional translation capability allows developers to seamlessly convert shaders between platform-specific languages like HLSL, MSL, and GLSL to CrossGL and then back again. This flexibility ensures that your shaders can be consistently optimized, maintained, and deployed across multiple platforms with ease.</p>"},{"location":"pages/graphica/graphica/#two-way-conversion","title":"Two-Way Conversion \ud83d\udd04","text":"<p>With CrossGL, you can not only convert CrossGL code into HLSL for DirectX, MSL for Metal, or GLSL for OpenGL, but you can also take existing shaders written in these platform-specific languages and convert them back into the CrossGL format. This two-way conversion is incredibly powerful for developers who want to: - Standardize shaders across multiple platforms: By converting HLSL, MSL, and GLSL shaders into CrossGL, you can unify your shader code into a single, maintainable format, ensuring consistency and reducing redundancy. - Optimize for multiple platforms: Once shaders are in the CrossGL format, they can be re-translated into any of the supported platform-specific languages, ensuring that they are optimized for the specific needs and performance characteristics of each platform.</p>"},{"location":"pages/graphica/graphica/#unified-shader-management","title":"Unified Shader Management \ud83d\udee0\ufe0f","text":"<p>This bidirectional capability of CrossGL simplifies shader management by allowing you to maintain a single version of your shaders in CrossGL. From this central format, you can easily generate platform-specific shaders for different environments or bring platform-specific shaders into the CrossGL ecosystem for centralized management. This flexibility makes it easier to apply updates, bug fixes, and optimizations across all platforms without having to manually edit each shader individually.</p> <p>A typical CrossGL shader consists of input, output, and the main function. #### Example :<code>shader.cgl</code></p> <pre><code>shader main\n{\n    vertex\n    {\n        input vec3 position;\n        output vec4 color;\n\n        void main()\n        {\n            color = vec4(position, 1.0);\n        }\n    }\n\n    fragment {\n        input vec4 color;\n        output vec4 fragColor;\n\n        void main()\n        {\n            fragColor = color;\n        }\n    }\n}\n</code></pre> <p>Translate to your desired backend : \ud83d\udd2e</p> <pre><code>import crosstl\n\n#Translate to Metal\nmetal_code = crosstl.translate('shader.cgl', backend='metal')\n\n#Translate to DirectX (HLSL)\nhlsl_code = crosstl.translate('shader.cgl', backend='directx')\n\n#Translate to OpenGL\nopengl_code = crosstl.translate('shader.cgl', backend='opengl')\n</code></pre>"},{"location":"pages/graphica/graphica/#converting-from-hlsl-to-crossgl","title":"Converting from HLSL to CrossGL","text":"<ol> <li>write your HLSL shader (e.g., <code>shader.hlsl</code>):</li> </ol> <pre><code>struct VS_INPUT {\nfloat3 position : POSITION;\n};\n\nstruct PS_INPUT {\nfloat4 position : SV_POSITION;\nfloat2 uv : TEXCOORD0;\n};\n\nPS_INPUT VSMain(VS_INPUT input) {\nPS_INPUT output;\noutput.position = float4(input.position, 1.0);\noutput.uv = input.position.xy * 10.0;\nreturn output;\n}\n\nfloat4 PSMain(PS_INPUT input) : SV_TARGET {\nreturn float4(input.uv, 0.0, 1.0);\n}\n</code></pre> <ol> <li>Convert to CrossGL:</li> </ol> <pre><code>import crosstl\n\ncrossgl_code = crosstl.translate('shader.hlsl', backend='cgl')\nprint(crossgl_code)\n</code></pre>"},{"location":"pages/graphica/graphica/#converting-from-metal-to-crossgl","title":"Converting from Metal to CrossGL","text":"<ol> <li>write your Metal shader (e.g., <code>shader.metal</code>):</li> </ol> <pre><code>#include &lt;metal_stdlib&gt;\nusing namespace metal;\n\nstruct VertexInput {\n    float3 position [[attribute(0)]];\n};\n\nstruct VertexOutput {\n    float4 position [[position]];\n    float2 uv;\n};\n\nvertex VertexOutput vertexShader(VertexInput in [[stage_in]]) {\n    VertexOutput out;\n    out.position = float4(in.position, 1.0);\n    out.uv = in.position.xy * 10.0;\n    return out;\n}\n\nfragment float4 fragmentShader(VertexOutput in [[stage_in]]) {\n    return float4(in.uv, 0.0, 1.0);\n}\n</code></pre> <ol> <li>Convert to CrossGL:</li> </ol> <pre><code>import crosstl\n\ncrossgl_code = crosstl.translate('shader.metal', backend='cgl')\nprint(crossgl_code)\n</code></pre>"},{"location":"pages/graphica/graphica/#converting-from-crossgl-to-hlsl","title":"Converting from CrossGL to HLSL","text":"<ol> <li>write your crossGL shader (e.g., <code>shader.cgl</code>):</li> </ol> <pre><code>shader main {\n    vertex {\n        input vec3 position;\n        output vec4 color;\n\n        void main() {\n            color = vec4(position, 1.0);\n        }\n    }\n\n    fragment {\n        input vec4 color;\n        output vec4 fragColor;\n\n        void main() {\n            fragColor = color;\n        }\n    }\n}\n</code></pre> <ol> <li>Convert to HLSL:</li> </ol> <pre><code>import crosstl\n\nhlsl_code = crosstl.translate('shader.cgl', backend='hlsl')\nprint(hlsl_code)\n</code></pre>"},{"location":"pages/graphica/graphica/#converting-from-crossgl-to-metal","title":"Converting from CrossGL to Metal","text":"<ol> <li>write your crossGL shader (e.g., <code>shader.cgl</code>):</li> </ol> <pre><code>shader main {\n    vertex {\n        input vec3 position;\n        output vec4 color;\n\n        void main() {\n            color = vec4(position, 1.0);\n        }\n    }\n\n    fragment {\n        input vec4 color;\n        output vec4 fragColor;\n\n        void main() {\n            fragColor = color;\n        }\n    }\n}\n</code></pre> <ol> <li>Convert to Metal:</li> </ol> <pre><code>import crosstl\n\nmetal_code = crosstl.translate('shader.cgl', backend='metal')\nprint(metal_code)\n</code></pre> <p>These examples will help you get started with CrossGL, enabling smooth translation between different shader languages and seamless integration of existing shaders into your CrossGL workflow. Enjoy your shader coding journey! \u2603\ufe0f\u2728</p>"},{"location":"pages/graphica/graphica/#supported-platforms","title":"Supported Platforms \ud83d\ude80","text":"<p>DirectX: Designed specifically for Windows-based applications, DirectX provides a robust framework for high-performance graphics and multimedia.</p> <p>Metal: Optimized for macOS and iOS, Metal delivers efficient and low-overhead graphics performance, tailored to Apple's hardware.</p> <p>OpenGL: A widely-used, cross-platform API, OpenGL offers broad compatibility and ease of use for developing graphics applications across different platforms, including Windows, macOS, and Linux.</p>"},{"location":"pages/graphica/graphica_contribution/","title":"Contribution Guidelines","text":"<p>We appreciate your interest in contributing to CrossGL. By contributing, you help improve the project and make it more robust and useful for everyone.</p> <pre><code>&lt;div class=\"large-text\"&gt;How to Contribute&lt;/div&gt;\n</code></pre> <p>1. Fork the Repository</p> <p>Start by forking the CrossGL repository on GitHub to your own account.</p> <p>2. Clone Your Fork</p> <p>Clone your forked repository to your local machine.</p> <pre><code>git clone https://github.com/your-username/CrossGL.git\ncd CrossGL\n</code></pre> <p>3. Create a Branch</p> <p>Create a new branch for your changes. Use a descriptive name for your branch.</p> <pre><code>git checkout -b feature-name\n</code></pre> <p>4. Make Changes</p> <p>Make your changes to the codebase. Follow the project\\'s coding style and guidelines. Ensure that your changes do not break existing functionality.</p> <p>5. Add Tests</p> <p>If applicable, add tests for your changes. Ensure that all tests pass before submitting your contribution.</p> <p>6. Commit Your Changes</p> <p>Commit your changes with a clear and concise commit message.</p> <pre><code>git add .\ngit commit -m \"Description of your changes\"\n</code></pre> <p>7. Push to GitHub</p> <p>Push your changes to your forked repository on GitHub.</p> <pre><code>git push origin feature-name\n</code></pre> <p>8. Open a Pull Request</p> <p>Open a pull request on the original repository. Provide a detailed description of your changes and any additional information that may be useful for the reviewers.</p> <pre><code>&lt;div class=\"large-text\"&gt;Contribution Pipeline&lt;/div&gt;\n</code></pre> <ol> <li> <p>Issue Tracking</p> <p>We use GitHub issues to track bugs, enhancements, and tasks. Feel free to open a new issue if you find a bug or have a feature request.</p> </li> <li> <p>Code Review</p> <p>All contributions go through a code review process. The maintainers will review your pull request and provide feedback. Be prepared to make additional changes based on the feedback.</p> </li> <li> <p>Continuous Integration</p> <p>We use Continuous Integration (CI) to run automated tests on all pull requests. Ensure that your code passes all the tests before submitting your pull request.</p> </li> <li> <p>Merging</p> <p>Once your pull request has been reviewed and approved, it will be merged into the main branch.</p> </li> </ol> <pre><code>&lt;div class=\"large-text\"&gt;Thank You \u2728&lt;/div&gt;\n</code></pre> <p>Thank you for your interest in contributing to CrossGL! Your contributions make a significant impact on the project and the community.</p>"},{"location":"pages/graphica/language/","title":"CrossGL Language","text":"<p>CrossGL is a unified, cross-platform shader language that simplifies graphics development across APIs like Vulkan, DirectX, and Metal. It allows developers to write once and compile to native shader languages, ensuring optimal performance and compatibility \ud83d\ude80.</p> <pre><code>&lt;div class=\"large-text\"&gt;Syntax Overview&lt;/div&gt;\n</code></pre> <p>The syntax of CrossGL is designed to be intuitive and similar to Shadertoy, making it easy for developers familiar with Shadertoy to adapt. Below is an overview of the basic syntax and features.</p> <pre><code>&lt;div class=\"large-text\"&gt;Basic Structure&lt;/div&gt;\n</code></pre> <p>A typical CrossGL shader consists of input, output, and the main function.</p> <pre><code>shader main {\n    input vec3 position;\n    output vec4 color;\n\n    void vertex main() {\n        gl_Position = vec4(position, 1.0);\n    }\n\n    void fragment main() {\n        color = vec4(position, 1.0);\n    }\n}\n</code></pre> <pre><code>&lt;div class=\"large-text\"&gt;Data Types&lt;/div&gt;\n</code></pre> <p>CrossGL supports various data types similar to other shader languages. Below is a mapping of some common types:</p> <p>CrossGL              GLSL                 HLSL                     Metal</p> <p>[vec2]{.title-ref}   [vec2]{.title-ref}   [float2]{.title-ref}     [float2]{.title-ref}   [vec3]{.title-ref}   [vec3]{.title-ref}   [float3]{.title-ref}     [float3]{.title-ref}   [vec4]{.title-ref}   [vec4]{.title-ref}   [float4]{.title-ref}     [float4]{.title-ref}   [mat4]{.title-ref}   [mat4]{.title-ref}   [float4x4]{.title-ref}   [float4x4]{.title-ref}</p> <pre><code>&lt;div class=\"large-text\"&gt;Functions and Operations&lt;/div&gt;\n</code></pre> <p>CrossGL provides built-in functions and operations for vector and matrix manipulation, similar to other shader languages.</p> <pre><code>float3 customFunction(float3 random, float factor) {\n    return random * factor;\n}\n\nvoid main() {\n    float3 color = vec3(0.0, 0.0, 0.0);\n    float factor = 1.0;\n\n    if (texCoord.x &gt; 0.5) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    for (int i = 0; i &lt; 3; i++) {\n        factor = factor * 0.5;\n        color = customFunction(color, factor);\n    }\n\n    if (length(color) &gt; 1.0) {\n        color = normalize(color);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n</code></pre>"}]}